(function (msfsSdk, msfsGarminsdk) {
    'use strict';

    /**
     * A set of states for the power of the GNS.
     */
    var PowerState;
    (function (PowerState) {
        PowerState["Off"] = "Off";
        PowerState["Booting"] = "Booting";
        PowerState["SelfTest"] = "SelfTest";
        PowerState["On"] = "On";
        PowerState["OnSkipInit"] = "OnSkipInit";
    })(PowerState || (PowerState = {}));

    /**
     * A GNS Simplified VNav Manager.
     */
    class GNSVNavManager {
        /**
         * Creates an instance of the Garmin VNAV Manager.
         * @param bus The event bus to use with this instance.
         * @param flightPlanner The flight planner to use with this instance.
         * @param apValues are the autopilot ap values.
         * @param primaryPlanIndex The index of the flightplan to follow vertical guidance from.
         * @param options The options to apply to this VNAV manager.
         */
        constructor(bus, flightPlanner, apValues, primaryPlanIndex, options) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.apValues = apValues;
            this.primaryPlanIndex = primaryPlanIndex;
            this.publisher = this.bus.getPublisher();
            this.state = msfsSdk.VNavState.Disabled;
            this.planChanged = false;
            this.fafIndex = undefined;
            this.mapIndex = undefined;
            this.pathMode = msfsSdk.Subject.create(msfsSdk.VNavPathMode.None);
            this.planePos = new msfsSdk.GeoPoint(0, 0);
            this.currentAltitude = 0;
            this.currentGpsAltitude = 0;
            this.approachDetails = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('fms_approach_details'), {
                isLoaded: false,
                type: ApproachType.APPROACH_TYPE_UNKNOWN,
                isRnpAr: false,
                bestRnavType: msfsSdk.RnavTypeFlags.None,
                rnavTypeFlags: msfsSdk.RnavTypeFlags.None,
                isCircling: false,
                isVtf: false,
                referenceFacility: null,
                runway: null
            }, msfsGarminsdk.FmsUtils.approachDetailsEquals);
            this.options = {
                allowPlusVWithoutSbas: true,
                allowApproachBaroVNav: false,
                enableAdvancedVNav: false,
                gpsSystemState: msfsSdk.Subject.create(msfsSdk.GPSSystemState.DiffSolutionAcquired)
            };
            this.glidepathCalculator = new msfsSdk.GlidePathCalculator(this.bus, this.flightPlanner, this.primaryPlanIndex);
            this.todBodDetails = {
                todLegIndex: -1,
                bodLegIndex: -1,
                todLegDistance: 0,
                distanceFromTod: 0,
                distanceFromBod: 0,
                currentConstraintLegIndex: -1
            };
            this.todBodDetailsSub = msfsSdk.ObjectSubject.create(Object.assign({}, this.todBodDetails));
            // Subjects for each vnav var to be set
            this.vnavState = msfsSdk.Subject.create(msfsSdk.VNavState.Enabled_Inactive);
            this.pathAvailable = msfsSdk.Subject.create(false);
            this.currentConstraintAltitude = msfsSdk.Subject.create(null);
            this.nextConstraintAltitude = msfsSdk.Subject.create(null);
            this.targetAltitude = msfsSdk.Subject.create(null);
            this.fpa = msfsSdk.Subject.create(null);
            this.verticalDeviation = msfsSdk.Subject.create(null);
            this.requiredVS = msfsSdk.Subject.create(null);
            this.captureType = msfsSdk.Subject.create(msfsSdk.VNavAltCaptureType.None);
            this.gpVerticalDeviation = msfsSdk.Subject.create(null);
            this.gpDistance = msfsSdk.Subject.create(null);
            this.gpFpa = msfsSdk.Subject.create(null);
            this.gpServiceLevel = msfsSdk.Subject.create(msfsGarminsdk.GlidepathServiceLevel.None);
            this.vnavNextLegTargetAltitude = msfsSdk.Subject.create(null);
            this.cruiseAltitude = msfsSdk.Subject.create(0);
            this.vnavFlightPhase = msfsSdk.Subject.create(msfsGarminsdk.GarminVNavFlightPhase.None);
            this.currentAltitudeConstraintDetails = msfsSdk.Subject.create({ type: msfsSdk.AltitudeRestrictionType.Unused, altitude: 0 }, msfsSdk.VNavUtils.altitudeConstraintDetailsEquals);
            Object.assign(this.options, options);
            this.glidepathServiceLevelCalculator = new msfsGarminsdk.GlidepathServiceLevelCalculator(this.options.allowPlusVWithoutSbas, this.options.allowApproachBaroVNav, false, this.options.gpsSystemState, this.approachDetails);
            const lnav = this.bus.getSubscriber();
            this.lnavLegIndex = msfsSdk.ConsumerSubject.create(lnav.on('lnav_tracked_leg_index'), 0);
            this.lnavLegDistanceAlong = msfsSdk.ConsumerSubject.create(lnav.on('lnav_leg_distance_along'), 0);
            this.bus.getSubscriber().on('indicated_alt').handle(alt => this.currentAltitude = alt);
            const gnss = this.bus.getSubscriber();
            gnss.on('gps-position').handle(lla => {
                this.planePos.set(lla.lat, lla.long);
                this.currentGpsAltitude = msfsSdk.UnitType.METER.convertTo(lla.alt, msfsSdk.UnitType.FOOT);
            });
            const fpl = this.bus.getSubscriber();
            fpl.on('fplLegChange').handle(e => this.onPlanChanged(e.planIndex));
            fpl.on('fplSegmentChange').handle(e => this.onPlanChanged(e.planIndex));
            this.approachDetails.setConsumer(bus.getSubscriber().on('fms_approach_details'));
            this.gpSupported = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('approach_supports_gp'), false);
            this.apValues.approachHasGP.sub(v => {
                this.bus.getPublisher().pub('gp_available', v, true);
            });
            this.monitorVars();
            this.setState(msfsSdk.VNavState.Disabled);
        }
        /** @inheritdoc */
        setState(vnavState) {
            this.state = vnavState;
        }
        /** @inheritdoc */
        tryActivate() {
            // noop
        }
        /** @inheritdoc */
        tryDeactivate() {
            // noop
        }
        /** @inheritdoc */
        canVerticalModeActivate() {
            return true;
        }
        /** @inheritdoc */
        onPathDirectorDeactivated() {
            // noop
        }
        /**
         * Method to call when VNAV Encounters a failed state.
         */
        failed() {
            this.resetGpVars();
            this.resetVNavVars();
        }
        /**
         * Sets planChanged to true to flag that a plan change has been received over the bus.
         * @param planIndex The Plan Index that changed.
         */
        onPlanChanged(planIndex) {
            if (planIndex === this.primaryPlanIndex) {
                this.planChanged = true;
            }
        }
        /**
         * Updates the VNAV director.
         */
        update() {
            if (!this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
                return;
            }
            const lateralPlan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
            const lateralLegIndex = this.lnavLegIndex.get();
            const alongLegDistance = msfsSdk.UnitType.NMILE.convertTo(this.lnavLegDistanceAlong.get(), msfsSdk.UnitType.METER);
            if (lateralPlan.length > 0 && lateralLegIndex < lateralPlan.length) {
                if (this.planChanged) {
                    this.fafIndex = msfsSdk.VNavUtils.getFafIndex(lateralPlan);
                    if (this.fafIndex !== undefined) {
                        this.mapIndex = msfsSdk.VNavUtils.getMissedApproachLegIndex(lateralPlan);
                        if (this.mapIndex <= this.fafIndex) {
                            this.fafIndex = undefined;
                            this.mapIndex = undefined;
                        }
                    }
                    this.planChanged = false;
                }
                this.apValues.approachHasGP.set(this.manageGP(lateralPlan, alongLegDistance));
            }
            else {
                this.failed();
            }
            if (this.apValues.approachHasGP.get() === false) {
                this.resetGpVars();
            }
        }
        /**
         * Method to monitor VNavVars.
         */
        monitorVars() {
            // init vnav vars
            this.initVars();
            this.pathMode.sub(mode => {
                SimVar.SetSimVarValue(msfsSdk.VNavVars.PathMode, msfsSdk.SimVarValueType.Number, mode);
            });
            this.vnavState.sub(state => SimVar.SetSimVarValue(msfsSdk.VNavVars.VNAVState, msfsSdk.SimVarValueType.Number, state));
            this.pathAvailable.sub(v => SimVar.SetSimVarValue(msfsSdk.VNavVars.PathAvailable, msfsSdk.SimVarValueType.Bool, v));
            this.currentConstraintAltitude.sub(alt => SimVar.SetSimVarValue(msfsSdk.VNavVars.CurrentConstraintAltitude, msfsSdk.SimVarValueType.Feet, alt !== null && alt !== void 0 ? alt : -1));
            this.nextConstraintAltitude.sub(alt => SimVar.SetSimVarValue(msfsSdk.VNavVars.NextConstraintAltitude, msfsSdk.SimVarValueType.Feet, alt !== null && alt !== void 0 ? alt : -1));
            this.targetAltitude.sub(alt => SimVar.SetSimVarValue(msfsSdk.VNavVars.TargetAltitude, msfsSdk.SimVarValueType.Feet, alt !== null && alt !== void 0 ? alt : -1));
            this.fpa.sub(fpa => SimVar.SetSimVarValue(msfsSdk.VNavVars.FPA, msfsSdk.SimVarValueType.Degree, fpa !== null && fpa !== void 0 ? fpa : 0));
            this.verticalDeviation.sub(dev => SimVar.SetSimVarValue(msfsSdk.VNavVars.VerticalDeviation, msfsSdk.SimVarValueType.Feet, dev !== null && dev !== void 0 ? dev : Number.MAX_SAFE_INTEGER));
            this.requiredVS.sub(vs => SimVar.SetSimVarValue(msfsSdk.VNavVars.RequiredVS, msfsSdk.SimVarValueType.FPM, vs !== null && vs !== void 0 ? vs : 0));
            this.captureType.sub(type => SimVar.SetSimVarValue(msfsSdk.VNavVars.CaptureType, msfsSdk.SimVarValueType.Number, type));
            this.gpVerticalDeviation.sub(dev => SimVar.SetSimVarValue(msfsSdk.VNavVars.GPVerticalDeviation, msfsSdk.SimVarValueType.Feet, dev !== null && dev !== void 0 ? dev : -1001));
            this.gpDistance.sub(dis => SimVar.SetSimVarValue(msfsSdk.VNavVars.GPDistance, msfsSdk.SimVarValueType.Meters, dis !== null && dis !== void 0 ? dis : -1));
            this.gpFpa.sub(fpa => SimVar.SetSimVarValue(msfsSdk.VNavVars.GPFpa, msfsSdk.SimVarValueType.Degree, fpa !== null && fpa !== void 0 ? fpa : 0));
            this.gpServiceLevel.sub(gpServiceLevel => SimVar.SetSimVarValue(msfsSdk.VNavVars.GPServiceLevel, msfsSdk.SimVarValueType.Number, gpServiceLevel));
            this.vnavNextLegTargetAltitude.sub(v => {
                this.publisher.pub('vnav_active_leg_alt', v !== null && v !== void 0 ? v : 0, true, true);
            }, true);
            this.currentAltitudeConstraintDetails.sub(v => {
                this.publisher.pub('vnav_altitude_constraint_details', v, true, true);
            }, true);
            this.cruiseAltitude.sub(v => {
                this.publisher.pub('vnav_cruise_altitude', v, true, true);
            }, true);
            this.vnavFlightPhase.sub(v => {
                this.publisher.pub('vnav_flight_phase', v, true, true);
            }, true);
        }
        /**
         * Method to reset VNAV Vars.
         */
        initVars() {
            SimVar.SetSimVarValue(msfsSdk.VNavVars.VNAVState, msfsSdk.SimVarValueType.Number, msfsSdk.VNavState.Disabled);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.PathMode, msfsSdk.SimVarValueType.Number, msfsSdk.VNavPathMode.None);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.PathAvailable, msfsSdk.SimVarValueType.Bool, false);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.CurrentConstraintAltitude, msfsSdk.SimVarValueType.Feet, -1);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.NextConstraintAltitude, msfsSdk.SimVarValueType.Feet, -1);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.TargetAltitude, msfsSdk.SimVarValueType.Feet, -1);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.FPA, msfsSdk.SimVarValueType.Degree, 0);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.VerticalDeviation, msfsSdk.SimVarValueType.Feet, Number.MAX_SAFE_INTEGER);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.RequiredVS, msfsSdk.SimVarValueType.FPM, 0);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.CaptureType, msfsSdk.SimVarValueType.Number, msfsSdk.VNavAltCaptureType.None);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.GPServiceLevel, msfsSdk.SimVarValueType.Number, msfsGarminsdk.GlidepathServiceLevel.None);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.GPVerticalDeviation, msfsSdk.SimVarValueType.Feet, -1001);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.GPDistance, msfsSdk.SimVarValueType.Meters, -1);
            SimVar.SetSimVarValue(msfsSdk.VNavVars.GPFpa, msfsSdk.SimVarValueType.Degree, 0);
        }
        /**
         * Resets the path-related VNavVars
         */
        resetVNavVars() {
            this.pathAvailable.set(false);
            this.currentConstraintAltitude.set(null);
            this.nextConstraintAltitude.set(null);
            this.currentAltitudeConstraintDetails.set({ type: msfsSdk.AltitudeRestrictionType.Unused, altitude: 0 });
            this.targetAltitude.set(null);
            this.fpa.set(null);
            this.verticalDeviation.set(null);
            this.requiredVS.set(null);
            this.captureType.set(msfsSdk.VNavAltCaptureType.None);
            this.vnavFlightPhase.set(msfsGarminsdk.GarminVNavFlightPhase.None);
        }
        /**
         * Resets the gp-related VNavVars
         */
        resetGpVars() {
            this.gpServiceLevel.set(msfsGarminsdk.GlidepathServiceLevel.None);
            this.gpVerticalDeviation.set(null);
            this.gpDistance.set(null);
            this.gpFpa.set(null);
        }
        /**
         * Manages the GP State and sets required data for GP guidance, returns whether there is a GP.
         * @param lateralPlan The FlightPlan.
         * @param alongLegDistance The Along Leg Distance
         * @returns Whether there is a GP.
         */
        manageGP(lateralPlan, alongLegDistance) {
            if (lateralPlan && this.gpSupported.get()) {
                const activeLateralLeg = this.lnavLegIndex.get();
                if (this.fafIndex !== undefined && this.mapIndex !== undefined && activeLateralLeg >= this.fafIndex && activeLateralLeg <= this.mapIndex) {
                    const gpServiceLevel = this.glidepathServiceLevelCalculator.getServiceLevel();
                    // Note: because the GP available flag is true, we don't have to check for circling approaches
                    this.gpServiceLevel.set(gpServiceLevel);
                    const gpDistance = this.glidepathCalculator.getGlidepathDistance(this.lnavLegIndex.get(), alongLegDistance);
                    this.gpDistance.set(gpDistance);
                    const currentAlt = this.glidepathServiceLevelCalculator.isBaroServiceLevel(gpServiceLevel) ? this.currentAltitude : this.currentGpsAltitude;
                    const desiredGPAltitudeFeet = msfsSdk.UnitType.METER.convertTo(this.glidepathCalculator.getDesiredGlidepathAltitude(gpDistance), msfsSdk.UnitType.FOOT);
                    this.gpVerticalDeviation.set(msfsSdk.MathUtils.clamp(desiredGPAltitudeFeet - currentAlt, -1000, 1000));
                    this.gpFpa.set(this.glidepathCalculator.glidepathFpa);
                    return gpServiceLevel !== msfsGarminsdk.GlidepathServiceLevel.None;
                }
            }
            this.resetGpVars();
            return false;
        }
    }

    /**
     * A GNS Autopilot Configuration.
     */
    class GNSAPConfig {
        /**
         * Instantiates the AP Config for the Autopilot.
         * @param bus is an instance of the Event Bus.
         * @param flightPlanner is an instance of the flight planner.
         * @param disableNavModeArming Whether to disable nav mode arming on this autopilot.
         * @param disableBackcourse Whether to disable backcourse support for this autopilot.
         * @param supportFlightDirector Whether to support a flight director independent from the autopilot state.
         */
        constructor(bus, flightPlanner, disableNavModeArming, disableBackcourse, supportFlightDirector) {
            this.bus = bus;
            this.flightPlanner = flightPlanner;
            this.defaultLateralMode = msfsSdk.APLateralModes.ROLL;
            this.defaultVerticalMode = msfsSdk.APVerticalModes.PITCH;
            this.defaultMaxBankAngle = 27.5;
            this.disableNavModeArming = false;
            this.disableBackcourse = false;
            this.supportFlightDirector = false;
            const defaultRollMode = SimVar.GetSimVarValue('AUTOPILOT DEFAULT ROLL MODE', msfsSdk.SimVarValueType.Number);
            const defaultPitchMode = SimVar.GetSimVarValue('AUTOPILOT DEFAULT PITCH MODE', msfsSdk.SimVarValueType.Number);
            this.disableNavModeArming = disableNavModeArming !== null && disableNavModeArming !== void 0 ? disableNavModeArming : false;
            this.disableBackcourse = disableBackcourse !== null && disableBackcourse !== void 0 ? disableBackcourse : false;
            this.supportFlightDirector = supportFlightDirector !== null && supportFlightDirector !== void 0 ? supportFlightDirector : false;
            switch (defaultRollMode) {
                case 1:
                    this.defaultLateralMode = msfsSdk.APLateralModes.LEVEL;
                    break;
                case 2:
                    this.defaultLateralMode = msfsSdk.APLateralModes.HEADING;
                    break;
                case 3:
                    this.defaultLateralMode = msfsSdk.APLateralModes.ROLL;
                    break;
                default:
                    this.defaultLateralMode = msfsSdk.APLateralModes.NONE;
            }
            switch (defaultPitchMode) {
                case 1:
                    this.defaultVerticalMode = msfsSdk.APVerticalModes.PITCH;
                    break;
                case 2:
                    this.defaultVerticalMode = msfsSdk.APVerticalModes.ALT;
                    break;
                case 3:
                    this.defaultVerticalMode = msfsSdk.APVerticalModes.VS;
                    break;
                default:
                    this.defaultVerticalMode = msfsSdk.APVerticalModes.NONE;
            }
        }
        /** @inheritdoc */
        createHeadingDirector(apValues) {
            return new msfsSdk.APHdgDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createRollDirector(apValues) {
            return new msfsSdk.APRollDirector(apValues, { minBankAngle: 6, maxBankAngle: 22 });
        }
        /** @inheritdoc */
        createWingLevelerDirector(apValues) {
            return new msfsSdk.APLvlDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createGpssDirector(apValues) {
            return new msfsSdk.LNavDirector(this.bus, apValues, this.flightPlanner, new msfsGarminsdk.GarminObsDirector(this.bus, apValues), {
                lateralInterceptCurve: this.lnavInterceptCurve.bind(this),
                disableArming: this.disableNavModeArming
            });
        }
        /** @inheritdoc */
        createVorDirector(apValues) {
            return new msfsSdk.APNavDirector(this.bus, apValues, msfsSdk.APLateralModes.VOR, { lateralInterceptCurve: this.navInterceptCurve.bind(this), disableArming: true });
        }
        /** @inheritdoc */
        createLocDirector(apValues) {
            return new msfsSdk.APNavDirector(this.bus, apValues, msfsSdk.APLateralModes.LOC, { lateralInterceptCurve: this.navInterceptCurve.bind(this) });
        }
        /** @inheritdoc */
        createBcDirector(apValues) {
            if (this.disableBackcourse) {
                return undefined;
            }
            else {
                return new msfsSdk.APBackCourseDirector(this.bus, apValues, {
                    lateralInterceptCurve: (distanceToSource, deflection, xtk, tas) => this.localizerInterceptCurve(xtk, tas)
                });
            }
        }
        /** @inheritdoc */
        createPitchDirector(apValues) {
            return new msfsSdk.APPitchDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createVsDirector(apValues) {
            return new msfsSdk.APVSDirector(apValues);
        }
        /** @inheritdoc */
        createFlcDirector(apValues) {
            return new msfsSdk.APFLCDirector(apValues);
        }
        /** @inheritdoc */
        createAltHoldDirector(apValues) {
            return new msfsSdk.APAltDirector(apValues);
        }
        /** @inheritdoc */
        createAltCapDirector(apValues) {
            return new msfsSdk.APAltCapDirector(apValues);
        }
        /** @inheritdoc */
        createVNavManager(apValues) {
            return new GNSVNavManager(this.bus, this.flightPlanner, apValues, 0, {
                allowApproachBaroVNav: false,
                allowPlusVWithoutSbas: false,
                enableAdvancedVNav: false,
                gpsSystemState: msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('gps_system_state_changed_1'), msfsSdk.GPSSystemState.Searching)
            });
        }
        /** @inheritdoc */
        createGpDirector(apValues) {
            return new msfsSdk.APGPDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createGsDirector(apValues) {
            return new msfsSdk.APGSDirector(this.bus, apValues);
        }
        /** @inheritdoc */
        createNavToNavManager(apValues) {
            return new msfsGarminsdk.GarminNavToNavManager(this.bus, this.flightPlanner, apValues);
        }
        /**
         * Calculates intercept angles for radio nav.
         * @param distanceToSource The distance from the plane to the source of the navigation signal, in nautical miles.
         * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
         * Positive values indicate that the desired track is to the right of the plane.
         * @param xtk The cross-track error of the plane from the desired track, in nautical miles. Positive values indicate
         * indicate that the plane is to the right of the track.
         * @param tas The true airspeed of the plane, in knots.
         * @param isLoc Whether the source of the navigation signal is a localizer. Defaults to `false`.
         * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
         */
        navInterceptCurve(distanceToSource, deflection, xtk, tas, isLoc) {
            if (isLoc) {
                return this.localizerInterceptCurve(xtk, tas);
            }
            else {
                return this.defaultInterceptCurve(xtk, tas);
            }
        }
        /**
         * Calculates intercept angles for LNAV.
         * @param dtk The desired track, in degrees true.
         * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
         * desired track.
         * @param tas The true airspeed of the plane, in knots.
         * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
         */
        lnavInterceptCurve(dtk, xtk, tas) {
            return this.defaultInterceptCurve(xtk, tas);
        }
        /**
         * Calculates intercept angles for localizers.
         * @param xtk The cross-track error of the plane from the desired track, in nautical miles. Positive values indicate
         * indicate that the plane is to the right of the track.
         * @param tas The true airspeed of the plane, in knots.
         * @returns The intercept angle, in degrees, to capture the localizer course.
         */
        localizerInterceptCurve(xtk, tas) {
            const xtkMeters = msfsSdk.UnitType.NMILE.convertTo(xtk, msfsSdk.UnitType.METER);
            const xtkMetersAbs = Math.abs(xtkMeters);
            if (xtkMetersAbs < 4) {
                return 0;
            }
            else if (xtkMetersAbs < 250) {
                return msfsSdk.NavMath.clamp(Math.abs(xtk * 75), 1, 5);
            }
            const turnRadiusMeters = msfsSdk.NavMath.turnRadius(tas, 22.5);
            const interceptAngle = this.calculateTurnBasedInterceptAngle(turnRadiusMeters, xtkMeters);
            return msfsSdk.NavMath.clamp(interceptAngle, 0, 20);
        }
        /**
         * Calculates non-localizer intercept angles.
         * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
         * desired track.
         * @param tas The true airspeed of the plane, in knots.
         * @returns The intercept angle, in degrees, to capture the desired track.
         */
        defaultInterceptCurve(xtk, tas) {
            const xtkMeters = msfsSdk.UnitType.NMILE.convertTo(xtk, msfsSdk.UnitType.METER);
            const xtkMetersAbs = Math.abs(xtkMeters);
            if (xtkMetersAbs < 250) {
                return msfsSdk.NavMath.clamp(Math.abs(xtk * 75), 0, 5);
            }
            const turnRadiusMeters = msfsSdk.NavMath.turnRadius(tas, 22.5);
            const interceptAngle = this.calculateTurnBasedInterceptAngle(turnRadiusMeters, xtkMeters);
            return msfsSdk.NavMath.clamp(interceptAngle, 0, 45);
        }
        /**
         * Calculates an intercept angle to a track such that the intercept course, projected forward from the plane's
         * position, intercepts the desired track at the same point as a constant-radius turn overlapping the plane's
         * position configured to be tangent to the desired track. This has the effect of producing an intercept angle which
         * guarantees a no-overshoot intercept for all initial ground tracks for which a no-overshoot intercept is possible
         * given the specified turn radius and cross-track error.
         *
         * If the magnitude of the cross-track error is greater than twice the turn radius, no constant-radius turn
         * overlapping the plane's position will be tangent to the desired track; in this case the maximum possible intercept
         * angle of 90 degrees is returned.
         * @param turnRadius The turn radius, in the same units as `xtk`.
         * @param xtk The cross-track error, in the same units as `turnRadius`.
         * @returns The calculated intercept angle, in degrees.
         */
        calculateTurnBasedInterceptAngle(turnRadius, xtk) {
            // The following formula is derived by solving for the intercept angle in Euclidean rather than spherical space.
            // The error from this simplification is negligible when turn radius and cross-track are small (less than 1% of
            // earth radius, or ~63km).
            // The Euclidean solution is chosen over the spherical one: asin(sin(xtk) / sqrt(1 - (1 - sin(xtk) * tan(radius))^2))
            // for performance reasons.
            return Math.asin(Math.min(Math.sqrt(Math.abs(xtk) / (2 * turnRadius)), 1)) * Avionics.Utils.RAD2DEG;
        }
    }

    /**
     * A Garmin GNS Generic autopilot.
     */
    class GNSAutopilot extends msfsSdk.Autopilot {
        /**
         * Creates an instance of the GNS Autopilot.
         * @param bus The event bus.
         * @param flightPlanner This autopilot's associated flight planner.
         * @param config This autopilot's configuration.
         * @param stateManager This autopilot's state manager.
         * @param settingsManager The settings manager to pass to altitude preselect system.
         */
        constructor(bus, flightPlanner, config, stateManager, settingsManager) {
            super(bus, flightPlanner, config, stateManager);
            this.settingsManager = settingsManager;
            this.externalAutopilotInstalled = msfsSdk.Subject.create(false);
            this.lateralArmedModeSubject = msfsSdk.Subject.create(msfsSdk.APLateralModes.NONE);
            this.altArmedSubject = msfsSdk.Subject.create(false);
        }
        /** @inheritdoc */
        onAfterUpdate() {
            if (!this.externalAutopilotInstalled.get()) {
                this.updateFma();
            }
            else {
                this.lateralArmedModeSubject.set(this.apValues.lateralArmed.get());
                this.altArmedSubject.set(this.altCapArmed);
            }
        }
        /** @inheritdoc */
        onInitialized() {
            this.bus.pub('vnav_enabled', true);
            this.monitorAdditionalEvents();
        }
        /** @inheritdoc */
        handleApFdStateChange() {
            const ap = this.stateManager.apMasterOn.get();
            const fd = this.stateManager.isFlightDirectorOn.get();
            const apConfig = this.config;
            if (ap && !fd) {
                this.stateManager.setFlightDirector(true);
            }
            else if (!ap && !fd) {
                this.lateralModes.forEach((mode) => {
                    if (mode.state !== msfsSdk.DirectorState.Inactive) {
                        mode.deactivate();
                    }
                });
                this.verticalModes.forEach((mode) => {
                    if (mode.state !== msfsSdk.DirectorState.Inactive) {
                        mode.deactivate();
                    }
                });
                this.apValues.lateralActive.set(msfsSdk.APLateralModes.NONE);
                this.apValues.lateralArmed.set(msfsSdk.APLateralModes.NONE);
                this.apValues.verticalActive.set(msfsSdk.APVerticalModes.NONE);
                this.apValues.verticalArmed.set(msfsSdk.APVerticalModes.NONE);
                this.verticalApproachArmed = msfsSdk.APVerticalModes.NONE;
                this.verticalAltitudeArmed = msfsSdk.APAltitudeModes.NONE;
                this.altCapArmed = false;
            }
            else if (!ap && fd && !apConfig.supportFlightDirector) {
                this.stateManager.setFlightDirector(false);
            }
        }
        /** @inheritdoc */
        monitorAdditionalEvents() {
            //noop
        }
        /**
         * Publishes data for the FMA.
         */
        updateFma() {
            //noop
        }
    }
    GNSAutopilot.ALT_SELECT_OPTIONS = {
        supportMetric: true,
        minValue: msfsSdk.UnitType.FOOT.createNumber(-1000),
        maxValue: msfsSdk.UnitType.FOOT.createNumber(50000),
        inputIncrLargeThreshold: 999,
        incrSmall: msfsSdk.UnitType.FOOT.createNumber(100),
        incrLarge: msfsSdk.UnitType.FOOT.createNumber(1000),
        incrSmallMetric: msfsSdk.UnitType.METER.createNumber(50),
        incrLargeMetric: msfsSdk.UnitType.METER.createNumber(500),
        initToIndicatedAlt: true
    };

    /**
     * A possible status message
     */
    var GnsVnavStatusType;
    (function (GnsVnavStatusType) {
        GnsVnavStatusType[GnsVnavStatusType["None"] = 0] = "None";
        GnsVnavStatusType[GnsVnavStatusType["BeginDescentIn"] = 1] = "BeginDescentIn";
        GnsVnavStatusType[GnsVnavStatusType["DescendToTarget"] = 2] = "DescendToTarget";
    })(GnsVnavStatusType || (GnsVnavStatusType = {}));

    var GnsVnavRefMode;
    (function (GnsVnavRefMode) {
        GnsVnavRefMode[GnsVnavRefMode["Before"] = 0] = "Before";
        GnsVnavRefMode[GnsVnavRefMode["After"] = 1] = "After";
    })(GnsVnavRefMode || (GnsVnavRefMode = {}));
    var GnsVnavTargetAltitudeMode;
    (function (GnsVnavTargetAltitudeMode) {
        GnsVnavTargetAltitudeMode[GnsVnavTargetAltitudeMode["Msl"] = 0] = "Msl";
        GnsVnavTargetAltitudeMode[GnsVnavTargetAltitudeMode["Agl"] = 1] = "Agl";
    })(GnsVnavTargetAltitudeMode || (GnsVnavTargetAltitudeMode = {}));
    const gnsVnavSettings = [
        {
            name: 'target_altitude',
            defaultValue: 1000,
        },
        {
            name: 'target_altitude_mode',
            defaultValue: GnsVnavTargetAltitudeMode.Msl,
        },
        {
            name: 'ref_distance',
            defaultValue: 4,
        },
        {
            name: 'ref_mode',
            defaultValue: GnsVnavRefMode.Before,
        },
        {
            name: 'ref_leg_index',
            defaultValue: 3,
        },
        {
            name: 'profile_vs',
            defaultValue: -400,
        },
        {
            name: 'messages_on',
            defaultValue: true,
        },
    ];
    /**
     * Utility class for retrieving GNS VNAV setting managers.
     */
    class GnsVnavSettingsManager {
        /**
         * Retrieves a setting manager with all VNAV settings.
         * @param bus The event bus.
         * @returns A setting manager with all VNAV settings.
         */
        static getManager(bus) {
            var _a;
            return (_a = GnsVnavSettingsManager.INSTANCE) !== null && _a !== void 0 ? _a : (GnsVnavSettingsManager.INSTANCE = new msfsSdk.DefaultUserSettingManager(bus, gnsVnavSettings));
        }
    }

    /**
     * Store for GNS VNAV
     */
    class GnsVnavStore {
        /**
         * Ctor
         * @param bus the event bus
         */
        constructor(bus) {
            this.bus = bus;
            this.ppos = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('gps-position'), new LatLongAlt(0, 0));
            this.groundSpeed = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('ground_speed'), 0);
            this.currentAltitude = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('pressure_alt'), 0);
            this.currentVerticalSpeed = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('vertical_speed'), 0);
            this.distanceAlongActiveLeg = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('lnav_leg_distance_along'), 0);
            this.obsSuspMode = msfsSdk.ConsumerSubject.create(this.bus.getSubscriber().on('obs_susp_mode'), msfsGarminsdk.ObsSuspModes.NONE);
            this.approachingProfileMessageInhibited = msfsSdk.Subject.create(false);
            this.approachingTargetAltitudeMessageInhibited = msfsSdk.Subject.create(false);
        }
    }

    const VALID_LEG_TYPES = [
        msfsSdk.LegType.AF,
        msfsSdk.LegType.CF,
        msfsSdk.LegType.DF,
        msfsSdk.LegType.IF,
        msfsSdk.LegType.RF,
        msfsSdk.LegType.TF,
    ];
    /**
     * Utils for GNS VNAV
     */
    class GnsVnavUtils {
        /**
         * Returns an array of leg valid as references for GNS VNAV
         *
         * @param plan the flight plan
         *
         * @returns array of {@link GnsVnavRefLegOption} objects
         */
        static getAvailableRefLegs(plan) {
            var _a;
            const legs = [];
            const fromIndex = Math.max(0, plan.activeLateralLeg - 1);
            for (let i = fromIndex; i < plan.length; i++) {
                const leg = plan.tryGetLeg(i);
                if (!leg) {
                    continue;
                }
                const isLegValid = this.isLegValidAsVnavTarget(i, null, plan);
                if (isLegValid) {
                    legs.push({ index: i, ident: (_a = leg.name) !== null && _a !== void 0 ? _a : '' });
                }
            }
            return legs;
        }
        /**
         * Returns if a leg at an index along a flight plan is a valid target leg for VNAV
         *
         * @param legIndex           the leg index
         * @param targetAltitudeMode the target altitude mode being used
         * @param plan               the flight plan
         *
         * @returns boolean
         *
         * @throws if the leg is null
         */
        static isLegValidAsVnavTarget(legIndex, targetAltitudeMode, plan) {
            const leg = plan.tryGetLeg(legIndex);
            if (!leg) {
                throw new Error('GNS VNAV: Leg was null');
            }
            if (msfsSdk.BitFlags.isAll(leg.flags, msfsSdk.LegDefinitionFlags.MissedApproach)) {
                return false;
            }
            const type = leg.leg.type;
            const validType = VALID_LEG_TYPES.includes(type);
            if (!validType) {
                return false;
            }
            if (!leg.leg.fixIcao || leg.leg.fixIcao === msfsSdk.ICAO.emptyIcao) {
                return false;
            }
            if (targetAltitudeMode !== GnsVnavTargetAltitudeMode.Agl || targetAltitudeMode === null) {
                return true;
            }
            const isAirport = this.isLegFixAirport(legIndex, plan);
            if (!isAirport) {
                return false;
            }
            return true;
        }
        /**
         * Returns whether a leg at an index along a flight plan has an airport on its `fixIcao`
         *
         * @param legIndex the leg index
         * @param plan     the flight plan
         *
         * @returns a boolean
         *
         * @throws if the leg is null
         */
        static isLegFixAirport(legIndex, plan) {
            const leg = plan.tryGetLeg(legIndex);
            if (!leg) {
                throw new Error('GNS VNAV: Leg was null');
            }
            if (!leg.leg.fixIcao || leg.leg.fixIcao === msfsSdk.ICAO.emptyIcao) {
                return false;
            }
            return msfsSdk.ICAO.getFacilityType(leg.leg.fixIcao) === msfsSdk.FacilityType.Airport;
        }
        /**
         * Gets the constraint on ref mode for a particular leg index
         *
         * @param legIndex the leg index
         * @param plan     the flight plan
         *
         * @returns a ref mode is it is constrained, `null` otherwise
         */
        static getLegRefModeConstraint(legIndex, plan) {
            if (legIndex === 0) {
                return GnsVnavRefMode.After;
            }
            if (legIndex === plan.length - 1) {
                return GnsVnavRefMode.Before;
            }
            return null;
        }
        /**
         * Returns the cumulative distance of a leg at an index along a flight plan
         *
         * @param legIndex the leg index
         * @param plan     the flight plan
         *
         * @returns distance in metres
         *
         * @throws if the leg or leg calculated is null
         */
        static getLegWaypointCumulativeDistance(legIndex, plan) {
            var _a;
            const leg = plan.tryGetLeg(legIndex);
            if (!leg || !leg.calculated) {
                throw new Error('GNS VNAV: Leg or leg calculated was null');
            }
            return (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions;
        }
        /**
         * Returns the distance of a leg at an index along a flight plan
         *
         * @param legIndex the leg index
         * @param plan     the flight plan
         *
         * @returns distance in metres
         *
         * @throws if the leg or leg calculated is null
         */
        static getLegWaypointDistance(legIndex, plan) {
            var _a;
            const leg = plan.tryGetLeg(legIndex);
            if (!leg || !leg.calculated) {
                throw new Error('GNS VNAV: Leg or leg calculated was null');
            }
            return (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions;
        }
    }

    const GNS_VNAV_MIN_GS = 35;
    const GNS_VNAV_MAX_ABS_VSR = 9999;
    const GNS_VNAV_MIN_ABS_VSR = 100;
    const GNS_VNAV_MAX_VS_FOR_LEVEL_FLIGHT = 100;
    const GNS_VNAV_ALTITUDE_MIN_VS_FOR_DESCENT = 250;
    /**
     * Controller for GNS VNAV
     */
    class GnsVnavController {
        /**
         * Ctor
         * @param bus the event bus
         * @param fms the fms
         */
        constructor(bus, fms) {
            this.bus = bus;
            this.fms = fms;
            this.cachedIcaoElevations = new Map();
            this.gnsVnavSettings = GnsVnavSettingsManager.getManager(this.bus);
            this.store = new GnsVnavStore(this.bus);
            this.publisher = this.bus.getPublisher();
            this.targetAltitudeSetting = this.gnsVnavSettings.getSetting('target_altitude');
            this.targetAltitudeModeSetting = this.gnsVnavSettings.getSetting('target_altitude_mode');
            this.refDistanceSetting = this.gnsVnavSettings.getSetting('ref_distance');
            this.refModeSetting = this.gnsVnavSettings.getSetting('ref_mode');
            this.refLegIndexSetting = this.gnsVnavSettings.getSetting('ref_leg_index');
            this.profileVSSetting = this.gnsVnavSettings.getSetting('profile_vs');
            this.messagesEnabledSetting = this.gnsVnavSettings.getSetting('messages_on');
            const sub = this.bus.getSubscriber();
            sub.on('fplCopied').handle((evt) => {
                if (evt.targetPlanIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                    this.publishAvailableRefLegs();
                }
            });
            sub.on('fplLegChange').handle((evt) => {
                if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                    this.publishAvailableRefLegs();
                }
            });
            sub.on('fplActiveLegChange').handle((evt) => {
                if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                    this.publishAvailableRefLegs();
                }
            });
            sub.on('fplLoaded').handle((evt) => {
                if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                    this.publishAvailableRefLegs();
                }
            });
            sub.on('fplCreated').handle((evt) => {
                if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                    this.publishAvailableRefLegs();
                }
            });
            sub.on('fplDeleted').handle((evt) => {
                if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                    this.publishAvailableRefLegs();
                }
            });
            // Disable message inhibit when any settings are changed
            msfsSdk.MappedSubject.create(this.targetAltitudeSetting, this.targetAltitudeModeSetting, this.refDistanceSetting, this.refModeSetting, this.refLegIndexSetting, this.profileVSSetting).sub(() => {
                this.store.approachingProfileMessageInhibited.set(false);
                this.store.approachingTargetAltitudeMessageInhibited.set(false);
            });
        }
        /**
         * Publishes the currently available ref legs
         */
        publishAvailableRefLegs() {
            const availableRefLegs = GnsVnavUtils.getAvailableRefLegs(this.refFlightPlan);
            this.publisher.pub('gnsvnav_available_ref_legs', availableRefLegs);
        }
        /**
         * Get the primary flight plan
         *
         * @returns a flight plan
         */
        get refFlightPlan() {
            return this.fms.getPrimaryFlightPlan();
        }
        /**
         * Update loop
         */
        async update() {
            // Check if all our input data is valid
            const canCalculate = this.isDataValidForCalculation();
            if (!canCalculate) {
                this.publishDataInvalid();
                return;
            }
            this.publisher.pub('gnsvnav_has_input_data', true);
            const refLegIndex = this.refLegIndexSetting.get();
            let targetAltitudeMode = this.targetAltitudeModeSetting.get();
            const targetAltitude = this.targetAltitudeSetting.get();
            let refMode = this.refModeSetting.get();
            const targetLegValid = GnsVnavUtils.isLegValidAsVnavTarget(refLegIndex, targetAltitudeMode, this.refFlightPlan);
            if (!targetLegValid) {
                this.publishDataInvalid();
                return;
            }
            // Check if the selected leg supports AGL, and if not, reset setting to MSL
            const targetLegSupportsAgl = targetLegValid && GnsVnavUtils.isLegFixAirport(refLegIndex, this.refFlightPlan);
            if (targetLegSupportsAgl) {
                this.publisher.pub('gnsvnav_agl_available', true);
            }
            else {
                this.publisher.pub('gnsvnav_agl_available', false);
                if (targetAltitudeMode === GnsVnavTargetAltitudeMode.Agl) {
                    targetAltitudeMode = GnsVnavTargetAltitudeMode.Msl;
                    this.targetAltitudeModeSetting.set(GnsVnavTargetAltitudeMode.Msl);
                }
            }
            // Check what ref modes we support for this leg, and if the current setting conflicts, set it correctly
            const targetLegMandatoryRefMode = GnsVnavUtils.getLegRefModeConstraint(refLegIndex, this.refFlightPlan);
            if (targetLegMandatoryRefMode !== null) {
                this.publisher.pub('gnsvnav_forced_ref_mode', targetLegMandatoryRefMode);
                if (targetLegMandatoryRefMode !== refMode) {
                    this.refModeSetting.set(targetLegMandatoryRefMode);
                    refMode = targetLegMandatoryRefMode;
                }
            }
            else {
                this.publisher.pub('gnsvnav_forced_ref_mode', null);
            }
            // Check if we are in a correct state for VNAV to be calculated
            const conditionsMet = this.areConditionsMeantForVnav();
            if (!conditionsMet) {
                this.publishConditionsNotMet();
                return;
            }
            // Get the final distance from the ref waypoint, considering the ref distance and mode
            const distance = this.getDistanceFromRefInfo(this.refDistanceSetting.get(), refMode, refLegIndex);
            if (distance <= 0) {
                this.publishDataInvalid();
                return;
            }
            const finalTargetAltitudeFeet = await this.getFinalTargetAltitude(targetAltitude, targetAltitudeMode, refLegIndex);
            let currentAltitude = this.store.currentAltitude.get();
            const currentAltitudeRaw = currentAltitude;
            // To avoid large and quick jumps in VSR/time-to-descent, we round the current altitude - to the nearest 10 feet if level,
            // and to the nearest 100 feet otherwise.
            if (this.isLevel()) {
                currentAltitude = Math.round(currentAltitude / 10) * 10;
            }
            else {
                currentAltitude = Math.round(currentAltitude / 100) * 100;
            }
            let groundSpeed = Math.max(GNS_VNAV_MIN_GS, this.store.groundSpeed.get());
            groundSpeed = Math.round(groundSpeed / 2) * 2;
            // Compute VSR
            const vsr = msfsSdk.VNavUtils.getRequiredVs(distance, finalTargetAltitudeFeet, currentAltitude, groundSpeed);
            if (Number.isFinite(vsr)) {
                const absVsr = Math.abs(vsr);
                if (absVsr >= GNS_VNAV_MIN_ABS_VSR && absVsr <= GNS_VNAV_MAX_ABS_VSR) {
                    this.publisher.pub('vnav_path_display', true);
                    this.publisher.pub('gnsvnav_vsr', vsr);
                    this.publisher.pub('vnav_required_vs', vsr);
                }
                else {
                    this.publishConditionsNotMet();
                    return;
                }
            }
            else {
                // Garbage VSR computed
                this.publishDataInvalid();
            }
            // Compute VNAV predictions
            const profileVsSettingValue = this.profileVSSetting.get();
            const profileVs = profileVsSettingValue > 0 ? -profileVsSettingValue : profileVsSettingValue;
            const altitudeChange = targetAltitude - currentAltitude;
            const altitudeChangeRaw = targetAltitude - currentAltitudeRaw;
            const feetRemainingToDescend = altitudeChangeRaw < 0 ? -altitudeChangeRaw : 0;
            // Publish "Approaching Target Altitude" message if needed
            if (this.isDescending() && feetRemainingToDescend > 460 && feetRemainingToDescend < 500) {
                this.publishApproachingTargetAlt();
            }
            const fpa = msfsSdk.VNavUtils.getFpaFromVerticalSpeed(profileVs, groundSpeed);
            const distanceToDescendFT = msfsSdk.VNavUtils.distanceForAltitude(fpa, altitudeChange);
            const distanceToDescendNM = msfsSdk.UnitType.NMILE.convertFrom(distanceToDescendFT, msfsSdk.UnitType.FOOT);
            const distanceUntilStartDescending = Math.max(0, distance - distanceToDescendNM);
            const time = msfsSdk.FlightPlanPredictorUtils.predictTime(groundSpeed, distanceUntilStartDescending);
            if (Number.isFinite(time)) {
                if (time > 0 && altitudeChange < 0) { // The GNS VNAV never predicts a climb
                    // The "Descend to Target" message is shown at exactly one minute from the scheduled descent
                    if (time > 60) {
                        this.publishDescendIn(time);
                    }
                    else {
                        this.publishDescendToTarget();
                    }
                }
                else {
                    this.publishNullStatus();
                }
            }
            else {
                // Garbage TTD computed
                this.publishNullStatus();
            }
        }
        /**
         * Publish events to signal that VNAV cannot be computed (requirements not met)
         */
        publishConditionsNotMet() {
            this.publisher.pub('gnsvnav_has_input_data', true);
            this.publisher.pub('vnav_path_display', false);
            this.publisher.pub('gnsvnav_vsr', Number.MAX_SAFE_INTEGER);
            this.publisher.pub('vnav_required_vs', 0);
            this.publisher.pub('gnsvnav_status', [GnsVnavStatusType.None, -1]);
            return;
        }
        /**
         * Publish events to signal that VNAV was not computed (no FPLN, too big VSR, negative distance, invalid values)
         */
        publishDataInvalid() {
            this.publisher.pub('gnsvnav_has_input_data', false);
            this.publisher.pub('vnav_path_display', false);
            this.publisher.pub('gnsvnav_vsr', Number.MAX_SAFE_INTEGER);
            this.publisher.pub('vnav_required_vs', 0);
            this.publisher.pub('gnsvnav_status', [GnsVnavStatusType.None, -1]);
            return;
        }
        /**
         * Publish events to signal approaching the target altitude
         */
        publishApproachingTargetAlt() {
            const messagesEnabled = this.messagesEnabledSetting.get();
            const messageInhibited = this.store.approachingTargetAltitudeMessageInhibited.get();
            if (messagesEnabled && !messageInhibited) {
                this.bus.getPublisher().pub('alerts_push', {
                    key: 'vnav-approaching-target-alt',
                    message: 'Approaching Target Altitude',
                });
                this.store.approachingTargetAltitudeMessageInhibited.set(true);
            }
        }
        /**
         * Publish events to signal a descent to target in some time
         * @param time the time value
         */
        publishDescendIn(time) {
            this.publisher.pub('gnsvnav_status', [GnsVnavStatusType.BeginDescentIn, time]);
        }
        /**
         * Publish events to signal a descent to target
         */
        publishDescendToTarget() {
            this.publisher.pub('gnsvnav_status', [GnsVnavStatusType.DescendToTarget, -1]);
            const messagesEnabled = this.messagesEnabledSetting.get();
            const messageInhibited = this.store.approachingProfileMessageInhibited.get();
            if (messagesEnabled && !messageInhibited) {
                this.bus.getPublisher().pub('alerts_push', {
                    key: 'vnav-approaching-profile',
                    message: 'Approaching VNAV Profile'
                });
                this.store.approachingProfileMessageInhibited.set(true);
            }
        }
        /**
         * Publish events to signal a null VNAV status
         */
        publishNullStatus() {
            this.publisher.pub('gnsvnav_status', [GnsVnavStatusType.None, -1]);
        }
        /**
         * Returns the current vertical speed to use
         *
         * @returns a number
         */
        getVerticalSpeed() {
            return this.store.currentVerticalSpeed.get();
        }
        /**
         * Return whether the plane is currently considered to be descending
         *
         * @returns a boolean
         */
        isDescending() {
            return this.getVerticalSpeed() < -GNS_VNAV_ALTITUDE_MIN_VS_FOR_DESCENT;
        }
        /**
         * Return whether the plane is currently considered to be in level flight
         *
         * @returns a boolean
         */
        isLevel() {
            return Math.abs(this.getVerticalSpeed()) < GNS_VNAV_MAX_VS_FOR_LEVEL_FLIGHT;
        }
        /**
         * Determines whether VNAV calculations can take place
         *
         * @returns a boolean
         */
        isDataValidForCalculation() {
            const targetAltitude = this.targetAltitudeSetting.get();
            if (targetAltitude < 0) {
                return false;
            }
            const refDistance = this.refDistanceSetting.get();
            if (refDistance < 0) {
                return false;
            }
            const refLegIndex = this.refLegIndexSetting.get();
            if (refLegIndex < 0) {
                return false;
            }
            const hasPrimaryFlightPlan = this.fms.hasPrimaryFlightPlan();
            if (!hasPrimaryFlightPlan) {
                return false;
            }
            const refPlanLegCount = this.refFlightPlan.length;
            if (refLegIndex >= refPlanLegCount) {
                return false;
            }
            const refPlanLegDef = this.refFlightPlan.tryGetLeg(refLegIndex);
            if (!refPlanLegDef || !refPlanLegDef.calculated) {
                return false;
            }
            return true;
        }
        /**
         * Determines whether VNAV can be used
         *
         * @returns a boolean
         */
        areConditionsMeantForVnav() {
            const groundSpeed = this.store.groundSpeed.get();
            if (groundSpeed <= GNS_VNAV_MIN_GS) {
                return false;
            }
            const suspModeActive = this.store.obsSuspMode.get() === msfsGarminsdk.ObsSuspModes.SUSP;
            if (suspModeActive) {
                return false;
            }
            return true;
        }
        /**
         * Computes the final target altitude at the VNAV target
         *
         * @param targetAltitude     the target altitude
         * @param targetAltitudeMode the target altitude mode
         * @param refLegIndex        the leg index the reference waypoint is at
         * @private
         */
        async getFinalTargetAltitude(targetAltitude, targetAltitudeMode, refLegIndex) {
            let finalTargetAltitudeFeet;
            switch (targetAltitudeMode) {
                case GnsVnavTargetAltitudeMode.Msl:
                    finalTargetAltitudeFeet = targetAltitude;
                    break;
                case GnsVnavTargetAltitudeMode.Agl: {
                    const elevation = await this.getAirportLegWaypointAltitude(refLegIndex);
                    finalTargetAltitudeFeet = elevation + targetAltitude;
                }
            }
            return finalTargetAltitudeFeet;
        }
        /**
         * Computes distance from present position to VNAV target
         *
         * @param refDistance     the reference distance entry, in metres
         * @param refDistanceMode the reference mode (before or after)
         * @param refLegIndex     the leg index the reference waypoint is at
         *
         * @returns the distance from PPOS
         */
        getDistanceFromRefInfo(refDistance, refDistanceMode, refLegIndex) {
            const refFlightPlan = this.refFlightPlan;
            let distanceToWaypoint;
            if (refLegIndex > refFlightPlan.activeLateralLeg) {
                // Ref leg is a next leg
                const activeLegCumulativeDistance = GnsVnavUtils.getLegWaypointCumulativeDistance(refFlightPlan.activeLateralLeg, refFlightPlan);
                const refLegCumulativeDistance = GnsVnavUtils.getLegWaypointCumulativeDistance(refLegIndex, refFlightPlan);
                const distanceBetweenLegsMetres = refLegCumulativeDistance - activeLegCumulativeDistance;
                const distanceBetweenLegsNM = msfsSdk.UnitType.NMILE.convertFrom(distanceBetweenLegsMetres, msfsSdk.UnitType.METER);
                const distanceAlongActiveLeg = this.store.distanceAlongActiveLeg.get();
                const activeLegLengthMetres = GnsVnavUtils.getLegWaypointDistance(refFlightPlan.activeLateralLeg, refFlightPlan);
                const activeLegLengthNM = msfsSdk.UnitType.NMILE.convertFrom(activeLegLengthMetres, msfsSdk.UnitType.METER);
                distanceToWaypoint = distanceBetweenLegsNM + (activeLegLengthNM - distanceAlongActiveLeg);
            }
            else if (refLegIndex === refFlightPlan.activeLateralLeg) {
                // Ref leg is TO leg
                const activeLegLengthMetres = GnsVnavUtils.getLegWaypointDistance(refFlightPlan.activeLateralLeg, refFlightPlan);
                const activeLegLengthNM = msfsSdk.UnitType.NMILE.convertFrom(activeLegLengthMetres, msfsSdk.UnitType.METER);
                const distanceAlongActiveLeg = this.store.distanceAlongActiveLeg.get();
                distanceToWaypoint = activeLegLengthNM - distanceAlongActiveLeg;
            }
            else if (refLegIndex === refFlightPlan.activeLateralLeg - 1) {
                // Ref leg is FROM leg
                const distanceAlongActiveLeg = this.store.distanceAlongActiveLeg.get();
                distanceToWaypoint = -distanceAlongActiveLeg;
            }
            else {
                // Ref leg is a previous leg
                if (refFlightPlan.activeLateralLeg > 0) {
                    const fromLegCumulativeDistance = GnsVnavUtils.getLegWaypointCumulativeDistance(refFlightPlan.activeLateralLeg - 1, refFlightPlan);
                    const refLegCumulativeDistance = GnsVnavUtils.getLegWaypointCumulativeDistance(refLegIndex, refFlightPlan);
                    const distanceBetweenLegsMetres = fromLegCumulativeDistance - refLegCumulativeDistance;
                    const distanceBetweenLegsNM = msfsSdk.UnitType.NMILE.convertFrom(distanceBetweenLegsMetres, msfsSdk.UnitType.METER);
                    const distanceAlongActiveLeg = this.store.distanceAlongActiveLeg.get();
                    distanceToWaypoint = -distanceAlongActiveLeg - distanceBetweenLegsNM;
                }
                else {
                    return 0;
                }
            }
            const finalDistance = distanceToWaypoint + (refDistanceMode === GnsVnavRefMode.Before ? -refDistance : refDistance);
            return Math.max(0, finalDistance);
        }
        /**
         * Gets the elevation of a leg (whose `fixIcao` is of an airport) along a flight plan at a leg index
         *
         * @param legIndex the leg index
         *
         * @returns the elevation (0 if it cannot be found), in feet
         */
        async getAirportLegWaypointAltitude(legIndex) {
            var _a;
            const leg = this.refFlightPlan.getLeg(legIndex);
            const legFixIcao = leg.leg.fixIcao;
            if (this.cachedIcaoElevations.has(legFixIcao)) {
                return (_a = this.cachedIcaoElevations.get(legFixIcao)) !== null && _a !== void 0 ? _a : 0;
            }
            const legFixFacilityType = msfsSdk.ICAO.getFacilityType(legFixIcao);
            const legFixIsAirport = legFixFacilityType === msfsSdk.FacilityType.Airport;
            if (!legFixIsAirport) {
                throw new Error('GNS VNAV: Can only get altitude on an airport');
            }
            const airportFacility = await this.fms.facLoader.getFacility(legFixFacilityType, legFixIcao);
            const elevationMeters = msfsSdk.AirportUtils.getElevation(airportFacility);
            const elevationFeet = elevationMeters !== undefined
                ? msfsSdk.UnitType.FOOT.convertFrom(elevationMeters, msfsSdk.UnitType.METER)
                : 0;
            this.cachedIcaoElevations.set(legFixIcao, elevationFeet);
            return elevationFeet;
        }
    }

    /** Possible GNS CDI Modes */
    var GnsCdiMode;
    (function (GnsCdiMode) {
        GnsCdiMode[GnsCdiMode["VLOC"] = 0] = "VLOC";
        GnsCdiMode[GnsCdiMode["GPS"] = 1] = "GPS";
    })(GnsCdiMode || (GnsCdiMode = {}));
    /**
     * An instrument that aggregates and manages CDI source navigation data.
     */
    class CDINavSource {
        /**
         * Creates an instance of CDINavSource.
         * @param bus The event bus to use with this instance.
         * @param gnsCdiMode A subject identifying what the current CDI source for this instrument is.
         */
        constructor(bus, gnsCdiMode) {
            this.bus = bus;
            this.gnsCdiMode = gnsCdiMode;
            this.nav1Source = {
                type: msfsSdk.NavSourceType.Nav,
                index: 1
            };
            this.nav2Source = {
                type: msfsSdk.NavSourceType.Nav,
                index: 2
            };
            this.currentSource = {
                type: msfsSdk.NavSourceType.Nav,
                index: 1
            };
            this.bus.getSubscriber().on('cdi_select').handle(source => {
                this.currentSource = source;
            });
            const gpsDrivesNav1 = SimVar.GetSimVarValue('GPS DRIVES NAV1', msfsSdk.SimVarValueType.Bool);
            this.bus.getPublisher().pub('cdi_select', gpsDrivesNav1 ?
                {
                    type: msfsSdk.NavSourceType.Gps,
                    index: 1
                }
                : {
                    type: msfsSdk.NavSourceType.Nav,
                    index: 1
                }, false, true);
            this.bus.getSubscriber().on('cdi_src_set').handle(this.handleSrcSet.bind(this));
            this.gnsCdiMode.sub(v => {
                SimVar.SetSimVarValue('GPS DRIVES NAV1', msfsSdk.SimVarValueType.Bool, v === GnsCdiMode.GPS);
            });
            this.controlSub = this.bus.getSubscriber();
            this.navEventPub = this.bus.getPublisher();
            this.controlSub.on('set_ap_nav_source').handle(this.handleApNavSet.bind(this));
            this.controlSub.on('gns_cdi_mode').handle(v => {
                if (v.navIndex === 1) {
                    this.nav1Source.type = v.gnsCdiMode === GnsCdiMode.GPS ? msfsSdk.NavSourceType.Gps : msfsSdk.NavSourceType.Nav;
                }
                else if (v.navIndex === 2) {
                    this.nav2Source.type = v.gnsCdiMode === GnsCdiMode.GPS ? msfsSdk.NavSourceType.Gps : msfsSdk.NavSourceType.Nav;
                }
                if (v.navIndex === this.currentSource.index) {
                    this.currentSource = v.navIndex === 1 ? this.nav1Source : this.nav2Source;
                    this.navEventPub.pub('cdi_select', this.currentSource, false, true);
                    SimVar.SetSimVarValue('AUTOPILOT NAV SELECTED', msfsSdk.SimVarValueType.Number, v.navIndex);
                }
            });
        }
        /**
         * Handle an AP nav set event.
         * @param index The index of the new AP nav source.
        .*/
        handleApNavSet(index) {
            if (index === 1) {
                this.currentSource = this.nav1Source;
            }
            else if (index === 2) {
                this.currentSource = this.nav2Source;
            }
            this.navEventPub.pub('cdi_select', this.currentSource, false, true);
            SimVar.SetSimVarValue('AUTOPILOT NAV SELECTED', msfsSdk.SimVarValueType.Number, index);
        }
        /**
         * Handles when the CDI source set event is recieved.
         * @param navSource The NavSourceId.
         */
        handleSrcSet(navSource) {
            // const previousSourceType = this.currentSource.type;
            if (navSource.index === 1) {
                this.nav1Source.type = navSource.type;
                this.currentSource = this.nav1Source;
            }
            else if (navSource.index === 2) {
                this.nav2Source.type = navSource.type;
                this.currentSource = this.nav2Source;
            }
            this.navEventPub.pub('cdi_select', this.currentSource, false, true);
            SimVar.SetSimVarValue('AUTOPILOT NAV SELECTED', msfsSdk.SimVarValueType.Number, this.currentSource.index);
        }
    }

    /**
     * SimVars for the GNS ADS-B mode interface.
     */
    var GNSAdsbSimVars;
    (function (GNSAdsbSimVars) {
        GNSAdsbSimVars["WTGNS_ADSB_OPER"] = "L:WTGNS_ADSB_OPER";
    })(GNSAdsbSimVars || (GNSAdsbSimVars = {}));
    /**
     * An instrument that tracks the state of the ADS-B system.
     */
    class GNSAdsbPublisher extends msfsSdk.SimVarPublisher {
        /**
         * Creates an instance of the GNSAdsbInstrument.
         * @param bus The bus to use with this instrument.
         */
        constructor(bus) {
            super(new Map([
                ['gns_adsb_oper', { name: GNSAdsbSimVars.WTGNS_ADSB_OPER, type: msfsSdk.SimVarValueType.Bool }]
            ]), bus);
        }
    }

    /**
     * Settings for the `nearest_airport_surface_type` key
     */
    var SurfaceTypeOption;
    (function (SurfaceTypeOption) {
        SurfaceTypeOption[SurfaceTypeOption["Any"] = 0] = "Any";
        SurfaceTypeOption[SurfaceTypeOption["HardOnly"] = 1] = "HardOnly";
        SurfaceTypeOption[SurfaceTypeOption["HardOrSoft"] = 2] = "HardOrSoft";
        SurfaceTypeOption[SurfaceTypeOption["Water"] = 3] = "Water";
    })(SurfaceTypeOption || (SurfaceTypeOption = {}));
    const generalSettings = [
        {
            name: 'nearest_airport_criteria_surface_type',
            defaultValue: SurfaceTypeOption.Any,
        },
        {
            name: 'nearest_airport_criteria_min_length',
            defaultValue: 0,
        },
        {
            name: 'com_frequency_spacing',
            defaultValue: msfsSdk.ComSpacing.Spacing833Khz,
        },
        {
            name: 'baroHpa',
            defaultValue: false
        }
    ];
    /**
     * Utility class for retrieving general setting managers.
     */
    class GeneralUserSettingsManager {
        /**
         * Retrieves a setting manager with all general user settings.
         * @param bus The event bus.
         * @returns A setting manager with all general user settings.
         */
        static getManager(bus) {
            var _a;
            return (_a = GeneralUserSettingsManager.INSTANCE) !== null && _a !== void 0 ? _a : (GeneralUserSettingsManager.INSTANCE = new msfsSdk.DefaultUserSettingManager(bus, generalSettings, true));
        }
    }

    var MapSettingsRanges;
    (function (MapSettingsRanges) {
        MapSettingsRanges[MapSettingsRanges["Off"] = 0] = "Off";
        MapSettingsRanges[MapSettingsRanges["FiveHundredFt"] = 1] = "FiveHundredFt";
        MapSettingsRanges[MapSettingsRanges["OneThousandFt"] = 2] = "OneThousandFt";
        MapSettingsRanges[MapSettingsRanges["FifteenHundredFt"] = 3] = "FifteenHundredFt";
        MapSettingsRanges[MapSettingsRanges["TwoThousandFt"] = 4] = "TwoThousandFt";
        MapSettingsRanges[MapSettingsRanges["ThiryFiveHundredFt"] = 5] = "ThiryFiveHundredFt";
        MapSettingsRanges[MapSettingsRanges["OneNm"] = 6] = "OneNm";
        MapSettingsRanges[MapSettingsRanges["OnePointFiveNm"] = 7] = "OnePointFiveNm";
        MapSettingsRanges[MapSettingsRanges["TwoNm"] = 8] = "TwoNm";
        MapSettingsRanges[MapSettingsRanges["ThreePointFiveNm"] = 9] = "ThreePointFiveNm";
        MapSettingsRanges[MapSettingsRanges["FiveNm"] = 10] = "FiveNm";
        MapSettingsRanges[MapSettingsRanges["TenNm"] = 11] = "TenNm";
        MapSettingsRanges[MapSettingsRanges["FifteenNm"] = 12] = "FifteenNm";
        MapSettingsRanges[MapSettingsRanges["TwentyNm"] = 13] = "TwentyNm";
        MapSettingsRanges[MapSettingsRanges["ThirtyFiveNm"] = 14] = "ThirtyFiveNm";
        MapSettingsRanges[MapSettingsRanges["FiftyNm"] = 15] = "FiftyNm";
        MapSettingsRanges[MapSettingsRanges["OneHundredNm"] = 16] = "OneHundredNm";
        MapSettingsRanges[MapSettingsRanges["OneHundredFiftyNm"] = 17] = "OneHundredFiftyNm";
        MapSettingsRanges[MapSettingsRanges["TwoHundredNm"] = 18] = "TwoHundredNm";
        MapSettingsRanges[MapSettingsRanges["ThreeHundredFiftyNm"] = 19] = "ThreeHundredFiftyNm";
        MapSettingsRanges[MapSettingsRanges["FiveHundredNm"] = 20] = "FiveHundredNm";
        MapSettingsRanges[MapSettingsRanges["OneThousandNm"] = 21] = "OneThousandNm";
        MapSettingsRanges[MapSettingsRanges["FifteenHundredNm"] = 22] = "FifteenHundredNm";
        MapSettingsRanges[MapSettingsRanges["TwoThousandNm"] = 23] = "TwoThousandNm";
    })(MapSettingsRanges || (MapSettingsRanges = {}));
    const MapSettingsRangeArrayNM = [
        [MapSettingsRanges.Off, msfsSdk.UnitType.FOOT.createNumber(0)],
        [MapSettingsRanges.FiveHundredFt, msfsSdk.UnitType.FOOT.createNumber(500)],
        [MapSettingsRanges.OneThousandFt, msfsSdk.UnitType.FOOT.createNumber(1000)],
        [MapSettingsRanges.FifteenHundredFt, msfsSdk.UnitType.FOOT.createNumber(1500)],
        [MapSettingsRanges.TwoThousandFt, msfsSdk.UnitType.FOOT.createNumber(2000)],
        [MapSettingsRanges.ThiryFiveHundredFt, msfsSdk.UnitType.FOOT.createNumber(3500)],
        [MapSettingsRanges.OneNm, msfsSdk.UnitType.NMILE.createNumber(1)],
        [MapSettingsRanges.OnePointFiveNm, msfsSdk.UnitType.NMILE.createNumber(1.5)],
        [MapSettingsRanges.TwoNm, msfsSdk.UnitType.NMILE.createNumber(2)],
        [MapSettingsRanges.ThreePointFiveNm, msfsSdk.UnitType.NMILE.createNumber(3.5)],
        [MapSettingsRanges.FiveNm, msfsSdk.UnitType.NMILE.createNumber(5)],
        [MapSettingsRanges.TenNm, msfsSdk.UnitType.NMILE.createNumber(10)],
        [MapSettingsRanges.FifteenNm, msfsSdk.UnitType.NMILE.createNumber(15)],
        [MapSettingsRanges.TwentyNm, msfsSdk.UnitType.NMILE.createNumber(20)],
        [MapSettingsRanges.ThirtyFiveNm, msfsSdk.UnitType.NMILE.createNumber(35)],
        [MapSettingsRanges.FiftyNm, msfsSdk.UnitType.NMILE.createNumber(50)],
        [MapSettingsRanges.OneHundredNm, msfsSdk.UnitType.NMILE.createNumber(100)],
        [MapSettingsRanges.OneHundredFiftyNm, msfsSdk.UnitType.NMILE.createNumber(150)],
        [MapSettingsRanges.TwoHundredNm, msfsSdk.UnitType.NMILE.createNumber(200)],
        [MapSettingsRanges.ThreeHundredFiftyNm, msfsSdk.UnitType.NMILE.createNumber(350)],
        [MapSettingsRanges.FiveHundredNm, msfsSdk.UnitType.NMILE.createNumber(500)],
        [MapSettingsRanges.OneThousandNm, msfsSdk.UnitType.NMILE.createNumber(1000)],
        [MapSettingsRanges.FifteenHundredNm, msfsSdk.UnitType.NMILE.createNumber(1500)],
        [MapSettingsRanges.TwoThousandNm, msfsSdk.UnitType.NMILE.createNumber(2000)]
    ];
    const MapSettingsRangeArrayKM = [
        [MapSettingsRanges.Off, msfsSdk.UnitType.FOOT.createNumber(0)],
        [MapSettingsRanges.FiveHundredFt, msfsSdk.UnitType.METER.createNumber(150)],
        [MapSettingsRanges.OneThousandFt, msfsSdk.UnitType.METER.createNumber(200)],
        [MapSettingsRanges.FifteenHundredFt, msfsSdk.UnitType.METER.createNumber(350)],
        [MapSettingsRanges.TwoThousandFt, msfsSdk.UnitType.METER.createNumber(500)],
        [MapSettingsRanges.ThiryFiveHundredFt, msfsSdk.UnitType.KILOMETER.createNumber(1)],
        [MapSettingsRanges.OneNm, msfsSdk.UnitType.KILOMETER.createNumber(1.5)],
        [MapSettingsRanges.OnePointFiveNm, msfsSdk.UnitType.KILOMETER.createNumber(2)],
        [MapSettingsRanges.TwoNm, msfsSdk.UnitType.KILOMETER.createNumber(3.5)],
        [MapSettingsRanges.ThreePointFiveNm, msfsSdk.UnitType.KILOMETER.createNumber(5)],
        [MapSettingsRanges.FiveNm, msfsSdk.UnitType.KILOMETER.createNumber(10)],
        [MapSettingsRanges.TenNm, msfsSdk.UnitType.KILOMETER.createNumber(15)],
        [MapSettingsRanges.FifteenNm, msfsSdk.UnitType.KILOMETER.createNumber(20)],
        [MapSettingsRanges.TwentyNm, msfsSdk.UnitType.KILOMETER.createNumber(35)],
        [MapSettingsRanges.ThirtyFiveNm, msfsSdk.UnitType.KILOMETER.createNumber(50)],
        [MapSettingsRanges.FiftyNm, msfsSdk.UnitType.KILOMETER.createNumber(100)],
        [MapSettingsRanges.OneHundredNm, msfsSdk.UnitType.KILOMETER.createNumber(150)],
        [MapSettingsRanges.OneHundredFiftyNm, msfsSdk.UnitType.KILOMETER.createNumber(200)],
        [MapSettingsRanges.TwoHundredNm, msfsSdk.UnitType.KILOMETER.createNumber(350)],
        [MapSettingsRanges.ThreeHundredFiftyNm, msfsSdk.UnitType.KILOMETER.createNumber(500)],
        [MapSettingsRanges.FiveHundredNm, msfsSdk.UnitType.KILOMETER.createNumber(1000)],
        [MapSettingsRanges.OneThousandNm, msfsSdk.UnitType.KILOMETER.createNumber(1500)],
        [MapSettingsRanges.FifteenHundredNm, msfsSdk.UnitType.KILOMETER.createNumber(2000)],
        [MapSettingsRanges.TwoThousandNm, msfsSdk.UnitType.KILOMETER.createNumber(3500)]
    ];
    const MapSettingsRangesMapNM = new Map(MapSettingsRangeArrayNM);
    /**
     * Possible waypoint display sizes for the map.
     */
    var MapSettingsWaypointSizes;
    (function (MapSettingsWaypointSizes) {
        MapSettingsWaypointSizes[MapSettingsWaypointSizes["Off"] = 0] = "Off";
        MapSettingsWaypointSizes[MapSettingsWaypointSizes["Small"] = 1] = "Small";
        MapSettingsWaypointSizes[MapSettingsWaypointSizes["Med"] = 2] = "Med";
        MapSettingsWaypointSizes[MapSettingsWaypointSizes["Large"] = 3] = "Large";
    })(MapSettingsWaypointSizes || (MapSettingsWaypointSizes = {}));
    var MapTrafficMode;
    (function (MapTrafficMode) {
        MapTrafficMode["All"] = "All";
        MapTrafficMode["TAAndProximity"] = "TAAndProximity";
        MapTrafficMode["TAOnly"] = "TAOnly";
    })(MapTrafficMode || (MapTrafficMode = {}));
    var MapDeclutterLevel;
    (function (MapDeclutterLevel) {
        MapDeclutterLevel["None"] = "None";
        MapDeclutterLevel["One"] = "One";
        MapDeclutterLevel["Two"] = "Two";
        MapDeclutterLevel["Three"] = "Three";
    })(MapDeclutterLevel || (MapDeclutterLevel = {}));
    /**
     * A settings provider for GNS map settings.
     */
    class MapSettingsProvider extends msfsSdk.DefaultUserSettingManager {
        /**
         * Creates an instance of the MapSettingsProvider.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            super(bus, [
                { name: 'map_orientation', defaultValue: msfsSdk.MapRotation.NorthUp },
                { name: 'map_autozoom', defaultValue: true },
                { name: 'map_arc_declutter_level', defaultValue: MapDeclutterLevel.None },
                { name: 'map_std_declutter_level', defaultValue: MapDeclutterLevel.None },
                { name: 'map_land_data', defaultValue: true },
                { name: 'map_aviation_data', defaultValue: true },
                { name: 'map_terr_aviation_data', defaultValue: true },
                { name: 'map_terr_arc_view_enabled', defaultValue: false },
                { name: 'map_wind_vector', defaultValue: true },
                { name: 'map_arc_nexrad_enabled', defaultValue: false },
                { name: 'map_std_nexrad_enabled', defaultValue: false },
                { name: 'map_traffic_mode', defaultValue: MapTrafficMode.All },
                { name: 'map_traffic_symbol_range', defaultValue: MapSettingsRanges.FiftyNm },
                { name: 'map_traffic_label_range', defaultValue: MapSettingsRanges.TwentyNm },
                { name: 'wpt_fpl_range', defaultValue: MapSettingsRanges.TwoThousandNm },
                { name: 'wpt_large_apt_range', defaultValue: MapSettingsRanges.OneHundredFiftyNm },
                { name: 'wpt_medium_apt_range', defaultValue: MapSettingsRanges.FiftyNm },
                { name: 'wpt_small_apt_range', defaultValue: MapSettingsRanges.TwentyNm },
                { name: 'wpt_int_range', defaultValue: MapSettingsRanges.TenNm },
                { name: 'wpt_ndb_range', defaultValue: MapSettingsRanges.TenNm },
                { name: 'wpt_vor_range', defaultValue: MapSettingsRanges.OneHundredFiftyNm },
                { name: 'wpt_user_range', defaultValue: MapSettingsRanges.OneHundredFiftyNm },
                { name: 'wpt_fpl_size', defaultValue: MapSettingsWaypointSizes.Med },
                { name: 'wpt_large_apt_size', defaultValue: MapSettingsWaypointSizes.Med },
                { name: 'wpt_medium_apt_size', defaultValue: MapSettingsWaypointSizes.Small },
                { name: 'wpt_small_apt_size', defaultValue: MapSettingsWaypointSizes.Small },
                { name: 'wpt_int_size', defaultValue: MapSettingsWaypointSizes.Small },
                { name: 'wpt_ndb_size', defaultValue: MapSettingsWaypointSizes.Small },
                { name: 'wpt_vor_size', defaultValue: MapSettingsWaypointSizes.Small },
                { name: 'wpt_user_size', defaultValue: MapSettingsWaypointSizes.Small },
                { name: 'airspace_classb_range', defaultValue: MapSettingsRanges.OneHundredNm },
                { name: 'airspace_classc_range', defaultValue: MapSettingsRanges.OneHundredNm },
                { name: 'airspace_classd_range', defaultValue: MapSettingsRanges.TwentyNm },
                { name: 'airspace_restricted_range', defaultValue: MapSettingsRanges.OneHundredFiftyNm },
                { name: 'airspace_moa_range', defaultValue: MapSettingsRanges.OneHundredFiftyNm },
                { name: 'airspace_other_range', defaultValue: MapSettingsRanges.OneHundredFiftyNm }
            ], true);
        }
    }

    /**
     * A settings provider for GNS arc map field settings.
     */
    class ArcMapFieldsSettingsProvider extends msfsSdk.DefaultUserSettingManager {
        /**
         * Creates an instance of the ArcMapFieldsSettingsProvider.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            super(bus, [
                { name: 'arcmap_topLeft_field_type', defaultValue: msfsGarminsdk.NavDataFieldType.DesiredTrack },
                { name: 'arcmap_topRight_field_type', defaultValue: msfsGarminsdk.NavDataFieldType.DistanceToWaypoint },
                { name: 'arcmap_bottomLeft_field_type', defaultValue: msfsGarminsdk.NavDataFieldType.GroundSpeed },
                { name: 'arcmap_bottomRight_field_type', defaultValue: msfsGarminsdk.NavDataFieldType.TimeToWaypoint }
            ], true);
        }
    }

    /**
     * A settings provider for GNS standard nav map field settings.
     */
    class StandardNavMapDataFieldsSettingsProvider extends msfsSdk.DefaultUserSettingManager {
        /**
         * Creates an instance of the StandardNavMapDataFieldsSettingsProvider.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            super(bus, [
                { name: 'stdmap_field_1_type', defaultValue: msfsGarminsdk.NavDataFieldType.DistanceToWaypoint, },
                { name: 'stdmap_field_2_type', defaultValue: msfsGarminsdk.NavDataFieldType.DesiredTrack },
                { name: 'stdmap_field_3_type', defaultValue: msfsGarminsdk.NavDataFieldType.GroundTrack },
                { name: 'stdmap_field_4_type', defaultValue: msfsGarminsdk.NavDataFieldType.TimeToWaypoint },
                { name: 'stdmap_field_5_type', defaultValue: msfsGarminsdk.NavDataFieldType.GroundSpeed },
            ], true);
        }
    }

    /**
     * A settings provider for GNS standard nav map field settings.
     */
    class WT430NavInfoFieldsSettingsProvider extends msfsSdk.DefaultUserSettingManager {
        /**
         * Creates an instance of the StandardNavMapDataFieldsSettingsProvider.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            super(bus, [
                { name: 'wt430_navinfo_field_1_type', defaultValue: msfsGarminsdk.NavDataFieldType.CrossTrack },
                { name: 'wt430_navinfo_field_2_type', defaultValue: msfsGarminsdk.NavDataFieldType.DistanceToWaypoint },
                { name: 'wt430_navinfo_field_3_type', defaultValue: msfsGarminsdk.NavDataFieldType.GroundTrack },
                { name: 'wt430_navinfo_field_4_type', defaultValue: msfsGarminsdk.NavDataFieldType.GroundSpeed },
                { name: 'wt430_navinfo_field_5_type', defaultValue: msfsGarminsdk.NavDataFieldType.TimeToWaypoint },
                { name: 'wt430_navinfo_field_6_type', defaultValue: msfsGarminsdk.NavDataFieldType.DesiredTrack }, /* FIXME add ALT field type */
            ], true);
        }
    }

    /**
     * A setting manager that handles GPS settings.
     */
    class GpsSettingsProvider extends msfsSdk.DefaultUserSettingManager {
        /**
         * Creates an instane of the GpsSettingsProvider.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            super(bus, [
                { name: 'sbas_waas_enabled', defaultValue: true },
                { name: 'sbas_egnos_enabled', defaultValue: true },
                { name: 'sbas_gagan_enabled', defaultValue: true },
                { name: 'sbas_msas_enabled', defaultValue: true },
            ], true);
        }
    }

    /**
     * A settings provider that provides access to all settings for the GNS units.
     */
    class GNSSettingsProvider {
        /**
         * Creates an instance of the GNSSettingsProvider.
         * @param bus The event bus to use with this instance.
         */
        constructor(bus) {
            this.generalSettings = GeneralUserSettingsManager.getManager(bus);
            this.map = new MapSettingsProvider(bus);
            this.units = msfsGarminsdk.UnitsUserSettings.getManager(bus);
            this.time = msfsGarminsdk.DateTimeUserSettings.getManager(bus);
            this.arcMapFields = new ArcMapFieldsSettingsProvider(bus);
            this.standardNavMapFields = new StandardNavMapDataFieldsSettingsProvider(bus);
            this.wt430navInfoFields = new WT430NavInfoFieldsSettingsProvider(bus);
            this.traffic = msfsGarminsdk.TrafficUserSettings.getManager(bus);
            this.gps = new GpsSettingsProvider(bus);
            this.vnav = GnsVnavSettingsManager.getManager(bus);
        }
    }

    /**
     * Interaction events available on the GNS430/530 bezel.
     */
    var InteractionEvent;
    (function (InteractionEvent) {
        InteractionEvent["LeftKnobPush"] = "LeftKnobPush";
        InteractionEvent["LeftInnerDec"] = "LeftInnerDec";
        InteractionEvent["LeftInnerInc"] = "LeftInnerInc";
        InteractionEvent["LeftOuterDec"] = "LeftOuterDec";
        InteractionEvent["LeftOuterInc"] = "LeftOuterInc";
        InteractionEvent["RightKnobPush"] = "RightKnobPush";
        InteractionEvent["RightInnerDec"] = "RightInnerDec";
        InteractionEvent["RightInnerInc"] = "RightInnerInc";
        InteractionEvent["RightOuterDec"] = "RightOuterDec";
        InteractionEvent["RightOuterInc"] = "RightOuterInc";
        InteractionEvent["CLRLong"] = "ClrLong";
        InteractionEvent["CLR"] = "Clr";
        InteractionEvent["ENT"] = "Ent";
        InteractionEvent["MENU"] = "Menu";
        InteractionEvent["DirectTo"] = "DirectTo";
        InteractionEvent["RangeDecrease"] = "RangeDecrease";
        InteractionEvent["RangeIncrease"] = "RangeIncrease";
        InteractionEvent["PROC"] = "Proc";
        InteractionEvent["VNAV"] = "Vnav";
        InteractionEvent["FPL"] = "Fpl";
        InteractionEvent["MSG"] = "Msg";
        InteractionEvent["OBS"] = "Obs";
        InteractionEvent["NavSwap"] = "NavSwap";
        InteractionEvent["ComSwap"] = "ComSwap";
        InteractionEvent["CDI"] = "Cdi";
    })(InteractionEvent || (InteractionEvent = {}));
    /**
     * A map of interaction event strings to the event enumeration.
     */
    const InteractionEventMap = new Map([
        ['LeftSmallKnob_Push', InteractionEvent.LeftKnobPush],
        ['LeftSmallKnob_Left', InteractionEvent.LeftInnerDec],
        ['LeftSmallKnob_Right', InteractionEvent.LeftInnerInc],
        ['LeftLargeKnob_Left', InteractionEvent.LeftOuterDec],
        ['LeftLargeKnob_Right', InteractionEvent.LeftOuterInc],
        ['RightSmallKnob_Push', InteractionEvent.RightKnobPush],
        ['RightSmallKnob_Left', InteractionEvent.RightInnerDec],
        ['RightSmallKnob_Right', InteractionEvent.RightInnerInc],
        ['RightLargeKnob_Left', InteractionEvent.RightOuterDec],
        ['RightLargeKnob_Right', InteractionEvent.RightOuterInc],
        ['CLR_Push_Long', InteractionEvent.CLRLong],
        ['CLR_Push', InteractionEvent.CLR],
        ['ENT_Push', InteractionEvent.ENT],
        ['MENU_Push', InteractionEvent.MENU],
        ['DirectTo_Push', InteractionEvent.DirectTo],
        ['RNG_Zoom', InteractionEvent.RangeDecrease],
        ['RNG_Dezoom', InteractionEvent.RangeIncrease],
        ['PROC_Push', InteractionEvent.PROC],
        ['VNAV_Push', InteractionEvent.VNAV],
        ['FPL_Push', InteractionEvent.FPL],
        ['MSG_Push', InteractionEvent.MSG],
        ['OBS_Push', InteractionEvent.OBS],
        ['NAVSWAP_Push', InteractionEvent.NavSwap],
        ['COMSWAP_Push', InteractionEvent.ComSwap],
        ['CDI_Push', InteractionEvent.CDI]
    ]);

    /**
     * A component that display the GNS startup boot screen.
     */
    class StartupScreen extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.logoEl = msfsSdk.FSComponent.createRef();
            this.okButtonEl = msfsSdk.FSComponent.createRef();
            this.screenRefs = [
                msfsSdk.FSComponent.createRef(), msfsSdk.FSComponent.createRef(), msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(), msfsSdk.FSComponent.createRef(), msfsSdk.FSComponent.createRef()
            ];
            this.bootComplete = false;
        }
        /** @inheritdoc */
        onAfterRender() {
            this.resetState();
            this.props.bus.getSubscriber().on('instrument_powered').handle(state => {
                switch (state) {
                    case PowerState.Booting:
                        this.setVisible(true);
                        this.runSequence();
                        break;
                    case PowerState.SelfTest:
                    case PowerState.On:
                    case PowerState.OnSkipInit:
                        this.setVisible(false);
                        this.bootComplete = true;
                        break;
                    default:
                        this.setVisible(false);
                        this.resetState();
                }
            });
        }
        /**
         * Runs the boot screen sequence.
         */
        runSequence() {
            this.phaseTimeout = window.setTimeout(() => {
                this.setVisible(true, this.screenRefs[0]);
                this.phaseTimeout = window.setTimeout(() => {
                    this.setVisible(false, this.screenRefs[0]);
                    this.setVisible(true, this.screenRefs[1]);
                    this.phaseTimeout = window.setTimeout(() => {
                        this.setVisible(false, this.screenRefs[1]);
                        this.setVisible(true, this.screenRefs[2]);
                        this.phaseTimeout = window.setTimeout(() => {
                            this.setVisible(false, this.screenRefs[2]);
                            this.setVisible(true, this.screenRefs[3]);
                            this.phaseTimeout = window.setTimeout(() => {
                                this.setVisible(false, this.screenRefs[3]);
                                this.setVisible(true, this.screenRefs[4]);
                                this.phaseTimeout = window.setTimeout(() => {
                                    this.setVisible(false, this.logoEl);
                                    this.setVisible(false, this.screenRefs[4]);
                                    this.setVisible(true, this.screenRefs[5]);
                                }, 5000);
                            }, 5000);
                        }, 5000);
                    }, 5000);
                }, 10000);
            }, 5000);
        }
        /**
         * Resets the state of the startup screen.
         */
        resetState() {
            this.screenRefs.forEach((v) => this.setVisible(false, v));
            this.setVisible(true, this.logoEl);
            this.bootComplete = false;
            clearTimeout(this.phaseTimeout);
        }
        /**
         * Checks if the boot sequence has completed.
         * @returns True if complete, false otherwise.
         */
        isBooted() {
            return this.bootComplete;
        }
        /**
         * Sets the screen to be visible or not.
         * @param isVisible Whether or not the screen is visible.
         * @param element The element to set visible.
         */
        setVisible(isVisible, element) {
            if (element === undefined) {
                element = this.el;
            }
            if (isVisible) {
                element.instance.classList.remove('hide-element');
            }
            else {
                element.instance.classList.add('hide-element');
            }
        }
        /**
         * Handles when an interaction event is received by the main screen.
         * @param evt The event that was received.
         */
        onInteractionEvent(evt) {
            if (!this.screenRefs[5].instance.classList.contains('hide-element')) {
                switch (evt) {
                    case InteractionEvent.ENT:
                    case InteractionEvent.RightKnobPush:
                        this.bootComplete = true;
                        this.props.bus.getPublisher().pub('instrument_powered', PowerState.SelfTest, false, true);
                }
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: `startup-screen ${this.props.gnsType}`, ref: this.el },
                msfsSdk.FSComponent.buildComponent("img", { class: 'startup-screen-logo', src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/garmin_logo_new.svg', ref: this.logoEl }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'startup-screen-cptext', ref: this.screenRefs[0] },
                    "GNS ",
                    `${this.props.gnsType === 'wt430' ? '430W' : '530W'}`,
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "Copyright 1998-2017",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "Garmin Ltd. or its subs",
                    msfsSdk.FSComponent.buildComponent("br", null)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'startup-screen-cptext', ref: this.screenRefs[1] },
                    "Main SW Version 5.40 - WT 1.1.10",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "GPS SW Version 5.0",
                    msfsSdk.FSComponent.buildComponent("br", null)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'startup-screen-cptext', ref: this.screenRefs[2] },
                    "Land and Terrain Databases",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "Via Microsoft Flight Simulator",
                    msfsSdk.FSComponent.buildComponent("br", null)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'startup-screen-cptext', ref: this.screenRefs[3] },
                    "Aviation Database",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "Via Microsoft Flight Simulator",
                    msfsSdk.FSComponent.buildComponent("br", null)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'startup-screen-cptext', ref: this.screenRefs[4] },
                    "All map and terrain data provided",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "is only to be used as a general",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "reference to your surrounding and",
                    msfsSdk.FSComponent.buildComponent("br", null),
                    "as an aid to situational awareness"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'startup-screen-confirm', ref: this.screenRefs[5] },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("img", { src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/basemap_icon.png' }),
                        "Basemap Land Database via MSFS"),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("img", { src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/terrain_db_icon.png' }),
                        "Terrain Database via MSFS"),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("img", { src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/apt_terrain_db_icon.png' }),
                        "Airport Terrain Database via MSFS"),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("img", { src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/aviation_db_icon.png' }),
                        "Aviation Database via MSFS"),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'startup-ok-button selected-white' }, "OK?"))));
        }
    }

    /// <reference types="@microsoft/msfs-types/js/simvar" />
    /**
     * A component that displays a radio frequency on the left side screen column.
     */
    class RadioFrequency extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.whole = msfsSdk.Subject.create('0');
            this.fract = msfsSdk.Subject.create('0');
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.props.bus.getSubscriber().on('set_frequency').handle(this.onFrequencySet.bind(this));
            if (this.props.type === msfsSdk.RadioType.Com) {
                let frequency = SimVar.GetSimVarValue(`COM ${this.props.standby ? 'STANDBY' : 'ACTIVE'} FREQUENCY:${this.props.index}`, msfsSdk.SimVarValueType.MHz);
                frequency = Math.round(frequency * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
                this.whole.set(Math.floor(frequency).toFixed(0));
                const fractDigits = Math.round(frequency * Math.pow(10, this.props.digits)) % Math.pow(10, this.props.digits);
                this.fract.set(fractDigits.toFixed(0).padStart(this.props.digits, '0'));
            }
        }
        /**
         * Handles when an observed frequency is changed.
         * @param change The frequency change event to observe.
         */
        onFrequencySet(change) {
            if (change.radio.radioType === this.props.type && change.radio.index === this.props.index) {
                let frequency = this.props.standby ? change.radio.standbyFrequency : change.radio.activeFrequency;
                frequency = Math.round(frequency * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
                this.whole.set(Math.floor(frequency).toFixed(0));
                const fractDigits = Math.round(frequency * Math.pow(10, this.props.digits)) % Math.pow(10, this.props.digits);
                this.fract.set(fractDigits.toFixed(0).padStart(this.props.digits, '0'));
            }
        }
        /**
         * Sets the radio frequency component to an active display.
         * @param isActive Whether or not the display should appear active.
         */
        setActive(isActive) {
            if (isActive) {
                this.el.instance.classList.add('active');
            }
            else {
                this.el.instance.classList.remove('active');
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: `radio-frequency ${this.props.type === msfsSdk.RadioType.Nav ? 'centered-value' : ''}`, ref: this.el },
                this.whole,
                ".",
                msfsSdk.FSComponent.buildComponent("span", { class: 'smaller' }, this.fract)));
        }
    }

    /**
     * A component that displays radio frequencies.
     */
    class RadioPane extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.standbyFreq = msfsSdk.FSComponent.createRef();
        }
        /**
         * Sets whether or not the radio field is the active field.
         * @param isActive Whether or not it is active.
         */
        setActive(isActive) {
            this.standbyFreq.instance.setActive(isActive);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'com-pane' },
                msfsSdk.FSComponent.buildComponent("h1", null, this.props.type === msfsSdk.RadioType.Com ? 'COM' : 'VLOC'),
                msfsSdk.FSComponent.buildComponent(RadioFrequency, { bus: this.props.bus, index: this.props.index, type: this.props.type, digits: this.props.type === msfsSdk.RadioType.Com ? 3 : 2 }),
                msfsSdk.FSComponent.buildComponent(RadioFrequency, { bus: this.props.bus, index: this.props.index, type: this.props.type, digits: this.props.type === msfsSdk.RadioType.Com ? 3 : 2, ref: this.standbyFreq, standby: true })));
        }
    }

    /**
     * A component that displays the page group and pager indicator.
     */
    class PageIndicator extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.pagerBoxes = [];
            this.pager = msfsSdk.FSComponent.createRef();
            this.label = msfsSdk.Subject.create('');
        }
        /**
         * Sets the page group data on the page indicator.
         * @param label The label for the page group.
         * @param pages The number of pages in the group.
         */
        setGroupData(label, pages) {
            this.pager.instance.innerText = '';
            this.pagerBoxes.length = 0;
            for (let i = 0; i < pages; i++) {
                this.pagerBoxes.push(this.renderPagerBox().instance);
            }
            this.label.set(label);
        }
        /**
         * Sets the current page number.
         * @param index The current page number.
         */
        setPage(index) {
            for (let i = 0; i < this.pagerBoxes.length; i++) {
                if (i === index) {
                    this.pagerBoxes[i].classList.add('active');
                }
                else {
                    this.pagerBoxes[i].classList.remove('active');
                }
            }
        }
        /**
         * Renders a pager box for the indicator.
         * @returns A pager box reference.
         */
        renderPagerBox() {
            const ref = msfsSdk.FSComponent.createRef();
            msfsSdk.FSComponent.render(msfsSdk.FSComponent.buildComponent("svg", { class: 'pager-box', viewBox: '0 0 6 12', width: '6', height: '12', ref: ref },
                msfsSdk.FSComponent.buildComponent("rect", { x: '0', y: '0', width: '6', height: '12' })), this.pager.instance);
            return ref;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page-indicator' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'page-label' }, this.label),
                msfsSdk.FSComponent.buildComponent("div", { class: 'pager', ref: this.pager })));
        }
    }

    var GNSAlertState;
    (function (GNSAlertState) {
        GNSAlertState[GNSAlertState["NO_ALERTS"] = 0] = "NO_ALERTS";
        GNSAlertState[GNSAlertState["PERSISTENT_ALERTS"] = 1] = "PERSISTENT_ALERTS";
        GNSAlertState[GNSAlertState["NEW_ALERTS"] = 2] = "NEW_ALERTS";
    })(GNSAlertState || (GNSAlertState = {}));
    /**
     * A subject that tracks GNS alert messages.
     */
    class AlertsSubject {
        /**
         * Creates an instance of a AlertsSubject.
         * @param bus An instance of the event bus.
         */
        constructor(bus) {
            this.data = msfsSdk.ArraySubject.create([]);
            this.alertState = msfsSdk.Subject.create(GNSAlertState.NO_ALERTS);
            const sub = bus.getSubscriber();
            sub.on('alerts_push').handle(this.onAlertPushed.bind(this));
            sub.on('alerts_remove').handle(this.onAlertRemoved.bind(this));
            this.publisher = bus.getPublisher();
            this.alertState.sub(state => this.publisher.pub('alerts_status', state, false, true));
        }
        /**
         * A callback called when an alert is pushed on the bus.
         * @param message The alert message that was pushed.
         */
        onAlertPushed(message) {
            const index = this.data.getArray().findIndex(x => x.key === message.key);
            message.isNew = true;
            if (index < 0) {
                this.data.insert(message, 0);
            }
            else {
                this.data.get(index).isNew = true;
            }
            this.alertState.set(GNSAlertState.NEW_ALERTS);
        }
        /**
         * A callback called when an alert is removed from the bus.
         * @param key The key of the alert that was removed.
         */
        onAlertRemoved(key) {
            const index = this.data.getArray().findIndex(x => x.key === key);
            if (index >= 0) {
                this.data.removeAt(index);
            }
            this.updateAlertState();
        }
        /**
         * Method called when the messages are viewed by opening the message dialog.
         */
        onAlertsViewed() {
            if (this.data.length > 0) {
                const alertsArray = this.data.getArray();
                for (let a = this.data.length - 1; a >= 0; a--) {
                    const alert = alertsArray[a];
                    if (!alert.persistent) {
                        this.data.removeAt(a);
                    }
                    else {
                        alert.isNew = false;
                    }
                }
            }
            this.updateAlertState();
        }
        /**
         * Updates the alerts state.
         */
        updateAlertState() {
            if (this.data.length === 0) {
                this.alertState.set(GNSAlertState.NO_ALERTS);
            }
            else {
                const newAlert = this.data.getArray().findIndex(x => x.isNew === true);
                this.alertState.set(newAlert > -1 ? GNSAlertState.NEW_ALERTS : GNSAlertState.PERSISTENT_ALERTS);
            }
        }
        /** @inheritdoc */
        get length() {
            return this.data.length;
        }
        /** @inheritdoc */
        get(index) {
            return this.data.get(index);
        }
        /** @inheritdoc */
        tryGet(index) {
            return this.data.tryGet(index);
        }
        /** @inheritdoc */
        getArray() {
            return this.data.getArray();
        }
        /** @inheritdoc */
        sub(handler, initialNotify = false, paused = false) {
            return this.data.sub(handler, initialNotify, paused);
        }
        /** @inheritdoc */
        unsub(handler) {
            this.data.unsub(handler);
        }
    }

    /**
     * A component that displays and manages the currently selected CDI display source.
     */
    class SelectedCDIDisplaySource extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.cdiLabel = msfsSdk.Subject.create('GPS');
            this.el = msfsSdk.FSComponent.createRef();
        }
        /**
         * Returns the instrument index of the owning instrument
         *
         * @returns a number, 1-indexed
         */
        get instrumentIndex() {
            // const instrumentIndex = this.props.instrumentIndex + 1;
            // ^-- FIXME the instrumentIndex should be the order of appearance of our <Instrument /> tag
            // in panel.xml (relative to all other tags with the same instrument name). However this is currently always 1,
            // since our code (and the panel.cfg files invoking it) do not specify which index of a dual-530 (or dual-430) we are.
            return this.props.instrumentIndex;
        }
        /** @inheritdoc */
        onAfterRender() {
            const gnsType = this.props.gnsType === 'wt430' ? '430' : '530';
            SimVar.SetSimVarValue(`L:AS${gnsType}_CDI_Source_${this.instrumentIndex}`, msfsSdk.SimVarValueType.Bool, true);
            this.el.instance.classList.add('green');
            this.props.gnsCdiMode.sub(v => {
                this.setCdiDisplaySource(v === GnsCdiMode.GPS);
            });
        }
        /**
         * Sets the currently selected CDI display source.
         *
         * @param isGps value
         */
        setCdiDisplaySource(isGps) {
            this.cdiLabel.set(isGps ? 'GPS' : 'VLOC');
            const gnsType = this.props.gnsType === 'wt430' ? '430' : '530';
            SimVar.SetSimVarValue(`L:AS${gnsType}_CDI_Source_${this.instrumentIndex}`, msfsSdk.SimVarValueType.Bool, isGps);
            if (isGps) {
                this.el.instance.classList.add('green');
            }
            else {
                this.el.instance.classList.remove('green');
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'cdi-label', ref: this.el }, this.cdiLabel));
        }
    }

    /**
     * A component that displays the footer bar along the bottom of the GNS.
     */
    class FooterBar extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.pageIndicator = msfsSdk.FSComponent.createRef();
            this.cdiEl = msfsSdk.FSComponent.createRef();
            this.obsLabel = msfsSdk.FSComponent.createRef();
            this.obsLabelText = msfsSdk.Subject.create('OBS');
            this.msgRef = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber().on('alerts_status').handle(this.setMsgStatus.bind(this));
            this.props.bus.getSubscriber().on('obs_susp_mode').handle((mode) => {
                let showLabel = false;
                let labelText = 'OBS';
                switch (mode) {
                    case msfsGarminsdk.ObsSuspModes.OBS:
                        showLabel = true;
                        labelText = 'OBS';
                        break;
                    case msfsGarminsdk.ObsSuspModes.SUSP:
                        showLabel = true;
                        labelText = 'SUSP';
                        break;
                    default:
                    case msfsGarminsdk.ObsSuspModes.NONE:
                        showLabel = false;
                        break;
                }
                this.obsLabel.instance.classList.toggle('hidden-element', !showLabel);
                this.obsLabelText.set(labelText);
            });
        }
        /**
         * Handles when the page is changed.
         * @param index The new page index.
         */
        onPageChanged(index) {
            this.pageIndicator.instance.setPage(index);
        }
        /**
         * Handles when the page group is changed.
         * @param label The new page group label.
         * @param pages The new page group total number of pages.
         */
        onPageGroupChanged(label, pages) {
            this.pageIndicator.instance.setGroupData(label, pages);
        }
        /**
         * Sets the MSG text animation state.
         * @param state either the message is flashing or not
         */
        setMsgStatus(state) {
            switch (state) {
                case GNSAlertState.NEW_ALERTS:
                    this.msgRef.instance.classList.remove('hidden-element');
                    this.msgRef.instance.classList.add('selected-yellow');
                    break;
                case GNSAlertState.PERSISTENT_ALERTS:
                    this.msgRef.instance.classList.remove('hidden-element');
                    this.msgRef.instance.classList.remove('selected-yellow');
                    break;
                default:
                    this.msgRef.instance.classList.remove('selected-yellow');
                    this.msgRef.instance.classList.add('hidden-element');
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(SelectedCDIDisplaySource, { ref: this.cdiEl, bus: this.props.bus, gnsType: this.props.gnsType, gnsCdiMode: this.props.gnsCdiMode, instrumentIndex: this.props.instrumentIndex }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'obs-label hidden-element', ref: this.obsLabel }, this.obsLabelText),
                msfsSdk.FSComponent.buildComponent("div", { class: 'msg-label' },
                    msfsSdk.FSComponent.buildComponent("span", { ref: this.msgRef, class: 'msg-yellow-box hidden-element' }, "MSG")),
                msfsSdk.FSComponent.buildComponent(PageIndicator, { ref: this.pageIndicator }),
                msfsSdk.FSComponent.buildComponent(WaypointAlerter, { bus: this.props.bus, gnsType: this.props.gnsType, flightPlanner: this.props.flightPlanner })));
        }
    }
    /**
     * A component that alerts when the waypoint is about to change.
     */
    class WaypointAlerter extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.message = msfsSdk.Subject.create('');
            this.magVar = msfsSdk.ConsumerSubject.create(this.props.bus.getSubscriber().on('magvar'), 0);
            this.alertComputer = new msfsGarminsdk.WaypointAlertComputer(this.props.bus, this.props.flightPlanner, 10);
            this.timeRemaining = msfsSdk.Subject.create(NaN);
            this.alertingState = msfsGarminsdk.WaypointAlertingState.None;
            this.course = NaN;
            this.courseType = msfsGarminsdk.WaypointAlertCourseType.DesiredTrack;
            this.dtkFormatter = (dtk) => {
                if (dtk === undefined) {
                    return '___';
                }
                let rounded = Math.round(msfsSdk.MagVar.trueToMagnetic(dtk, this.magVar.get()));
                rounded = rounded === 0 ? 360 : rounded;
                return `${rounded.toString().padStart(3, '0')}°`;
            };
        }
        /** @inheritdoc */
        onAfterRender() {
            this.props.bus.getSubscriber().on('realTime').handle(() => {
                this.alertComputer.update();
            });
            this.alertComputer.timeRemaining.sub(v => this.timeRemaining.set(Math.ceil(v.number)));
            this.alertComputer.onStateChanged.on((s, ev) => {
                this.alertingState = ev.newState;
                this.course = ev.course;
                this.courseType = ev.courseType;
            });
            this.timeRemaining.sub(() => this.onUpdated());
        }
        /**
         * Responds to changes in the distance remaining to the next egress transition.
         */
        onUpdated() {
            if (this.alertingState !== msfsGarminsdk.WaypointAlertingState.None) {
                this.el.instance.classList.remove('hide-element');
                switch (this.alertingState) {
                    case msfsGarminsdk.WaypointAlertingState.ArrivingAtWaypoint:
                        if (this.timeRemaining.get() > 3) {
                            this.el.instance.classList.add('flashing');
                        }
                        else {
                            this.el.instance.classList.remove('flashing');
                        }
                        this.message.set(this.props.gnsType === 'wt430' ? 'ARRIVING WPT' : 'Arriving at waypoint');
                        break;
                    case msfsGarminsdk.WaypointAlertingState.CourseInSeconds:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `DTK ${this.dtkFormatter(this.course)} ${this.timeRemaining.get()} S`
                            : `Next DTK ${this.dtkFormatter(this.course)} in ${this.timeRemaining.get()} sec`);
                        break;
                    case msfsGarminsdk.WaypointAlertingState.CourseNow:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `DTK ${this.dtkFormatter(this.course)} NOW`
                            : `DTK ${this.dtkFormatter(this.course)} now`);
                        break;
                    case msfsGarminsdk.WaypointAlertingState.HoldDirect:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? 'HOLD DIRECT'
                            : 'Hold direct');
                        break;
                    case msfsGarminsdk.WaypointAlertingState.HoldParallel:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? 'HOLD PARALLEL'
                            : 'Hold parallel');
                        break;
                    case msfsGarminsdk.WaypointAlertingState.HoldTeardrop:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? 'HOLD TEARDROP'
                            : 'Hold teardrop');
                        break;
                    case msfsGarminsdk.WaypointAlertingState.LeftTurnInSeconds:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `LT TO ${this.dtkFormatter(this.course)} ${this.timeRemaining.get()} S`
                            : `Left to ${this.dtkFormatter(this.course)} in ${this.timeRemaining.get()} sec`);
                        break;
                    case msfsGarminsdk.WaypointAlertingState.LeftTurnNow:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `LT TO ${this.dtkFormatter(this.course)} NOW`
                            : `Left to ${this.dtkFormatter(this.course)} now`);
                        break;
                    case msfsGarminsdk.WaypointAlertingState.ParallelTrackEnd:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `PTK END ${this.timeRemaining.get()} S`
                            : `PTK end in ${this.timeRemaining.get()} sec`);
                        break;
                    case msfsGarminsdk.WaypointAlertingState.RightTurnInSeconds:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `RT TO ${this.dtkFormatter(this.course)} ${this.timeRemaining.get()} S`
                            : `Right to ${this.dtkFormatter(this.course)} in ${this.timeRemaining.get()} sec`);
                        break;
                    case msfsGarminsdk.WaypointAlertingState.RightTurnNow:
                        this.el.instance.classList.add('flashing');
                        this.message.set(this.props.gnsType === 'wt430'
                            ? `RT TO ${this.dtkFormatter(this.course)} NOW`
                            : `Right to ${this.dtkFormatter(this.course)} now`);
                        break;
                }
            }
            else {
                this.el.instance.classList.add('hide-element');
            }
        }
        /**
         * Renders the component.
         * @returns The component VNode.
         */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-alerter hide-element', ref: this.el }, this.message));
        }
    }

    /**
     * A component which displays a number with units.
     */
    class GNSNumberUnitDisplay extends msfsSdk.AbstractNumberUnitDisplay {
        constructor() {
            super(...arguments);
            this.numberText = msfsSdk.Subject.create('');
            this.unitText = msfsSdk.Subject.create('');
        }
        /** @inheritdoc */
        onValueChanged(value) {
            this.setDisplay(value, this.displayUnit.get());
        }
        /** @inheritdoc */
        onDisplayUnitChanged(displayUnit) {
            this.setDisplay(this.value.get(), displayUnit);
        }
        /**
         * Displays this component's current value.
         * @param value The current value.
         * @param displayUnit The current display unit.
         */
        setDisplay(value, displayUnit) {
            if (!displayUnit || !value.unit.canConvert(displayUnit)) {
                displayUnit = value.unit;
            }
            const numberText = this.props.formatter(value.asUnit(displayUnit));
            this.numberText.set(numberText);
            this.unitText.set(GNSNumberUnitDisplay.getUnitChar(displayUnit));
        }
        /**
         * Gets a unit type character to display.
         * @param unitType The type of unit that was changed to.
         * @returns The special character that represents the unit type ligature.
         */
        static getUnitChar(unitType) {
            if (unitType.isMagnetic !== undefined) {
                return unitType.isMagnetic() ? 'ï' : 'ð';
            }
            switch (unitType) {
                case msfsSdk.UnitType.FOOT:
                    return 'à';
                case msfsSdk.UnitType.NMILE:
                    return 'á';
                case msfsSdk.UnitType.KPH:
                    return 'â';
                case msfsSdk.UnitType.KILOMETER:
                    return 'ã';
                case msfsSdk.UnitType.MPH:
                    return 'ä';
                case msfsSdk.UnitType.MILE:
                    return 'å';
                case msfsSdk.UnitType.METER:
                    return 'æ';
                case msfsSdk.UnitType.MPM:
                    return 'ç';
                case msfsSdk.UnitType.FPM:
                    return 'è';
                case msfsSdk.UnitType.GALLON || msfsSdk.UnitType.GALLON_FUEL:
                    return 'é';
                case msfsSdk.UnitType.KILOGRAM:
                    return 'ì';
                case msfsSdk.UnitType.LITER:
                    return 'í';
                case msfsSdk.UnitType.POUND:
                    return 'î';
                case msfsSdk.UnitType.DEGREE:
                    return 'ï';
                case msfsSdk.UnitType.IN_HG:
                    return 'À';
                case msfsSdk.UnitType.HPA:
                    return 'Å';
                case msfsSdk.UnitType.CELSIUS:
                    return 'Á';
                case msfsSdk.UnitType.FAHRENHEIT:
                    return 'Â';
                case msfsSdk.UnitType.KNOT:
                    return 'È';
                default:
                    return '';
            }
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' },
                msfsSdk.FSComponent.buildComponent("span", { class: 'numberunit-num' }, this.numberText),
                msfsSdk.FSComponent.buildComponent("span", { class: 'numberunit-unit' }, this.unitText)));
        }
    }
    /**
     * A component that displays a vertical unit character ligature.
     */
    class GNSVerticalUnitDisplay extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.unit = msfsSdk.SubscribableUtils.toSubscribable(this.props.unit, true);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: 'numberunit-unit' }, this.unit.map((v) => GNSNumberUnitDisplay.getUnitChar(v))));
        }
    }

    /**
     * A component that displays the nav radio navigational details.
     */
    class NavInfoPane extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.radialEl = msfsSdk.FSComponent.createRef();
            this.distanceEl = msfsSdk.FSComponent.createRef();
            this.airportEl = msfsSdk.FSComponent.createRef();
            this.runwayEl = msfsSdk.FSComponent.createRef();
            this.radioType = msfsSdk.Subject.create('VOR');
            this.ident = msfsSdk.Subject.create('____');
            this.radial = msfsSdk.ComputedSubject.create(0, this.formatRadial.bind(this));
            this.distance = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(0));
            this.airport = msfsSdk.Subject.create('');
            this.runwayDesignator = msfsSdk.Subject.create('');
            this.runwayNumber = msfsSdk.Subject.create('');
            this.radioPosition = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.dmePosition = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.ppos = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.invalidPos = new msfsSdk.GeoPoint(0, 0);
        }
        /** @inheritdoc */
        onAfterRender() {
            const sub = this.props.bus.getSubscriber();
            sub.on(`nav_lla_${this.props.radioIndex}`).handle(pos => this.radioPosition.set(pos.lat, pos.long));
            sub.on(`nav_dme_lla_${this.props.radioIndex}`).handle(pos => this.dmePosition.set(pos.lat, pos.long));
            sub.on(`nav_ident_${this.props.radioIndex}`).handle(ident => this.ident.set(ident !== '' ? ident : '____'));
            sub.on(`nav_loc_airport_ident_${this.props.radioIndex}`).whenChanged().handle(ident => this.airport.set(ident));
            sub.on(`nav_loc_runway_designator_${this.props.radioIndex}`).whenChanged()
                .handle(designator => this.runwayDesignator.set(msfsSdk.RunwayUtils.getDesignatorLetter(designator)));
            sub.on(`nav_loc_runway_number_${this.props.radioIndex}`).whenChanged().handle(number => this.runwayNumber.set(number.toFixed(0)));
            sub.on('gps-position').handle(pos => this.ppos.set(pos.lat, pos.long));
            this.radioPosition.sub(this.onRadioPositionChanged.bind(this));
            this.dmePosition.sub(this.onRadioPositionChanged.bind(this));
            this.ppos.sub(this.onRadioPositionChanged.bind(this));
            this.runwayDesignator.sub(this.onRadioTypeChanged.bind(this));
            this.runwayNumber.sub(this.onRadioTypeChanged.bind(this));
            this.onRadioTypeChanged();
        }
        /**
         * A callback called when either the radio or present position changes.
         */
        onRadioPositionChanged() {
            const radioValid = !this.radioPosition.get().equals(this.invalidPos);
            const dmeValid = !this.dmePosition.get().equals(this.invalidPos);
            if (radioValid) {
                const distance = msfsSdk.UnitType.GA_RADIAN.convertTo(this.radioPosition.get().distance(this.ppos.get()), msfsSdk.UnitType.NMILE);
                const radial = this.radioPosition.get().bearingTo(this.ppos.get());
                const radialWithMagVar = msfsSdk.MagVar.trueToMagnetic(radial, this.radioPosition.get());
                this.distance.set(distance);
                this.radial.set(Math.round(radialWithMagVar));
            }
            else if (dmeValid) {
                const distance = msfsSdk.UnitType.GA_RADIAN.convertTo(this.dmePosition.get().distance(this.ppos.get()), msfsSdk.UnitType.NMILE);
                const radial = this.dmePosition.get().bearingTo(this.ppos.get());
                const radialWithMagVar = msfsSdk.MagVar.trueToMagnetic(radial, this.dmePosition.get());
                this.distance.set(distance);
                this.radial.set(Math.round(radialWithMagVar));
            }
            else {
                this.distance.set(0);
                this.radial.set(undefined);
            }
        }
        /**
         * Handles when the tuned radio station type changes.
         */
        onRadioTypeChanged() {
            const isLoc = this.runwayNumber.get() !== '0' && this.runwayNumber.get() !== '';
            if (isLoc) {
                this.airportEl.instance.classList.remove('hide-element');
                this.runwayEl.instance.classList.remove('hide-element');
                this.radialEl.instance.classList.add('hide-element');
                this.distanceEl.instance.classList.add('hide-element');
                this.radioType.set('LOC');
            }
            else {
                this.airportEl.instance.classList.add('hide-element');
                this.runwayEl.instance.classList.add('hide-element');
                this.radialEl.instance.classList.remove('hide-element');
                this.distanceEl.instance.classList.remove('hide-element');
                this.radioType.set('VOR');
            }
        }
        /**
         * Formats the nav station radial.
         * @param radial The radial to format.
         * @returns The formatted radial.
         */
        formatRadial(radial) {
            if (radial === undefined) {
                return '___°';
            }
            else {
                return `${radial.toFixed(0).padStart(3, '0')}°`;
            }
        }
        /**
         * Formats the radio nav station distance.
         * @param distance The distance to the nav station.
         * @returns The formatted distance string.
         */
        formatDistance(distance) {
            if (distance === 0) {
                return '__._';
            }
            else if (distance < 100) {
                return distance.toFixed(1);
            }
            else {
                return distance.toFixed(0);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'com-pane navinfo-pane' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'navinfo-ident' },
                    msfsSdk.FSComponent.buildComponent("label", null, this.radioType),
                    msfsSdk.FSComponent.buildComponent("div", null, this.ident)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'navinfo-radial', ref: this.radialEl },
                    msfsSdk.FSComponent.buildComponent("label", null, "RAD"),
                    msfsSdk.FSComponent.buildComponent("div", null, this.radial)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'navinfo-airport', ref: this.airportEl }, this.airport),
                msfsSdk.FSComponent.buildComponent("hr", null),
                msfsSdk.FSComponent.buildComponent("div", { class: 'navinfo-distance', ref: this.distanceEl },
                    msfsSdk.FSComponent.buildComponent("label", null, "DIS"),
                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { value: this.distance, displayUnit: msfsSdk.Subject.create(this.distance.get().unit), formatter: this.formatDistance.bind(this) })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'navinfo-runway', ref: this.runwayEl },
                    "ILS ",
                    msfsSdk.FSComponent.buildComponent("span", null, this.runwayNumber),
                    msfsSdk.FSComponent.buildComponent("span", null, this.runwayDesignator))));
        }
    }

    /**
     * A component that renders a GNS list scrollbar.
     */
    class GNSScrollBar extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.topArrow = msfsSdk.FSComponent.createRef();
            this.bottomArrow = msfsSdk.FSComponent.createRef();
            this.outerBar = msfsSdk.FSComponent.createRef();
            this.innerBar = msfsSdk.FSComponent.createRef();
            this.svg = msfsSdk.FSComponent.createRef();
            this.el = msfsSdk.FSComponent.createRef();
            this.scrollContainer = msfsSdk.FSComponent.createRef();
            this.barMargin = 5;
            this.currentScrollHeight = 0;
            /**
             * Handles when the scrollcontainer is scrolled.
             */
            this.onScroll = () => {
                this.redraw(false);
            };
        }
        /** @inheritdoc */
        onAfterRender() {
            const scrollContainer = this.el.instance.previousElementSibling;
            if (scrollContainer !== null) {
                this.scrollContainer.instance = scrollContainer;
                this.scrollContainer.instance.addEventListener('scroll', this.onScroll);
            }
            const diffAndAdjust = () => {
                if (this.currentScrollHeight !== this.scrollContainer.instance.scrollHeight) {
                    this.redraw(true);
                }
            };
            this.sizeChangeTimer = window.setInterval(diffAndAdjust, 150);
        }
        /**
         * Redraws the SVG components as necessary.
         * @param resetHeight If true, will reset the heights of the scrollbar components.
         */
        redraw(resetHeight) {
            const height = this.scrollContainer.instance.scrollHeight;
            const clientHeight = this.scrollContainer.instance.clientHeight;
            const top = this.scrollContainer.instance.scrollTop;
            const bottom = top + clientHeight;
            if (top === 0) {
                this.topArrow.instance.classList.add('hide-element');
            }
            else {
                this.topArrow.instance.classList.remove('hide-element');
            }
            if (bottom === height) {
                this.bottomArrow.instance.classList.add('hide-element');
            }
            else {
                this.bottomArrow.instance.classList.remove('hide-element');
            }
            //Need two pixels of slop here because Coherent is not precise about scrollHeights sometimes
            if (Math.abs(height - clientHeight) <= 2) {
                this.el.instance.classList.add('hide-element');
            }
            else {
                this.el.instance.classList.remove('hide-element');
            }
            if (resetHeight) {
                this.el.instance.style.height = `${clientHeight}px`;
                this.svg.instance.setAttribute('height', `${clientHeight}px`);
            }
            const barHeight = clientHeight - (this.barMargin * 2);
            const visibleAreaRatio = clientHeight / height;
            const scrollTopPercentage = top / height;
            this.innerBar.instance.setAttribute('transform', `translate(0,${barHeight * scrollTopPercentage})`);
            if (resetHeight) {
                this.outerBar.instance.setAttribute('d', `M 0 5 l 4 0 l 0 ${barHeight} l -4 0 z`);
                this.innerBar.instance.setAttribute('d', `M 0 5 l 4 0 l 0 ${barHeight * visibleAreaRatio} l -4 0 z`);
                this.bottomArrow.instance.setAttribute('transform', `translate(0, ${clientHeight - 2})`);
                this.currentScrollHeight = height;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'scroll-bar', ref: this.el },
                msfsSdk.FSComponent.buildComponent("svg", { ref: this.svg, width: '4px' },
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 2 0 L 0 2 L 4 2 Z', ref: this.topArrow, class: 'scroll-bar-arrow' }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 2 2 L 0 0 L 4 0 Z', ref: this.bottomArrow, transform: 'translate(0,8)', class: 'scroll-bar-arrow' }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 0 5 l 4 0 l 0 4 l -4 0 z', ref: this.outerBar, class: 'scroll-bar-bar' }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 0 5 l 4 0 l 0 4 l -4 0 z', ref: this.innerBar, class: 'scroll-bar-bar filled' }))));
        }
        /** @inheritdoc */
        destroy() {
            if (this.scrollContainer.getOrDefault() !== null) {
                this.scrollContainer.instance.removeEventListener('scroll', this.onScroll);
            }
            if (this.sizeChangeTimer !== undefined) {
                clearInterval(this.sizeChangeTimer);
            }
        }
    }

    /**
     * A UI control implementation for the GNS430/530 hardware controls.
     */
    class GNSUiControl extends msfsSdk.HardwareUiControl {
        /** @inheritdoc */
        onInteractionEvent(evt) {
            switch (evt) {
                case InteractionEvent.RightInnerInc:
                    if (this.props.innerKnobScroll) {
                        return this.scroll('forward');
                    }
                    break;
                case InteractionEvent.RightInnerDec:
                    if (this.props.innerKnobScroll) {
                        return this.scroll('backward');
                    }
                    break;
                case InteractionEvent.RightOuterInc:
                    return this.scroll('forward');
                case InteractionEvent.RightOuterDec:
                    return this.scroll('backward');
            }
            return this.triggerEvent(evt, this);
        }
        /**
         * Handles when the left knob is pushed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftKnobPush(sender) {
            return this.props.onLeftKnobPush ? this.props.onLeftKnobPush(sender) : false;
        }
        /**
         * Handles when the left inner knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftInnerDec(sender) {
            return this.props.onLeftInnerDec ? this.props.onLeftInnerDec(sender) : false;
        }
        /**
         * Handles when the left inner knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftInnerInc(sender) {
            return this.props.onLeftInnerInc ? this.props.onLeftInnerInc(sender) : false;
        }
        /**
         * Handles when the left outer knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftOuterDec(sender) {
            return this.props.onLeftOuterDec ? this.props.onLeftOuterDec(sender) : false;
        }
        /**
         * Handles when the left outer knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftOuterInc(sender) {
            return this.props.onLeftOuterInc ? this.props.onLeftOuterInc(sender) : false;
        }
        /**
         * Handles when the right knob is pushed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightKnobPush(sender) {
            return this.props.onRightKnobPush ? this.props.onRightKnobPush(sender) : false;
        }
        /**
         * Handles when the right inner knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightInnerDec(sender) {
            return this.props.onRightInnerDec ? this.props.onRightInnerDec(sender) : false;
        }
        /**
         * Handles when the right inner knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightInnerInc(sender) {
            return this.props.onRightInnerInc ? this.props.onRightInnerInc(sender) : false;
        }
        /**
         * Handles when the right outer knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightOuterDec(sender) {
            return this.props.onRightOuterDec ? this.props.onRightOuterDec(sender) : false;
        }
        /**
         * Handles when the right outer knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightOuterInc(sender) {
            return this.props.onRightOuterInc ? this.props.onRightOuterInc(sender) : false;
        }
        /**
         * Handles when the CLR button is held down.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onClrLong(sender) {
            return this.props.onClrLong ? this.props.onClrLong(sender) : false;
        }
        /**
         * Handles when the CLR button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onClr(sender) {
            return this.props.onClr ? this.props.onClr(sender) : false;
        }
        /**
         * Handles when the ENT button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onEnt(sender) {
            return this.props.onEnt ? this.props.onEnt(sender) : false;
        }
        /**
         * Handles when the MENU button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onMenu(sender) {
            return this.props.onMenu ? this.props.onMenu(sender) : false;
        }
        /**
         * Handles when the direct-to button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onDirectTo(sender) {
            return this.props.onDirectTo ? this.props.onDirectTo(sender) : false;
        }
        /**
         * Handles when the range decrease button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRangeDecrease(sender) {
            return this.props.onRangeDecrease ? this.props.onRangeDecrease(sender) : false;
        }
        /**
         * Handles when the range increase button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRangeIncrease(sender) {
            return this.props.onRangeIncrease ? this.props.onRangeIncrease(sender) : false;
        }
        /**
         * Handles when the PROC button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onProc(sender) {
            return this.props.onProc ? this.props.onProc(sender) : false;
        }
        /**
         * Handles when the VNAV button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onVnav(sender) {
            return this.props.onVnav ? this.props.onVnav(sender) : false;
        }
        /**
         * Handles when the FPL button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onFpl(sender) {
            return this.props.onFpl ? this.props.onFpl(sender) : false;
        }
        /**
         * Handles when the MSG buttons is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onMsg(sender) {
            return this.props.onMsg ? this.props.onMsg(sender) : false;
        }
        /**
         * Handles when the OBS button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onObs(sender) {
            return this.props.onObs ? this.props.onObs(sender) : false;
        }
        /**
         * Handles when the nav swap button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onNavSwap(sender) {
            return this.props.onNavSwap ? this.props.onNavSwap(sender) : false;
        }
        /**
         * Handles when the com swap button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onComSwap(sender) {
            return this.props.onComSwap ? this.props.onComSwap(sender) : false;
        }
        /**
         * Handles when the CDI button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onCdi(sender) {
            return this.props.onCdi ? this.props.onCdi(sender) : false;
        }
    }
    /**
     * A control list implementation for the GNS430/530 hardware controls.
     */
    class GNSUiControlList extends msfsSdk.HardwareUiControlList {
        /** @inheritdoc */
        onInteractionEvent(evt) {
            switch (evt) {
                case InteractionEvent.RightInnerInc:
                    if (this.props.innerKnobScroll) {
                        return this.scroll('forward');
                    }
                    break;
                case InteractionEvent.RightInnerDec:
                    if (this.props.innerKnobScroll) {
                        return this.scroll('backward');
                    }
                    break;
                case InteractionEvent.RightOuterInc:
                    return this.scroll('forward');
                case InteractionEvent.RightOuterDec:
                    return this.scroll('backward');
            }
            return this.triggerEvent(evt, this);
        }
        /** @inheritdoc */
        renderScrollbar() {
            return (msfsSdk.FSComponent.buildComponent(GNSScrollBar, null));
        }
        /**
         * Handles when the left knob is pushed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftKnobPush(sender) {
            return this.props.onLeftKnobPush ? this.props.onLeftKnobPush(sender) : false;
        }
        /**
         * Handles when the left inner knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftInnerDec(sender) {
            return this.props.onLeftInnerDec ? this.props.onLeftInnerDec(sender) : false;
        }
        /**
         * Handles when the left inner knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftInnerInc(sender) {
            return this.props.onLeftInnerInc ? this.props.onLeftInnerInc(sender) : false;
        }
        /**
         * Handles when the left outer knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftOuterDec(sender) {
            return this.props.onLeftOuterDec ? this.props.onLeftOuterDec(sender) : false;
        }
        /**
         * Handles when the left outer knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onLeftOuterInc(sender) {
            return this.props.onLeftOuterInc ? this.props.onLeftOuterInc(sender) : false;
        }
        /**
         * Handles when the right knob is pushed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightKnobPush(sender) {
            return this.props.onRightKnobPush ? this.props.onRightKnobPush(sender) : false;
        }
        /**
         * Handles when the right inner knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightInnerDec(sender) {
            return this.props.onRightInnerDec ? this.props.onRightInnerDec(sender) : false;
        }
        /**
         * Handles when the right inner knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightInnerInc(sender) {
            return this.props.onRightInnerInc ? this.props.onRightInnerInc(sender) : false;
        }
        /**
         * Handles when the right outer knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightOuterDec(sender) {
            return this.props.onRightOuterDec ? this.props.onRightOuterDec(sender) : false;
        }
        /**
         * Handles when the right outer knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightOuterInc(sender) {
            return this.props.onRightOuterInc ? this.props.onRightOuterInc(sender) : false;
        }
        /**
         * Handles when the CLR button is held down.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onClrLong(sender) {
            return this.props.onClrLong ? this.props.onClrLong(sender) : false;
        }
        /**
         * Handles when the CLR button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onClr(sender) {
            return this.props.onClr ? this.props.onClr(sender) : false;
        }
        /**
         * Handles when the ENT button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onEnt(sender) {
            return this.props.onEnt ? this.props.onEnt(sender) : false;
        }
        /**
         * Handles when the MENU button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onMenu(sender) {
            return this.props.onMenu ? this.props.onMenu(sender) : false;
        }
        /**
         * Handles when the direct-to button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onDirectTo(sender) {
            return this.props.onDirectTo ? this.props.onDirectTo(sender) : false;
        }
        /**
         * Handles when the range decrease button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRangeDecrease(sender) {
            return this.props.onRangeDecrease ? this.props.onRangeDecrease(sender) : false;
        }
        /**
         * Handles when the range increase button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRangeIncrease(sender) {
            return this.props.onRangeIncrease ? this.props.onRangeIncrease(sender) : false;
        }
        /**
         * Handles when the PROC button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onProc(sender) {
            return this.props.onProc ? this.props.onProc(sender) : false;
        }
        /**
         * Handles when the VNAV button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onVnav(sender) {
            return this.props.onVnav ? this.props.onVnav(sender) : false;
        }
        /**
         * Handles when the FPL button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onFpl(sender) {
            return this.props.onFpl ? this.props.onFpl(sender) : false;
        }
        /**
         * Handles when the MSG buttons is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onMsg(sender) {
            return this.props.onMsg ? this.props.onMsg(sender) : false;
        }
        /**
         * Handles when the OBS button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onObs(sender) {
            return this.props.onObs ? this.props.onObs(sender) : false;
        }
        /**
         * Handles when the nav swap button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onNavSwap(sender) {
            return this.props.onNavSwap ? this.props.onNavSwap(sender) : false;
        }
        /**
         * Handles when the com swap button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onComSwap(sender) {
            return this.props.onComSwap ? this.props.onComSwap(sender) : false;
        }
        /**
         * Handles when the CDI button is pressed.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onCdi(sender) {
            return this.props.onCdi ? this.props.onCdi(sender) : false;
        }
    }

    /**
     * A UI control that display a flight plan entry line within the plan table.
     */
    class SelectableText extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.text = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onFocused() {
            var _a;
            this.text.instance.classList.add((_a = this.props.selectedClass) !== null && _a !== void 0 ? _a : 'selected');
        }
        /** @inheritdoc */
        onBlurred() {
            var _a;
            this.text.instance.classList.remove((_a = this.props.selectedClass) !== null && _a !== void 0 ? _a : 'selected');
        }
        /**
         * Sets whether the selectable text is darkened
         *
         * @param isDarkened the desired state to set
         */
        setDarkened(isDarkened) {
            var _a, _b;
            if (isDarkened) {
                this.text.instance.classList.add((_a = this.props.darkenedClass) !== null && _a !== void 0 ? _a : 'darkened');
            }
            else {
                this.text.instance.classList.remove((_b = this.props.darkenedClass) !== null && _b !== void 0 ? _b : 'darkened');
            }
        }
        /**
         * Handles when the right inner knob is decremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightInnerDec(sender) {
            return this.props.onRightInnerDec ? this.props.onRightInnerDec(sender) : false;
        }
        /**
         * Handles when the right inner knob is incremented.
         * @param sender The sender of this event.
         * @returns True if the event was handled, false otherwise.
         */
        onRightInnerInc(sender) {
            return this.props.onRightInnerInc ? this.props.onRightInnerInc(sender) : false;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: this.props.class, style: 'display: inline-block;', ref: this.text }, this.props.data));
        }
    }

    /**
     * A definition of a dialog menu.
     */
    class MenuDefinition {
        constructor() {
            /**
             * The title of the menu.
             */
            this.title = 'Page Menu';
        }
        /**
         * Updates the entries in this menu.
         */
        updateEntries() { }
        /**
         * Sets the label of a menu entry.
         * @param index The index of the menu entry.
         * @param val The value to set.
         */
        setEntryLabel(index, val) {
            const entry = this.entries[index];
            if (typeof entry.label === 'string') {
                entry.label = val;
            }
            else {
                entry.label.set(val);
            }
        }
        /**
         * Sets the disabled status of a menu entry.
         * @param index The index of the menu entry.
         * @param val The value to set.
         */
        setEntryDisabled(index, val) {
            const entry = this.entries[index];
            if (typeof entry.disabled === 'boolean') {
                entry.disabled = val;
            }
            else {
                entry.disabled.set(val);
            }
        }
        /**
         * Sets the action of a menu entry.
         * @param index The index of the menu entry.
         * @param val The value to set.
         */
        setEntryAction(index, val) {
            const entry = this.entries[index];
            if (typeof entry.action === 'function') {
                entry.action = val;
            }
            else {
                entry.action.set(val);
            }
        }
    }
    /**
     * A service that controls open pages and menus.
     */
    class ViewService {
        /**
         * Sets the current view service presenter.
         * @param presenter The presenter to set.
         */
        static setPresenter(presenter) {
            this.presenter = presenter;
        }
        /**
         * Confirms an action with a confirmation dialog box.
         * @param title The title of the dialog.
         * @param body The body of the dialog.
         * @returns True if confirmed, false if No was answered.
         */
        static confirm(title, body) {
            if (this.presenter !== undefined) {
                return new Promise((resolve, reject) => { var _a; return (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openConfirmDialog(title, body, resolve, reject); });
            }
            return Promise.reject('The view presenter was not yet available.');
        }
        /**
         * Gets a waypoint using the waypoint info dialog box.
         * @returns The facility selected by the user.
         */
        static getWaypoint() {
            if (this.presenter !== undefined) {
                return new Promise((resolve, reject) => { var _a; return (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openWaypointDialog(resolve, reject); });
            }
            return Promise.reject('The view presenter was not yet available.');
        }
        /**
         * Opens the waypoint duplicates resolution dialog box.
         * @param ident The ident of the duplicate waypoint.
         * @param icaos The icaos of all the duplicate waypoints to load.
         * @returns The facility selected by the user.
         */
        static resolveDups(ident, icaos) {
            if (this.presenter !== undefined) {
                return new Promise((resolve, reject) => { var _a; return (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openDupsDialog(ident, icaos, resolve, reject); });
            }
            return Promise.reject('The view presenter was not yet available.');
        }
        /**
         * Goes back to the previously opened page group.
         */
        static back() {
            if (this.presenter !== undefined) {
                this.presenter.back();
            }
        }
        /**
         * Opens the DIRECT TO dialog.
         * @param legDefinition the leg definition to preselect a waypoint from in the DIRECT TO dialog.
         */
        static directToDialogWithLeg(legDefinition) {
            var _a;
            (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openDirectToDialogWithLeg(legDefinition);
        }
        /**
         * Opens the DIRECT TO dialog.
         * @param icao The icao of a facility
         */
        static directToDialogWithIcao(icao) {
            var _a;
            (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openDirectToDialogWithIcao(icao);
        }
        /**
         * Opens the OBS dialog.
         */
        static obsDialog() {
            var _a;
            (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openObsDialog();
        }
        /**
         * Opens the Activate Leg dialog for activating a future leg on the existing flight plan.
         * @param legIndex The global index of the leg to activate.
         */
        static activateLegDialog(legIndex) {
            var _a;
            (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.openActivateLegDialog(legIndex);
        }
        /**
         * Opens a menu dialog.
         * @param definition The menu definition to open the menu with.
         * @param title The optional title of the menu.
         * @returns The open menu dialog.
         */
        static menu(definition, title) {
            if (this.presenter !== undefined) {
                return this.presenter.openMenu(definition, title);
            }
            return undefined;
        }
        /**
         * Opens a page group.
         * @param group The name of the page group to open.
         * @param replace Whether or not to replace the current view on the stack.
         * @param pageNumber The page number to open. If omitted, this will open the most recently opened page of the group.
         * @returns Undefined or the page it's going to open.
         */
        static open(group, replace, pageNumber) {
            if (this.presenter !== undefined) {
                return this.presenter.openPageGroup(group, replace, pageNumber);
            }
            return undefined;
        }
        /**
         * Resets the views to the default page and group.
         */
        static default() {
            if (this.presenter !== undefined) {
                this.presenter.default();
            }
        }
    }
    /**
     * A component that represents a GNS display page.
     */
    class Page extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            /** The page container element. */
            this.el = msfsSdk.FSComponent.createRef();
            this.active = false;
        }
        /**
         * Whether the page is currently active
         *
         * @returns a boolean
         */
        get isActive() {
            return this.active;
        }
        /**
         * A callback fired when the page has been suspended and is no longer visible.
         */
        onSuspend() {
            this.el.instance.classList.add('hide-element');
            this.active = false;
        }
        /**
         * A callback fired when the page has been resumed as is now visible.
         */
        onResume() {
            this.el.instance.classList.remove('hide-element');
            this.active = true;
        }
        /**
         * Pauses all active animations on the page.
         */
        freezeAnimations() {
            this.el.instance.classList.add('paused');
        }
        /**
         * Resumes all active animations on the page.
         */
        resumeAnimations() {
            this.el.instance.classList.remove('paused');
        }
        /**
         * Focuses the page.
         * @returns True if the page could be focused, false otherwise.
         */
        focus() { return false; }
        /**
         * Blurs the page.
         */
        blur() { }
        /**
         * Handles when an interaction event is received.
         * @param evt The interaction event that was received.
         * @returns True if the event was handled, false otherwise.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onInteractionEvent(evt) { return false; }
        /**
         * Gets the root element of this page.
         * @returns The page's root element.
         */
        getRootElement() {
            return this.el.instance;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page-empty', ref: this.el }));
        }
    }
    /**
     * A component that displays a particular page group.
     */
    class PageGroup extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.pages = [];
            /** Whether or not the page group has focus. */
            this.isFocused = false;
        }
        /**
         * Gets the length of the page group.
         * @returns The page group length.
         */
        get length() {
            return this.pages.length;
        }
        /**
         * Gets the currently active page, if any.
         * @returns The currently active page, or undefined.
         */
        get activePage() {
            return this.currentPage;
        }
        /**
         * Resumes the page group.
         */
        resume() {
            if (this.currentPage === undefined) {
                const defaultPage = this.props.defaultPage === undefined ? 0 : this.props.defaultPage;
                const page = this.pages[defaultPage];
                if (page !== undefined) {
                    this.currentPage = page;
                    this.props.onPageChanged(this.pages.indexOf(this.currentPage));
                    this.currentPage.onResume();
                    this.currentPage.active = true;
                }
            }
            else {
                this.props.onPageChanged(this.pages.indexOf(this.currentPage));
                this.currentPage.onResume();
                this.currentPage.active = true;
            }
        }
        /**
         * Suspends the page group.
         */
        suspend() {
            for (let i = 0; i < this.pages.length; i++) {
                const page = this.pages[i];
                if (page.isActive) {
                    page.blur();
                    page.onSuspend();
                    page.active = false;
                }
            }
            this.isFocused = false;
        }
        /**
         * Focuses the page group.
         */
        focus() {
            if (this.currentPage !== undefined && this.currentPage.focus()) {
                this.isFocused = true;
            }
        }
        /**
         * Focuses the page group.
         */
        blur() {
            if (this.currentPage !== undefined) {
                this.currentPage.blur();
            }
            this.isFocused = false;
        }
        /**
         * Handles when an interaction event is received.
         * @param evt The interaction event that was received.
         * @returns True if the event was handled, false otherwise.
         */
        onInteractionEvent(evt) {
            let handled = false;
            if (this.currentPage !== undefined) {
                handled = this.currentPage.onInteractionEvent(evt);
            }
            if (!handled) {
                switch (evt) {
                    case InteractionEvent.RightInnerInc:
                        this.changePage('inc');
                        return true;
                    case InteractionEvent.RightInnerDec:
                        this.changePage('dec');
                        return true;
                    case InteractionEvent.CLRLong:
                        ViewService.default();
                        return true;
                }
            }
            return handled;
        }
        /**
         * Changes the active page.
         * @param direction The direction to advance the pages in.
         */
        changePage(direction) {
            if (this.currentPage !== undefined) {
                const currentPageIndex = this.pages.indexOf(this.currentPage);
                const newPageIndex = Utils.Clamp(currentPageIndex + (direction === 'inc' ? 1 : -1), 0, this.pages.length - 1);
                ViewService.open(this.props.label, true, newPageIndex);
            }
        }
        /**
         * Sets the current active page in the group.
         * @param page The number of the page to set as active.
         */
        setPage(page) {
            const newPageIndex = Utils.Clamp(page, 0, this.pages.length - 1);
            if (this.currentPage !== undefined) {
                const currentPageIndex = this.pages.indexOf(this.currentPage);
                if (currentPageIndex !== newPageIndex) {
                    this.currentPage.blur();
                    this.currentPage.onSuspend();
                }
            }
            this.currentPage = this.pages[newPageIndex];
            this.currentPage.onResume();
            this.props.onPageChanged(newPageIndex);
        }
        /**
         * Gets a page from the page group.
         * @param index The index of the page.
         * @returns The requested page.
         */
        getPage(index) {
            return this.pages[index];
        }
        /**
         * Gets the index of a page in the page group.
         * @param page The page to search for.
         * @returns The index if found, or -1 if not found.
         */
        indexOfPage(page) {
            return this.pages.indexOf(page);
        }
        /** @inheritdoc */
        onAfterRender(node) {
            msfsSdk.FSComponent.visitNodes(node, childNode => {
                if (childNode.instance instanceof Page) {
                    this.pages.push(childNode.instance);
                    return true;
                }
                return false;
            });
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null, this.props.children));
        }
    }

    var FieldTypeMenuPreset;
    (function (FieldTypeMenuPreset) {
        FieldTypeMenuPreset[FieldTypeMenuPreset["ArcNavMap"] = 0] = "ArcNavMap";
        FieldTypeMenuPreset[FieldTypeMenuPreset["StandardMap"] = 1] = "StandardMap";
    })(FieldTypeMenuPreset || (FieldTypeMenuPreset = {}));
    /**
     * A menu that changes the data field type of a setting.
     */
    class FieldTypeMenu extends MenuDefinition {
        /**
         * Creates a new FieldTypeMenu.
         * @param menuEntries the field type menu entries to show
         * @param setting The setting to set when a field type is picked.
         * @param onSet A callback called when the setting is set.
         */
        constructor(menuEntries, setting, onSet) {
            super();
            this.menuEntries = menuEntries;
            this.setting = setting;
            this.onSet = onSet;
            this.title = 'SELECT FIELD TYPE';
            this.entries = menuEntries.map((entry) => (Object.assign(Object.assign({}, entry), { action: () => this.setSetting(entry.type) })));
        }
        /**
         * Sets the supplied setting to the specified field type.
         * @param type The field type to set to.
         */
        setSetting(type) {
            this.setting.set(type);
            this.onSet();
        }
        /** @inheritdoc */
        updateEntries() {
            /** no-op */
        }
    }

    /**
     * A component that displays a changeable settings driven data field.
     */
    class GNSDataField extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /**
         * Gets the data field's root DOM element.
         * @returns The field's root DOM element.
         */
        get element() {
            return this.el;
        }
        /** @inheritdoc */
        onAfterRender() {
            this.typeSub = msfsSdk.SubscribableUtils.toSubscribable(this.props.type, true).sub(this.onFieldTypeChanged.bind(this), true);
        }
        /**
         * A handler called when the data field type has changed.
         * @param type The type that the field has been changed to.
         */
        onFieldTypeChanged(type) {
            var _a, _b;
            this.el.instance.innerHTML = '';
            (_a = this.field) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.model) === null || _b === void 0 ? void 0 : _b.destroy();
            this.model = this.props.context.modelFactory.create(type);
            const node = this.props.context.renderer.render(type, this.model);
            this.field = node.instance;
            msfsSdk.FSComponent.render(node, this.el.instance);
        }
        /**
         * Updates the field from the model data.
         */
        update() {
            var _a;
            (_a = this.model) === null || _a === void 0 ? void 0 : _a.update();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            (_a = this.field) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.model) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.typeSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `gns-data-field ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`, ref: this.el }));
        }
    }

    /**
     * A time unit display for the GNS devices.
     */
    class GNSTimeDisplay extends msfsGarminsdk.TimeDisplay {
        /** @inheritdoc */
        getSuffix(format, isAm) {
            if (format === msfsGarminsdk.TimeDisplayFormat.UTC) {
                return 'Ä';
            }
            else if (format === msfsGarminsdk.TimeDisplayFormat.Local24) {
                return 'Ã';
            }
            else {
                return isAm ? 'Æ' : 'Ç';
            }
        }
    }

    /**
     * A GNS implementation of NavDataFieldRenderer.
     */
    class GNSDataFieldRenderer {
        /**
         * Constructor.
         * @param unitsSettingManager A display units user setting manager.
         * @param dateTimeSettingManager A date/time user setting manager.
         */
        constructor(unitsSettingManager, dateTimeSettingManager) {
            this.renderer = new msfsGarminsdk.GenericNavDataFieldRenderer();
            this.renderer.register(msfsGarminsdk.NavDataFieldType.BearingToWaypoint, new GNSFieldBearingRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.Waypoint, new GNSFieldTextRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.Destination, new GNSFieldTextRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.DistanceToWaypoint, new GNSFieldDistanceLargeRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.DistanceToDestination, new GNSFieldDistanceLargeRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.DesiredTrack, new GNSFieldBearingRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.Endurance, new GNSFieldDurationRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.TimeOfWaypointArrival, new GNSFieldTimeRenderer(dateTimeSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.TimeToWaypoint, new GNSFieldDurationRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.FuelOnBoard, new GNSFieldFuelRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.FuelOverDestination, new GNSFieldFuelRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.GroundSpeed, new GNSFieldSpeedRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.TimeOfDestinationArrival, new GNSFieldTimeRenderer(dateTimeSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.TrueAirspeed, new GNSFieldSpeedRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.GroundTrack, new GNSFieldBearingRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.VerticalSpeedRequired, new GNSFieldVerticalSpeedRenderer(unitsSettingManager));
            this.renderer.register(msfsGarminsdk.NavDataFieldType.CrossTrack, new GNSFieldDistanceLargeRenderer(unitsSettingManager));
        }
        /**
         * Renders a navigation data bar field of a given type.
         * @param type A data bar field type.
         * @param model The data model for the field.
         * @returns A navigation data bar field of the given type, as a VNode.
         * @throws Error if an unsupported field type is specified.
         */
        render(type, model) {
            return this.renderer.render(type, model);
        }
    }
    /**
     * An abstract next-generation (NXi, G3000, etc) implementation of {@link NavDataFieldTypeRenderer} which supports
     * display unit settings.
     */
    class GNSDataFieldTypeRenderer {
        /**
         * Constructor.
         * @param unitsSettingManager A user setting manager for measurement units.
         */
        constructor(unitsSettingManager) {
            this.unitsSettingManager = unitsSettingManager;
        }
    }
    GNSDataFieldTypeRenderer.BEARING_FORMATTER = msfsSdk.NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' });
    GNSDataFieldTypeRenderer.DISTANCE_FORMATTER = msfsSdk.NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: true, nanString: '__._' });
    GNSDataFieldTypeRenderer.SPEED_FORMATTER = msfsSdk.NumberFormatter.create({ precision: 0.1, maxDigits: 3, nanString: '_._' });
    GNSDataFieldTypeRenderer.FUEL_FORMATTER = msfsSdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    GNSDataFieldTypeRenderer.ANGLE_FORMATTER = msfsSdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    GNSDataFieldTypeRenderer.TEMPERATURE_FORMATTER = msfsSdk.NumberFormatter.create({ precision: 1, nanString: '___' });
    GNSDataFieldTypeRenderer.DURATION_OPTIONS = {
        pad: 0,
        format: msfsSdk.DurationDisplayFormat.hh_mm_or_mm_ss,
        delim: msfsSdk.DurationDisplayDelim.ColonOrCross,
        nanString: '__:__'
    };
    /**
     * A GNS data field renderer that renders speed fields.
     */
    class GNSFieldTextRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(SelectableText, { data: model.value }));
        }
    }
    /**
     * A GNS data field renderer that renders speed fields.
     */
    class GNSFieldSpeedRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.SPEED_FORMATTER, value: model.value, displayUnit: this.unitsSettingManager.speedUnits }));
        }
    }
    /**
     * A GNS data field renderer that renders distance fields.
     */
    class GNSFieldDistanceLargeRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.DISTANCE_FORMATTER, value: model.value, displayUnit: this.unitsSettingManager.distanceUnitsLarge }));
        }
    }
    /**
     * A GNS data field renderer that renders vertical speed fields.
     */
    class GNSFieldVerticalSpeedRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.SPEED_FORMATTER, value: model.value, displayUnit: this.unitsSettingManager.verticalSpeedUnits }));
        }
    }
    /**
     * A GNS data field renderer that bearing fields.
     */
    class GNSFieldBearingRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.BEARING_FORMATTER, value: model.value, displayUnit: this.unitsSettingManager.navAngleUnits }));
        }
    }
    /**
     * A GNS data field renderer that renders fuel fields.
     */
    class GNSFieldFuelRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: model.value, displayUnit: this.unitsSettingManager.weightUnits }));
        }
    }
    /**
     * A GNS data field renderer that renders duration fields.
     */
    class GNSFieldDurationRenderer extends GNSDataFieldTypeRenderer {
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.DurationDisplay, { options: GNSDataFieldTypeRenderer.DURATION_OPTIONS, value: model.value }));
        }
    }
    /**
     * A GNS data field renderer that renders time fields.
     */
    class GNSFieldTimeRenderer {
        /**
         * Constructor.
         * @param dateTimeSettingManager A date/time user setting manager.
         */
        constructor(dateTimeSettingManager) {
            this.dateTimeSettingManager = dateTimeSettingManager;
            this.timeFormat = msfsSdk.ConsumerSubject.create(this.dateTimeSettingManager.whenSettingChanged('dateTimeFormat'), this.dateTimeSettingManager.getSetting('dateTimeFormat').value);
            this.localOffset = msfsSdk.ConsumerSubject.create(this.dateTimeSettingManager.whenSettingChanged('dateTimeLocalOffset'), this.dateTimeSettingManager.getSetting('dateTimeLocalOffset').value);
        }
        /** @inheritdoc */
        render(model) {
            return (msfsSdk.FSComponent.buildComponent(GNSTimeDisplay, { time: model.value, localOffset: this.localOffset, format: this.timeFormat.map(format => GNSFieldTimeRenderer.FORMAT_SETTING_MAP[format]), class: 'time-without-seconds-or-suffix' }));
        }
    }
    GNSFieldTimeRenderer.FORMAT_SETTING_MAP = {
        [msfsGarminsdk.DateTimeFormatSettingMode.Local12]: msfsGarminsdk.TimeDisplayFormat.Local12,
        [msfsGarminsdk.DateTimeFormatSettingMode.Local24]: msfsGarminsdk.TimeDisplayFormat.Local24,
        [msfsGarminsdk.DateTimeFormatSettingMode.UTC]: msfsGarminsdk.TimeDisplayFormat.UTC
    };

    /**
     * A component that displays a GNS leg type icon.
     */
    class LegIcon extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.iconElement = msfsSdk.FSComponent.createRef();
        }
        /**
         * A callback called when the leg type changes to modify the leg type icon.
         * @param legExists is a bool for whether an arrow should be drawn at all
         * @param isDirectTo is a bool for whether the flight plan is current in a direct to state.
         * @param legType The current enum value for the leg type.
         * @param turnDirection the direction of the turn
         */
        updateLegIcon(legExists, isDirectTo, legType, turnDirection) {
            if (legExists) {
                this.iconElement.instance.classList.remove('hide-element');
                if (isDirectTo) {
                    this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_DIRECTTO').src;
                }
                else {
                    switch (legType) {
                        case msfsSdk.LegType.HA:
                        case msfsSdk.LegType.HF:
                        case msfsSdk.LegType.HM:
                            if (turnDirection === msfsSdk.LegTurnDirection.Left) {
                                this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_HOLD_LEFT').src;
                            }
                            else {
                                this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_HOLD_RIGHT').src;
                            }
                            break;
                        case msfsSdk.LegType.RF:
                        case msfsSdk.LegType.AF:
                            if (turnDirection === msfsSdk.LegTurnDirection.Left) {
                                this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_ARC_LEFT').src;
                            }
                            else {
                                this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_ARC_RIGHT').src;
                            }
                            break;
                        default:
                            this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_DEFAULT').src;
                            break;
                    }
                }
            }
            else {
                this.iconElement.instance.classList.add('hide-element');
            }
        }
        /**
         * Renders the component.
         * @returns The component VNode.
         */
        render() {
            return (msfsSdk.FSComponent.buildComponent("img", { class: 'leg-icon hide-element', src: '', ref: this.iconElement }));
        }
    }

    /**
     * A component that displays a waypoint leg, with fix type labels.
     */
    class WaypointLeg extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.legName = msfsSdk.Subject.create(this.props.nullIsBlank ? '     ' : '_____');
            this.legType = msfsSdk.Subject.create('');
            this.nameEl = msfsSdk.FSComponent.createRef();
            this.iconElement = msfsSdk.FSComponent.createRef();
        }
        /**
         * Sets the displayed leg, or null to not display.
         * @param leg The new leg data.
         */
        setLeg(leg) {
            var _a;
            this.props.isArcMap && this.iconElement.instance.classList.add('hide-element');
            if (leg !== null) {
                switch (leg.name) {
                    case 'PROC. TURN':
                        if (this.props.isArcMap) {
                            this.legName.set('');
                            this.setProcTurnSvg(leg);
                            this.iconElement.instance.classList.remove('hide-element');
                        }
                        else {
                            this.legName.set('proc. turn');
                            this.nameEl.instance.classList.add('extended2');
                            this.nameEl.instance.classList.add('smaller-font');
                        }
                        break;
                    case 'MANSEQ':
                        this.legName.set('man seq');
                        this.nameEl.instance.classList.add('extended');
                        break;
                    case 'HOLD':
                        this.legName.set('hold');
                        this.nameEl.instance.classList.add('extended');
                        break;
                    default:
                        this.legName.set((_a = leg.name) !== null && _a !== void 0 ? _a : '_____');
                        this.nameEl.instance.classList.remove('extended');
                        break;
                }
                this.legType.set(this.getFixType(leg.leg.fixTypeFlags));
            }
            else {
                this.legName.set(this.props.nullIsBlank ? '     ' : '_____');
                this.legType.set('');
            }
        }
        /**
         * Sets which Proc turn directon icon to get.
         * @param leg The new leg data.
         */
        setProcTurnSvg(leg) {
            switch (leg.leg.turnDirection) {
                case msfsSdk.LegTurnDirection.Left:
                    this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_PTURN_LEFT_GREEN').src;
                    break;
                default:
                    this.iconElement.instance.src = msfsSdk.ImageCache.get('LEGICON_PTURN_RIGHT_GREEN').src;
                    break;
            }
        }
        /** @inheritdoc */
        onFocused() {
            this.nameEl.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.nameEl.instance.classList.remove('selected');
        }
        /**
         * Gets the fix type label for the leg.
         * @param flags The flags on the leg.
         * @returns The fix type label.
         */
        getFixType(flags) {
            if (flags === 0) {
                return '';
            }
            if (msfsSdk.BitFlags.isAny(flags, msfsSdk.FixTypeFlags.IF)) {
                return 'IF';
            }
            if (msfsSdk.BitFlags.isAny(flags, msfsSdk.FixTypeFlags.IAF)) {
                return 'IA';
            }
            if (msfsSdk.BitFlags.isAny(flags, msfsSdk.FixTypeFlags.MAP)) {
                return 'MA';
            }
            if (msfsSdk.BitFlags.isAny(flags, msfsSdk.FixTypeFlags.FAF)) {
                return 'FA';
            }
            if (msfsSdk.BitFlags.isAny(flags, msfsSdk.FixTypeFlags.MAHP)) {
                return 'MH';
            }
            return '';
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `waypoint-leg ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfsSdk.FSComponent.buildComponent("span", { class: 'waypoint-leg-name', ref: this.nameEl }, this.legName),
                msfsSdk.FSComponent.buildComponent("span", { class: 'waypoint-leg-type' }, this.legType),
                msfsSdk.FSComponent.buildComponent("img", { class: 'waypoint-leg-icon hide-element', src: '', ref: this.iconElement })));
        }
    }

    /**
     * A component that displays the CDI on the arc map page.
     */
    class ArcCdi extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.toFlag = msfsSdk.FSComponent.createRef();
            this.fromFlag = msfsSdk.FSComponent.createRef();
            this.rightArrow = msfsSdk.FSComponent.createRef();
            this.leftArrow = msfsSdk.FSComponent.createRef();
            this.needle = msfsSdk.FSComponent.createRef();
            this.xtkLabelLeft = msfsSdk.FSComponent.createRef();
            this.xtkLabelRight = msfsSdk.FSComponent.createRef();
            this.currentBearing = 0;
            this.currentDtk = 0;
            this.currentXtk = 0;
            this.cdiScale = 2;
            this.hasActiveLeg = false;
            this.toFlagVisible = msfsSdk.Subject.create(false);
            this.fromFlagVisible = msfsSdk.Subject.create(false);
            this.rightArrowVisible = msfsSdk.Subject.create(false);
            this.leftArrowVisible = msfsSdk.Subject.create(false);
            this.needleVisible = msfsSdk.Subject.create(false);
            this.xtkLabel = msfsSdk.Subject.create('');
            this.xtkLabelFormatter = msfsSdk.NumberFormatter.create({ precision: 0.1, maxDigits: 3 });
            this.gpsIsValid = false;
        }
        /** @inheritdoc */
        onAfterRender() {
            const sub = this.props.bus.getSubscriber();
            sub.on('lnavdata_cdi_scale').whenChanged().handle(this.onCdiScaleChanged.bind(this));
            sub.on('lnavdata_dtk_true').withPrecision(0).handle(this.onDtkChanged.bind(this));
            sub.on('lnavdata_waypoint_bearing_true').withPrecision(0).handle(this.onWaypointBearingChanged.bind(this));
            sub.on('lnavdata_xtk').withPrecision(3).atFrequency(6).handle(this.onXtkChanged.bind(this));
            sub.on('lnavdata_xtk').withPrecision(1).atFrequency(6).handle(xtk => this.xtkLabel.set(this.xtkLabelFormatter(Math.abs(xtk))));
            sub.on('fplActiveLegChange').handle(this.onActiveLegChanged.bind(this));
            this.toFlagVisible.sub(this.setElementVisibility(this.toFlag), true);
            this.fromFlagVisible.sub(this.setElementVisibility(this.fromFlag), true);
            this.rightArrowVisible.sub(this.setElementVisibility(this.rightArrow), true);
            this.rightArrowVisible.sub(this.setElementVisibility(this.xtkLabelRight), true);
            this.leftArrowVisible.sub(this.setElementVisibility(this.leftArrow), true);
            this.leftArrowVisible.sub(this.setElementVisibility(this.xtkLabelLeft), true);
            this.needleVisible.sub(this.setElementVisibility(this.needle), true);
            sub.on('gps_system_state_changed_1').handle(state => {
                this.gpsIsValid = state === msfsSdk.GPSSystemState.SolutionAcquired || state === msfsSdk.GPSSystemState.DiffSolutionAcquired;
                this.onWaypointBearingChanged(this.currentBearing);
                this.onXtkChanged(this.currentXtk);
            });
        }
        /**
         * Handles when the bearing to the current waypoint changes.
         * @param bearing The new bearing to the current waypoint, in degrees true.
         */
        onWaypointBearingChanged(bearing) {
            if (this.hasActiveLeg && this.gpsIsValid) {
                const angleDiff = msfsSdk.NavMath.diffAngle(this.currentDtk, bearing);
                if (Math.abs(angleDiff) <= 90) {
                    this.toFlagVisible.set(true);
                    this.fromFlagVisible.set(false);
                }
                else {
                    this.fromFlagVisible.set(true);
                    this.toFlagVisible.set(false);
                }
            }
            else {
                this.toFlagVisible.set(false);
                this.fromFlagVisible.set(false);
            }
            this.currentBearing = bearing;
        }
        /**
         * Handles when the CDI scale changes.
         * @param cdiScale The new CDI scale, in nautical miles.
         */
        onCdiScaleChanged(cdiScale) {
            this.cdiScale = cdiScale;
            this.onXtkChanged(this.currentXtk);
        }
        /**
         * Handles when the XTK changes.
         * @param xtk The new XTK, in nautical miles.
         */
        onXtkChanged(xtk) {
            if (this.hasActiveLeg && this.gpsIsValid) {
                if (Math.abs(xtk) <= this.cdiScale) {
                    this.needleVisible.set(true);
                    this.leftArrowVisible.set(false);
                    this.rightArrowVisible.set(false);
                    const mid = (this.cdiWidth / 2);
                    const percentScale = -xtk / this.cdiScale;
                    const centerPos = mid + (percentScale * mid);
                    const leftPos = centerPos - 3;
                    this.needle.instance.style.transform = `translate3d(${leftPos}px, 0, 0)`;
                }
                else if (xtk > this.cdiScale) {
                    this.needleVisible.set(false);
                    this.leftArrowVisible.set(true);
                    this.rightArrowVisible.set(false);
                }
                else if (xtk < -this.cdiScale) {
                    this.needleVisible.set(false);
                    this.leftArrowVisible.set(false);
                    this.rightArrowVisible.set(true);
                }
                else {
                    this.needleVisible.set(false);
                    this.leftArrowVisible.set(false);
                    this.rightArrowVisible.set(false);
                }
            }
            else {
                this.needleVisible.set(false);
                this.leftArrowVisible.set(false);
                this.rightArrowVisible.set(false);
            }
            this.currentXtk = xtk;
        }
        /**
         * Creates a function that sets element visibility.
         * @param el The element to apply to.
         * @returns The built function.
         */
        setElementVisibility(el) {
            return (isVisible) => {
                if (isVisible) {
                    el.instance.classList.remove('hide-element');
                }
                else {
                    el.instance.classList.add('hide-element');
                }
            };
        }
        /**
         * Handles when the DTK changes.
         * @param dtk The new DTK, in degrees true.
         */
        onDtkChanged(dtk) {
            this.currentDtk = dtk;
            this.onWaypointBearingChanged(this.currentBearing);
        }
        /**
         * Handles when the active leg changes.
         */
        onActiveLegChanged() {
            if (this.props.fms.hasPrimaryFlightPlan() && this.props.fms.getPrimaryFlightPlan().length > 1) {
                this.hasActiveLeg = true;
            }
            else {
                this.hasActiveLeg = false;
            }
            this.onWaypointBearingChanged(this.currentBearing);
            this.onXtkChanged(this.currentXtk);
        }
    }

    /**
     * WT430 CDI
     */
    class WT430Cdi extends ArcCdi {
        constructor() {
            super(...arguments);
            this.cdiWidth = 252;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'arc-cdi-wt430' },
                msfsSdk.FSComponent.buildComponent("svg", { width: '261px', height: '38px', xmlns: "http://www.w3.org/2000/svg" },
                    msfsSdk.FSComponent.buildComponent("rect", { x: '0px', y: '0px', width: '261px', height: '38px', stroke: 'cyan', "stroke-width": '2px' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '12px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '35px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '58px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '81px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '104px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '152px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '175px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '198px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '221px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '244px', y: '17.5px', width: '5px', height: '5px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 119 14 l 12 -10 l 12 10 z', fill: '#0f0', ref: this.toFlag }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 119 23 l 12 10 l 12 -10 z', fill: '#0f0', ref: this.fromFlag }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 22 18 l -4 0 l 0 -4 l -12 6 l 12 6 l 0 -4 l 4 0 z', fill: '#0f0', ref: this.leftArrow }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 238 18 l 4 0 l 0 -4 l 12 6 l -12 6 l 0 -4 l -4 0 z', fill: '#0f0', ref: this.rightArrow }),
                    msfsSdk.FSComponent.buildComponent("rect", { ref: this.needle, x: '5px', y: '2px', width: '6px', height: '34px', stroke: '#0f0', "stroke-width": '2px', fill: 'transparent' })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'arc-cdi-xtk-label-left', ref: this.xtkLabelLeft }, this.xtkLabel),
                msfsSdk.FSComponent.buildComponent("div", { class: 'arc-cdi-xtk-label-right', ref: this.xtkLabelRight }, this.xtkLabel)));
        }
    }

    /**
     * GNS430 NAV Page 1
     */
    class NavInfo extends Page {
        constructor() {
            super(...arguments);
            this.fromWaypoint = msfsSdk.FSComponent.createRef();
            this.toWaypoint = msfsSdk.FSComponent.createRef();
            this.legIcon = msfsSdk.FSComponent.createRef();
            this.rootControl = msfsSdk.FSComponent.createRef();
            this.pageMenu = new NavInfoPageMenu();
            this.gpsValidity = msfsSdk.Subject.create(msfsGarminsdk.NavDataFieldGpsValidity.Invalid);
            this.settingsProvider = new GNSSettingsProvider(this.props.bus);
            this.fieldContext = {
                modelFactory: new msfsGarminsdk.DefaultNavDataBarFieldModelFactory(this.props.bus, this.props.fms, this.gpsValidity),
                renderer: new GNSDataFieldRenderer(this.settingsProvider.units, this.settingsProvider.time),
                fieldTypeMenuEntries: [
                    { label: 'BRG - Bearing', disabled: false, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'DIS - Distance', disabled: false, type: msfsGarminsdk.NavDataFieldType.DistanceToWaypoint },
                    { label: 'DTK - Desired Track', disabled: false, type: msfsGarminsdk.NavDataFieldType.DesiredTrack },
                    { label: 'ESA - Enrte Safe Alt', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'ETA - Est Time Arvl', disabled: false, type: msfsGarminsdk.NavDataFieldType.TimeOfWaypointArrival },
                    { label: 'ETE - Est Time Enrte', disabled: false, type: msfsGarminsdk.NavDataFieldType.TimeToWaypoint },
                    { label: 'FLOW - Total Fuel Flow', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'GS - Ground Speed', disabled: false, type: msfsGarminsdk.NavDataFieldType.GroundSpeed },
                    { label: 'MSA - Min Safe Alt', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'TKE - Track Ang Err', disabled: false, type: msfsGarminsdk.NavDataFieldType.TrackAngleError },
                    { label: 'TRK - Track', disabled: false, type: msfsGarminsdk.NavDataFieldType.GroundTrack },
                    { label: 'VSR - Vert Spd Reqd', disabled: false, type: msfsGarminsdk.NavDataFieldType.VerticalSpeedRequired },
                    { label: 'XTK - Cross Track Err', disabled: false, type: msfsGarminsdk.NavDataFieldType.CrossTrack },
                ],
            };
            this.fields = [
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
            ];
            this.clockSub = this.props.bus.getSubscriber().on('realTime')
                .atFrequency(4).handle(() => {
                var _a;
                for (let i = 0; i < this.fields.length; i++) {
                    (_a = this.fields[i].getOrDefault()) === null || _a === void 0 ? void 0 : _a.update();
                }
            });
        }
        /** @inheritDoc */
        onSuspend() {
            super.onSuspend();
            this.clockSub.pause();
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.clockSub.resume();
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.pageMenu);
                return true;
            }
            let handled = false;
            if (this.rootControl.instance.isFocused) {
                if (evt === InteractionEvent.CLR) {
                    this.rootControl.instance.blur();
                    handled = true;
                }
                else {
                    handled = this.rootControl.instance.onInteractionEvent(evt);
                }
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber().on('fplActiveLegChange').handle(this.onActiveLegChanged.bind(this));
            this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
            this.toWaypoint.instance.setDisabled(true);
            this.fromWaypoint.instance.setDisabled(true);
            this.pageMenu.onRestoreDefaults = () => {
                this.settingsProvider.arcMapFields.getAllSettings().forEach(v => v.resetToDefault());
                ViewService.back();
            };
            this.pageMenu.onChangeFieldsSelected = () => {
                ViewService.back();
                this.rootControl.instance.focus(msfsSdk.FocusPosition.First);
            };
            this.props.bus.getSubscriber().on('gps_system_state_changed_1').handle(state => {
                const valid = state === msfsSdk.GPSSystemState.SolutionAcquired || state === msfsSdk.GPSSystemState.DiffSolutionAcquired;
                this.gpsValidity.set(valid ? msfsGarminsdk.NavDataFieldGpsValidity.Valid : msfsGarminsdk.NavDataFieldGpsValidity.Invalid);
            });
        }
        /**
         * Handles when the active flight plan leg changes.
         * @param data The active flight plan leg change event.
         */
        onActiveLegChanged(data) {
            if (data.planIndex !== this.props.fms.flightPlanner.activePlanIndex) {
                return;
            }
            if (this.props.fms.hasPrimaryFlightPlan() && data.type === msfsSdk.ActiveLegType.Lateral) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                const toLeg = plan.tryGetLeg(data.segmentIndex, data.legIndex);
                this.toWaypoint.instance.setLeg(toLeg);
                if (toLeg !== null) {
                    const toLegIndex = plan.getLegIndexFromLeg(toLeg);
                    const fromLeg = plan.tryGetLeg(toLegIndex - 1);
                    const directToState = this.props.fms.getDirectToState();
                    this.fromWaypoint.instance.setLeg(fromLeg);
                    if (fromLeg === null || directToState === msfsGarminsdk.DirectToState.TOEXISTING || directToState === msfsGarminsdk.DirectToState.TORANDOM) {
                        this.legIcon.instance.updateLegIcon(true, true, toLeg.leg.type, toLeg.leg.turnDirection);
                    }
                    else {
                        this.legIcon.instance.updateLegIcon(true, false, toLeg.leg.type, toLeg.leg.turnDirection);
                    }
                }
                else {
                    this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
                }
            }
            else {
                this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
            }
        }
        /**
         * Handles a data field change interaction (right inner dec/inc)
         *
         * @param fieldIndex 1-indexed data field index
         *
         * @returns true
         */
        onChangeDataField(fieldIndex) {
            const field = this.fields[fieldIndex - 1];
            ViewService.menu(new FieldTypeMenu(this.fieldContext.fieldTypeMenuEntries, field.instance.props.type, () => {
                ViewService.back();
                this.rootControl.instance.scroll('forward');
            }));
            return true;
        }
        /**
         * Renders a data field label
         *
         * @param fieldIndex 1-indexed data field index
         *
         * @returns a vnode
         */
        renderDataFieldLabel(fieldIndex) {
            const fieldSettings = this.settingsProvider.wt430navInfoFields;
            return (msfsSdk.FSComponent.buildComponent(SelectableText, { data: fieldSettings.getSetting(`wt430_navinfo_field_${fieldIndex}_type`), selectedClass: "selected-cyan", onRightInnerDec: this.onChangeDataField.bind(this, fieldIndex), onRightInnerInc: this.onChangeDataField.bind(this, fieldIndex) }));
        }
        /**
         * Renders a data field element
         *
         * @param fieldIndex 1-indexed data field index
         *
         * @returns a vnode
         */
        renderDataFieldElement(fieldIndex) {
            const fieldSettings = this.settingsProvider.wt430navInfoFields;
            return (msfsSdk.FSComponent.buildComponent(GNSDataField, { class: 'map-data-field-field', context: this.fieldContext, type: fieldSettings.getSetting(`wt430_navinfo_field_${fieldIndex}_type`), ref: this.fields[fieldIndex - 1] }));
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page nav-info-page hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.rootControl, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WT430Cdi, { bus: this.props.bus, fms: this.props.fms }),
                    msfsSdk.FSComponent.buildComponent("div", { class: "nav-info-fromto" },
                        msfsSdk.FSComponent.buildComponent(WaypointLeg, { ref: this.fromWaypoint, class: 'arc-map-waypoints-from', isArcMap: true }),
                        msfsSdk.FSComponent.buildComponent(LegIcon, { ref: this.legIcon }),
                        msfsSdk.FSComponent.buildComponent(WaypointLeg, { ref: this.toWaypoint, class: 'arc-map-waypoints-to', isArcMap: true })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "nav-info-field-labels" },
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldLabel(1)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldLabel(2)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldLabel(3))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "nav-info-fields" },
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldElement(1)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldElement(2)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldElement(3)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldElement(4)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldElement(5)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldElement(6))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "nav-info-field-labels" },
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldLabel(4)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldLabel(5)),
                        msfsSdk.FSComponent.buildComponent("span", null, this.renderDataFieldLabel(6))))));
        }
    }
    /**
     * A page menu for the NAV 1 page on the 4330.
     */
    class NavInfoPageMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.onChangeFieldsSelected = () => { };
            this.onRestoreDefaults = () => { };
            /** @inheritdoc */
            this.entries = [
                { label: 'Crossfill?', disabled: true, action: () => { } },
                { label: 'Change Fields?', disabled: false, action: () => this.onChangeFieldsSelected() },
                { label: 'Restore Defaults?', disabled: false, action: () => this.onRestoreDefaults() },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            /** no-op */
        }
    }

    /**
     * A module that controls display of airport runways.
     */
    class AirportRunwayDisplayModule {
        constructor() {
            /** Whether or not runway labels should be displayed */
            this.displayLabels = msfsSdk.Subject.create(true);
            /** Whether or not the runways themselves should be displayed. */
            this.displayRunways = msfsSdk.Subject.create(true);
            /**
             * Highlights an airport which may not already be contained in the set of
             * nearest airports to already be displayed.
             */
            this.focusAirport = msfsSdk.Subject.create(undefined);
        }
    }

    /**
     * Map system component keys specific to the GNS map system.
     */
    var GNSMapKeys;
    (function (GNSMapKeys) {
        GNSMapKeys["Range"] = "range";
        GNSMapKeys["Controller"] = "controller";
        GNSMapKeys["RangeLegend"] = "rangeLegend";
        GNSMapKeys["Runways"] = "runways";
        GNSMapKeys["CompassNorth"] = "compassNorth";
        GNSMapKeys["Units"] = "units";
        GNSMapKeys["CompassArc"] = "compassArc";
        GNSMapKeys["WaypointBearing"] = "waypointBearing";
        GNSMapKeys["TrafficBanner"] = "trafficBanner";
        GNSMapKeys["Obs"] = "obs";
        GNSMapKeys["Declutter"] = "declutter";
    })(GNSMapKeys || (GNSMapKeys = {}));
    /**
     * Airspace show types for GNS maps.
     */
    var AirspaceVisibility;
    (function (AirspaceVisibility) {
        AirspaceVisibility["ClassB"] = "ClassB";
        AirspaceVisibility["ClassC"] = "ClassC";
        AirspaceVisibility["ClassD"] = "ClassD";
        AirspaceVisibility["Restricted"] = "Restricted";
        AirspaceVisibility["MOA"] = "MOA";
        AirspaceVisibility["Other"] = "Other";
    })(AirspaceVisibility || (AirspaceVisibility = {}));
    /**
     * A class that handles configuration of GNS traffic icons.
     */
    class GNSTrafficIcons {
    }
    GNSTrafficIcons.IconOptions = (gnsType) => ({
        iconSize: gnsType === 'wt430' ? 22 : 18,
        font: 'GreatNiftySymbol-Regular',
        fontSize: gnsType === 'wt430' ? 16 : 12,
        drawOffScale: false,
        supportAdsbVector: true,
        forceDrawNoArrow: true,
        vectorLength: 30,
        drawTARAVectorAsNormalVector: true
    });

    /**
     * A map layer that displays airport runways.
     */
    class AirportRunwayLayer extends msfsSdk.MapLayer {
        constructor() {
            super(...arguments);
            this.textManager = new msfsSdk.MapCullableTextLabelManager(true);
            this.waypointAddedSub = this.props.waypointRenderer.onWaypointAdded.on(this.onWaypointAdded.bind(this));
            this.waypointRemovedSub = this.props.waypointRenderer.onWaypointRemoved.on(this.onWaypointRemoved.bind(this));
            this.updateRequired = false;
            this.displayedAirports = new Map();
            this.runwayLabels = new Map();
            this.canvasLayerRef = msfsSdk.FSComponent.createRef();
            this.labelLayerRef = msfsSdk.FSComponent.createRef();
            this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
            this.geoPointCache = [new msfsSdk.GeoPoint(0, 0), new msfsSdk.GeoPoint(0, 0), new msfsSdk.GeoPoint(0, 0), new msfsSdk.GeoPoint(0, 0)];
            this.displayModule = this.props.model.getModule(GNSMapKeys.Runways);
            this.runwaysDisplayedSub = this.displayModule.displayRunways.sub(() => this.updateRequired = true);
            this.labelsDisplayedSub = this.displayModule.displayLabels.sub(() => this.updateRequired = true);
            this.focusChangedSub = this.displayModule.focusAirport.sub(this.onFocusAirportChanged.bind(this));
            this.centerlineDash = [5, 5];
        }
        /** @inheritdoc */
        onAttached() {
            this.canvasLayerRef.instance.onAttached();
            this.labelLayerRef.instance.onAttached();
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.labelLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            this.canvasLayerRef.instance.onUpdated(time, elapsed);
            const performUpdate = this.isVisible() && (this.updateRequired || this.canvasLayerRef.instance.display.isInvalid);
            if (performUpdate) {
                this.canvasLayerRef.instance.display.syncWithMapProjection(this.props.mapProjection);
                this.canvasLayerRef.instance.display.clear();
                const context = this.canvasLayerRef.instance.display.context;
                const geoProjection = this.canvasLayerRef.instance.display.geoProjection;
                context.fillStyle = 'white';
                context.strokeStyle = 'black';
                context.lineWidth = 1;
                if (this.displayModule.displayRunways.get()) {
                    for (const airport of this.displayedAirports.values()) {
                        this.drawRunways(airport, geoProjection, context);
                    }
                    const focusAirport = this.displayModule.focusAirport.get();
                    if (focusAirport !== undefined && this.displayedAirports.get(focusAirport.uid) === undefined) {
                        this.drawRunways(focusAirport, geoProjection, context);
                    }
                }
                this.updateRequired = false;
            }
            this.textManager.update(this.props.mapProjection);
            this.labelLayerRef.instance.display.clear();
            const context = this.labelLayerRef.instance.display.context;
            if (this.displayModule.displayLabels.get()) {
                for (const label of this.textManager.visibleLabels) {
                    label.draw(context, this.props.mapProjection);
                }
            }
        }
        /**
         * Draws the runways for a given airport.
         * @param airport The airport to draw runways for.
         * @param geoProjection The geoprojection from the canvas to draw against.
         * @param context The canvas rendering context to use.
         */
        drawRunways(airport, geoProjection, context) {
            const runways = airport.facility.get().runways;
            for (let i = 0; i < runways.length; i++) {
                const runway = runways[i];
                const runwayPos = this.geoPointCache[0].set(runway.latitude, runway.longitude);
                const halfWidth = msfsSdk.UnitType.METER.convertTo(runway.width / 2, msfsSdk.UnitType.GA_RADIAN);
                const halfLength = msfsSdk.UnitType.METER.convertTo(runway.length / 2, msfsSdk.UnitType.GA_RADIAN);
                const leftBound = runwayPos.offset(msfsSdk.NavMath.normalizeHeading(runway.direction - 90), halfWidth, this.geoPointCache[1]);
                const forwardBound = runwayPos.offset(runway.direction, halfLength, this.geoPointCache[2]);
                const backwardBound = runwayPos.offset(msfsSdk.NavMath.normalizeHeading(runway.direction + 180), halfLength, this.geoPointCache[3]);
                const pPos = geoProjection.project(runwayPos, this.vec2Cache[0]);
                const pLeft = geoProjection.project(leftBound, this.vec2Cache[1]);
                const width = Math.max(msfsSdk.Vec2Math.distance(pPos, pLeft) * 2, 3) / 2;
                const pBack = geoProjection.project(backwardBound, this.vec2Cache[0]);
                const pForward = geoProjection.project(forwardBound, this.vec2Cache[1]);
                const theta = msfsSdk.Vec2Math.theta(msfsSdk.Vec2Math.sub(pForward, pBack, this.vec2Cache[2]));
                const pBackL = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(width, theta - (Math.PI / 2), this.vec2Cache[2]), pBack, this.vec2Cache[3]);
                const pBackR = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(width, theta + (Math.PI / 2), this.vec2Cache[2]), pBack, this.vec2Cache[4]);
                const pForwardL = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(width, theta - (Math.PI / 2), this.vec2Cache[2]), pForward, this.vec2Cache[5]);
                const pForwardR = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(width, theta + (Math.PI / 2), this.vec2Cache[2]), pForward, this.vec2Cache[6]);
                context.fillStyle = msfsSdk.RunwayUtils.getSurfaceCategory(runway) === msfsSdk.RunwaySurfaceCategory.Hard ? 'white' : '#00ff00';
                context.beginPath();
                context.moveTo(pBackL[0], pBackL[1]);
                context.lineTo(pBackR[0], pBackR[1]);
                context.lineTo(pForwardR[0], pForwardR[1]);
                context.lineTo(pForwardL[0], pForwardL[1]);
                context.closePath();
                context.fill();
                if (width >= 4) {
                    context.beginPath();
                    context.moveTo(pBack[0], pBack[1]);
                    context.lineTo(pForward[0], pForward[1]);
                    context.setLineDash(this.centerlineDash);
                    context.stroke();
                }
            }
        }
        /**
         * A handler that is called when a waypoint is added to the waypoint renderer.
         * @param sender The waypoint renderer.
         * @param waypoint The waypoint that was added.
         */
        onWaypointAdded(sender, waypoint) {
            if (waypoint instanceof msfsGarminsdk.AirportWaypoint && (waypoint.size === msfsGarminsdk.AirportSize.Large || waypoint.size === msfsGarminsdk.AirportSize.Medium)) {
                this.displayedAirports.set(waypoint.uid, waypoint);
                this.processAirportWaypoint(waypoint);
                this.updateRequired = true;
            }
        }
        /**
         * A handler that is called when a waypoint is added to the waypoint renderer.
         * @param sender The waypoint renderer.
         * @param waypoint The waypoint that was added.
         */
        onWaypointRemoved(sender, waypoint) {
            var _a;
            if (waypoint instanceof msfsGarminsdk.AirportWaypoint && (waypoint.size === msfsGarminsdk.AirportSize.Large || waypoint.size === msfsGarminsdk.AirportSize.Medium)) {
                this.displayedAirports.delete(waypoint.uid);
                const labels = this.runwayLabels.get(waypoint.uid);
                if (((_a = this.displayModule.focusAirport.get()) === null || _a === void 0 ? void 0 : _a.uid) !== waypoint.uid) {
                    labels === null || labels === void 0 ? void 0 : labels.forEach(l => this.textManager.deregister(l));
                    this.runwayLabels.delete(waypoint.uid);
                }
                this.updateRequired = true;
            }
        }
        /**
         * A callback fired when the focused airport is changed.
         * @param waypoint The waypoint representing the focused airport.
         */
        onFocusAirportChanged(waypoint) {
            if (waypoint === this.focusedAirport) {
                return;
            }
            if (this.focusedAirport !== undefined) {
                const displayedAirport = this.displayedAirports.get(this.focusedAirport.uid);
                if (displayedAirport === undefined) {
                    const labels = this.runwayLabels.get(this.focusedAirport.uid);
                    labels === null || labels === void 0 ? void 0 : labels.forEach(l => this.textManager.deregister(l));
                    this.runwayLabels.delete(this.focusedAirport.uid);
                }
            }
            if (waypoint !== undefined) {
                const displayedAirport = this.displayedAirports.get(waypoint.uid);
                if (displayedAirport === undefined) {
                    this.processAirportWaypoint(waypoint);
                }
            }
            this.focusedAirport = waypoint;
            this.updateRequired = true;
        }
        /**
         * Processes an airport waypoint to generate runway labels.
         * @param waypoint The waypoint to process.
         */
        processAirportWaypoint(waypoint) {
            const oneWayRunways = [];
            const runways = waypoint.facility.get().runways;
            for (let i = 0; i < runways.length; i++) {
                oneWayRunways.push(...msfsSdk.RunwayUtils.getOneWayRunways(runways[i], i));
            }
            const runwayLabels = [];
            for (let i = 0; i < oneWayRunways.length; i++) {
                const runway = oneWayRunways[i];
                const label = new RunwayTextLabel(runway.designation, new msfsSdk.GeoPoint(runway.latitude, runway.longitude), runway.course, this.props.gnsType);
                runwayLabels.push(label);
                this.textManager.register(label);
            }
            this.runwayLabels.set(waypoint.uid, runwayLabels);
        }
        /** @inheritdoc */
        onDetached() {
            this.waypointAddedSub.destroy();
            this.waypointRemovedSub.destroy();
            this.runwaysDisplayedSub.destroy();
            this.labelsDisplayedSub.destroy();
            this.focusChangedSub.destroy();
            this.canvasLayerRef.instance.onDetached();
            this.labelLayerRef.instance.onDetached();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(msfsSdk.MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }),
                msfsSdk.FSComponent.buildComponent(msfsSdk.MapCullableTextLayer, { model: this.props.model, mapProjection: this.props.mapProjection, manager: this.textManager, ref: this.labelLayerRef })));
        }
    }
    /**
     * A map text label used for runway designations.
     */
    class RunwayTextLabel extends msfsSdk.MapCullableLocationTextLabel {
        /**
         * Constructor.
         * @param text The text of this label, or a subscribable which provides it.
         * @param location The geographic location of this label, or a subscribable which provides it.
         * @param runwayDirection The direction of the runway, used to offset the label.
         * @param gnsType The type of GNS unit that will display this runway label.
         */
        constructor(text, location, runwayDirection, gnsType) {
            const runwayLabelOffset = msfsSdk.Vec2Subject.create(new Float64Array(2));
            super(text, 0, location, false, {
                fontSize: gnsType === 'wt430' ? 14 : 10,
                fontColor: 'black',
                font: 'GreatNiftySymbol-Regular',
                anchor: new Float64Array([0.5, 0.5]),
                showBg: true,
                bgColor: 'white',
                bgPadding: msfsSdk.VecNMath.create(4, 0, 0, -1, 0),
                bgOutlineColor: 'black',
                bgOutlineWidth: 1,
                offset: runwayLabelOffset
            });
            this.runwayDirection = runwayDirection;
            this.runwayLabelOffset = runwayLabelOffset;
        }
        /** @inheritdoc */
        draw(context, mapProjection) {
            const relativeBearing = (this.runwayDirection * Avionics.Utils.DEG2RAD) + mapProjection.getRotation();
            const offsetVec = msfsSdk.Vec2Math.setFromPolar(1, relativeBearing + (Math.PI / 2), msfsSdk.MapCullableLocationTextLabel.tempVec2);
            const fontSize = this.fontSize.get();
            const width = 0.6 * fontSize * this.text.get().length;
            const height = fontSize;
            this.runwayLabelOffset.set(offsetVec[0] * width, offsetVec[1] * height);
            super.draw(context, mapProjection);
        }
    }

    /**
     * A map layer that displays the north compass arrow.
     */
    class CompassNorthLayer extends msfsSdk.MapLayer {
        constructor() {
            super(...arguments);
            this.arrowEl = msfsSdk.FSComponent.createRef();
            this.mapRotation = msfsSdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAttached() {
            this.mapRotation.map(msfsSdk.SubscribableMapFunctions.withPrecision(1)).sub(rotation => {
                this.arrowEl.instance.style.transform = `rotate3d(0, 0, 1, ${rotation}deg)`;
            });
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            if (msfsSdk.BitFlags.isAll(changeFlags, msfsSdk.MapProjectionChangeType.Rotation)) {
                this.mapRotation.set(mapProjection.getRotation() * Avionics.Utils.RAD2DEG);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-compass-north' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-compass-north-arrow', ref: this.arrowEl },
                    msfsSdk.FSComponent.buildComponent("svg", { viewBox: '0 0 24 24' },
                        msfsSdk.FSComponent.buildComponent("path", { d: 'M 4 22 L 12 1 L 20 22 L 12 18 Z', stroke: 'black', "stroke-width": '4px' }),
                        msfsSdk.FSComponent.buildComponent("path", { d: 'M 4 22 L 12 1 L 20 22 L 12 18 Z', stroke: 'white', fill: 'black', "stroke-width": '1px' }))),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-compass-north-label' }, "N")));
        }
    }

    /** An extended version of the map range module that handles setting a range simvar for tooltips. */
    class GNSMapIndexedRangeModule extends msfsSdk.MapIndexedRangeModule {
        /**
         * Create a GNSMapIndexedRangeModule.
         * @param rangeSimvar The SimVar to update with the current range in NM.
         */
        constructor(rangeSimvar) {
            super();
            this.rangeSimvar = rangeSimvar;
            if (rangeSimvar !== undefined) {
                this.nominalRange.sub(v => {
                    SimVar.SetSimVarValue(rangeSimvar, 'number', v.asUnit(msfsSdk.UnitType.NMILE));
                });
            }
        }
        /**
         * Update the map range simvar.
         */
        updateMapRangeSimvar() {
            if (this.rangeSimvar !== undefined) {
                SimVar.SetSimVarValue(this.rangeSimvar, 'number', this.nominalRange.get().asUnit(msfsSdk.UnitType.NMILE));
            }
        }
    }

    var AirspaceRenderType;
    (function (AirspaceRenderType) {
        AirspaceRenderType[AirspaceRenderType["GreenSingle"] = 0] = "GreenSingle";
        AirspaceRenderType[AirspaceRenderType["GreenDashed"] = 1] = "GreenDashed";
        AirspaceRenderType[AirspaceRenderType["Null"] = 2] = "Null";
    })(AirspaceRenderType || (AirspaceRenderType = {}));
    /**
     * Utility class containing functions defining the rendering behavior of airspaces for GNS maps.
     */
    class MapAirspaceRendering {
        /**
         * Determines the rendering order of airspaces for GNS maps.
         * @returns The relative rendering order of two airspaces for GNS maps.
         */
        static renderOrder() {
            return 0;
        }
        /**
         * Selects airspace renderers for GNS maps.
         * @param airspace The airspace to render.
         * @returns The renderer to use to render the specified airspace.
         */
        static selectRenderer(airspace) {
            switch (airspace.facility.type) {
                case msfsSdk.BoundaryType.ClassB:
                case msfsSdk.BoundaryType.ClassC:
                case msfsSdk.BoundaryType.ClassE:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.GreenSingle];
                case msfsSdk.BoundaryType.ClassD:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.GreenDashed];
                case msfsSdk.BoundaryType.Restricted:
                case msfsSdk.BoundaryType.Prohibited:
                case msfsSdk.BoundaryType.Warning:
                case msfsSdk.BoundaryType.Danger:
                case msfsSdk.BoundaryType.Training:
                case msfsSdk.BoundaryType.MOA:
                case msfsSdk.BoundaryType.Alert:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.GreenSingle];
                default:
                    return MapAirspaceRendering.RENDERERS[AirspaceRenderType.Null];
            }
        }
    }
    MapAirspaceRendering.RENDERERS = {
        [AirspaceRenderType.GreenSingle]: new msfsSdk.MapSingleLineAirspaceRenderer(0.8, '#00ff00', []),
        [AirspaceRenderType.GreenDashed]: new msfsSdk.MapSingleLineAirspaceRenderer(0.8, '#00ff00', [5, 5]),
        [AirspaceRenderType.Null]: new msfsSdk.NullAirspaceRenderer(),
    };

    /// <reference types="@microsoft/msfs-types/js/avionics" />
    /**
     * A map layer which draws a range compass in front of the map target.
     */
    class MapRangeCompassLayer extends msfsSdk.MapLayer {
        constructor() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            super(...arguments);
            this.rootRef = msfsSdk.FSComponent.createRef();
            this.arcLayerRef = msfsSdk.FSComponent.createRef();
            this.roseLayerContainerRef = msfsSdk.FSComponent.createRef();
            this.roseLayerRef = msfsSdk.FSComponent.createRef();
            this.roseLabelsLayerRef = msfsSdk.FSComponent.createRef();
            this.arcStrokeWidth = (_a = this.props.arcStrokeWidth) !== null && _a !== void 0 ? _a : MapRangeCompassLayer.DEFAULT_ARC_STROKE_WIDTH;
            this.arcStrokeColor = (_b = this.props.arcStrokeColor) !== null && _b !== void 0 ? _b : MapRangeCompassLayer.DEFAULT_ARC_STROKE_COLOR;
            this.arcEndTickLength = (_c = this.props.arcEndTickLength) !== null && _c !== void 0 ? _c : this.props.bearingTickMajorLength;
            this.bearingLabelFontColor = (_d = this.props.bearingLabelFontColor) !== null && _d !== void 0 ? _d : this.arcStrokeColor;
            this.bearingLabelOutlineWidth = (_e = this.props.bearingLabelOutlineWidth) !== null && _e !== void 0 ? _e : MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_WIDTH;
            this.bearingLabelOutlineColor = (_f = this.props.bearingLabelOutlineColor) !== null && _f !== void 0 ? _f : MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_COLOR;
            this.bearingLabelRadialOffset = (_g = this.props.bearingLabelRadialOffset) !== null && _g !== void 0 ? _g : MapRangeCompassLayer.DEFAULT_HEADING_LABEL_RADIAL_OFFSET;
            this.unitsModule = this.props.model.getModule(GNSMapKeys.Units);
            this.rangeModule = this.props.model.getModule(GNSMapKeys.Range);
            this.waypointBearingModule = this.props.model.getModule(GNSMapKeys.WaypointBearing);
            this.centerSubject = msfsSdk.Vec2Subject.create(new Float64Array(2));
            this.radiusSubject = msfsSdk.Subject.create(0);
            this.rotationSubject = msfsSdk.Subject.create(0);
            this.waypointBearingSubject = msfsSdk.Subject.create(undefined);
            this.magVarCorrectionSubject = msfsSdk.MappedSubject.create(([navAngle, magVar]) => navAngle.isMagnetic() ? magVar : 0, (_j = (_h = this.unitsModule) === null || _h === void 0 ? void 0 : _h.navAngle) !== null && _j !== void 0 ? _j : msfsSdk.Subject.create(msfsSdk.BasicNavAngleUnit.create(true)), this.props.model.getModule(msfsSdk.MapSystemKeys.OwnAirplaneProps).magVar);
            this.needUpdateRootVisibility = false;
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            this.needRotateBearingTicks = true;
            this.needReclipTicks = true;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.needUpdateRootVisibility = true;
            if (isVisible) {
                this.updateParameters();
            }
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.arcLayerRef.instance.onAttached();
            this.roseLayerRef.instance.onAttached();
            this.roseLabelsLayerRef.instance.onAttached();
            this.initListeners();
            this.updateVisibility();
            this.updateParameters();
        }
        /**
         * Initializes listeners.
         */
        initListeners() {
            this.initParameterListeners();
            this.initModuleListeners();
        }
        /**
         * Initializes parameter listeners.
         */
        initParameterListeners() {
            this.centerSubject.sub(this.onCenterChanged.bind(this));
            this.radiusSubject.sub(this.onRadiusChanged.bind(this));
            this.rotationSubject.sub(this.onRotationChanged.bind(this));
            this.waypointBearingSubject.sub(this.onWaypointBearingChanged.bind(this));
            this.magVarCorrectionSubject.sub(this.onMagVarCorrectionChanged.bind(this));
        }
        /**
         * Initializes modules listeners.
         */
        initModuleListeners() {
            var _a;
            this.rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
            (_a = this.waypointBearingModule) === null || _a === void 0 ? void 0 : _a.waypointBearing.sub(b => this.waypointBearingSubject.set(b));
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            this.arcLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.roseLabelsLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
            if (msfsSdk.BitFlags.isAll(changeFlags, msfsSdk.MapProjectionChangeType.ProjectedSize)) {
                // resizing the map will cause synced canvas layers to clear themselves, so we need to force a redraw on these
                // layers.
                this.needRedrawArc = true;
                this.needRedrawBearings = true;
            }
            if (!this.isVisible()) {
                return;
            }
            this.updateParameters();
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            if (this.needUpdateRootVisibility) {
                this.updateRootVisibility();
                this.needUpdateRootVisibility = false;
            }
            if (!this.isVisible()) {
                return;
            }
            this.redraw();
            this.updateSubLayers(time, elapsed);
        }
        /**
         * Updates the visibility of this layer's root.
         */
        updateRootVisibility() {
            this.rootRef.instance.style.display = this.isVisible() ? 'block' : 'none';
        }
        /**
         * Redraws the compass.
         */
        redraw() {
            this.redrawArc();
            this.redrawBearings();
        }
        /**
         * Redraws the arc of the compass.
         */
        redrawArc() {
            if (!this.needRedrawArc) {
                return;
            }
            const arcLayerDisplay = this.arcLayerRef.instance.display;
            arcLayerDisplay.clear();
            const center = this.centerSubject.get();
            const radius = this.radiusSubject.get();
            const angularWidthRad = MapRangeCompassLayer.ARC_ANGULAR_WIDTH * Avionics.Utils.DEG2RAD;
            const startAngle = -Math.PI / 2 - angularWidthRad / 2;
            const pathStart = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(radius, startAngle, MapRangeCompassLayer.vec2Cache[1]), center, MapRangeCompassLayer.vec2Cache[1]);
            this.composeArcPath(center, radius, angularWidthRad, pathStart);
            arcLayerDisplay.context.lineWidth = this.arcStrokeWidth + 3;
            arcLayerDisplay.context.strokeStyle = 'black';
            arcLayerDisplay.context.stroke();
            this.composeArcPath(center, radius, angularWidthRad, pathStart);
            arcLayerDisplay.context.lineWidth = this.arcStrokeWidth;
            arcLayerDisplay.context.strokeStyle = this.arcStrokeColor;
            arcLayerDisplay.context.stroke();
            this.needRedrawArc = false;
        }
        /**
         * Composes the path of the compass arc.
         * @param center The center of the compass, in pixels.
         * @param radius The radius of the compass, in pixels.
         * @param angularWidth The angular width of the arc, in radians.
         * @param pathStart The position of the start of the left end of the arc, in pixels.
         */
        composeArcPath(center, radius, angularWidth, pathStart) {
            const arcLayerDisplay = this.arcLayerRef.instance.display;
            arcLayerDisplay.context.beginPath();
            arcLayerDisplay.context.moveTo(pathStart[0], pathStart[1]);
            arcLayerDisplay.context.arc(center[0], center[1], radius, (-angularWidth - Math.PI) / 2, (angularWidth - Math.PI) / 2);
        }
        /**
         * Redraws the bearing tick and labels.
         */
        redrawBearings() {
            if (!this.needRedrawBearings && !this.needRotateBearingTicks) {
                return;
            }
            this.roseLabelsLayerRef.instance.redraw();
            this.roseLayerRef.instance.updateRotation();
            this.needRotateBearingTicks = false;
            if (!this.needRedrawBearings && !this.needReclipTicks) {
                return;
            }
            if (this.needReclipTicks) {
                this.updateBearingTickClip();
            }
            this.roseLayerRef.instance.redraw();
            this.needRedrawBearings = false;
        }
        /**
         * Updates the bearing tick clip mask.
         */
        updateBearingTickClip() {
            const center = this.centerSubject.get();
            const radius = this.radiusSubject.get();
            const thick = this.arcStrokeWidth / 2;
            const innerToOuterLength = this.arcEndTickLength + thick + 5;
            const totalRadius = radius + this.arcEndTickLength + thick / 2 + 5;
            const leftAngle = -MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2 * Avionics.Utils.DEG2RAD - Math.PI / 2;
            const leftInner1 = msfsSdk.Vec2Math.setFromPolar(radius - thick / 2, leftAngle, MapRangeCompassLayer.vec2Cache[0]);
            const leftInner2 = msfsSdk.Vec2Math.setFromPolar(thick / 2, leftAngle - Math.PI / 2, MapRangeCompassLayer.vec2Cache[1]);
            const leftOuter = msfsSdk.Vec2Math.setFromPolar(innerToOuterLength, leftAngle, MapRangeCompassLayer.vec2Cache[2]);
            const outerWidth = Math.abs(leftInner1[0] + leftInner2[0] + leftOuter[0]) * 2;
            this.roseLayerContainerRef.instance.style.webkitClipPath // the cast is to avoid typescript complaining webkitCliPath doesn't exist
                = `path('M${center[0]},${center[1]} l${leftInner1[0]},${leftInner1[1]} l${leftInner2[0]},${leftInner2[1]} l${leftOuter[0]},${leftOuter[1]} a${totalRadius},${totalRadius},0,0,1,${outerWidth},0 l${leftInner2[0]},${-leftInner2[1]} l${leftInner1[0]},${-leftInner1[1]} Z')`;
            this.needReclipTicks = false;
        }
        /**
         * Updates this layer's sublayers.
         * @param time The current time as a UNIX timestamp.
         * @param elapsed The elapsed time, in milliseconds, since the last update.
         */
        updateSubLayers(time, elapsed) {
            this.arcLayerRef.instance.onUpdated(time, elapsed);
            this.roseLayerRef.instance.onUpdated(time, elapsed);
            this.roseLabelsLayerRef.instance.onUpdated(time, elapsed);
        }
        /**
         * Updates this layer's visibility.
         */
        updateVisibility() {
            this.setVisible(true);
        }
        /**
         * Updates the ring.
         */
        updateParameters() {
            var _a;
            const center = this.props.mapProjection.getTargetProjected();
            const radius = this.rangeModule.nominalRange.get().asUnit(msfsSdk.UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const rotation = Math.round((this.props.mapProjection.getRotation() + this.magVarCorrectionSubject.get() * Avionics.Utils.DEG2RAD) * 1e4) / 1e4;
            this.centerSubject.set(center);
            this.radiusSubject.set(radius);
            this.rotationSubject.set(rotation);
            this.waypointBearingSubject.set((_a = this.waypointBearingModule) === null || _a === void 0 ? void 0 : _a.waypointBearing.get());
        }
        /**
         * Responds to changes in the location of the center of the compass.
         */
        onCenterChanged() {
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            this.needReclipTicks = true;
        }
        /**
         * Responds to changes in the radius of the compass.
         */
        onRadiusChanged() {
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            this.needReclipTicks = true;
        }
        /**
         * Responds to changes in the rotation of the compass.
         */
        onRotationChanged() {
            this.needRotateBearingTicks = true;
        }
        /**
         * Responds to changes in the DTK.
         */
        onWaypointBearingChanged() {
            this.needRedrawBearings = true;
        }
        /**
         * Responds to changes in the magnetic variation correction for the compass.
         */
        onMagVarCorrectionChanged() {
            if (this.isVisible()) {
                this.updateParameters();
            }
        }
        /**
         * Responds to changes in the nominal map range.
         */
        onRangeChanged() {
            if (this.isVisible()) {
                this.updateParameters();
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.rootRef, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
                msfsSdk.FSComponent.buildComponent(msfsSdk.MapSyncedCanvasLayer, { ref: this.arcLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
                msfsSdk.FSComponent.buildComponent("div", { ref: this.roseLayerContainerRef, style: 'position: absolute; width: 100%; height: 100%;' },
                    msfsSdk.FSComponent.buildComponent(MapRangeCompassRose, { ref: this.roseLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassWptBearingSubject: this.waypointBearingSubject, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, tickMajorInterval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, tickMinorMultiplier: MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR, tickMajorLength: this.props.bearingTickMajorLength, tickMinorLength: this.props.bearingTickMinorLength, tickStrokeWidth: this.arcStrokeWidth, tickStrokeColor: this.arcStrokeColor })),
                msfsSdk.FSComponent.buildComponent(MapRangeCompassRoseLabels, { ref: this.roseLabelsLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassWptBearingSubject: this.waypointBearingSubject, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, angularWidth: MapRangeCompassLayer.ARC_ANGULAR_WIDTH, interval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, font: this.props.bearingLabelFont, fontSize: this.props.bearingLabelFontSize, fontColor: this.bearingLabelFontColor, outlineWidth: this.bearingLabelOutlineWidth, outlineColor: this.bearingLabelOutlineColor, radialOffset: this.props.bearingTickMajorLength + this.bearingLabelRadialOffset })));
        }
    }
    /** The angular width of the compass arc, in degrees. */
    MapRangeCompassLayer.ARC_ANGULAR_WIDTH = 130;
    /** The angular interval, in degrees, between major bearing ticks. */
    MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL = 30;
    /** The number of minor bearing ticks per major bearing tick. */
    MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR = 3;
    /** The radial on which the range label is positioned, in degrees. */
    MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE = -135;
    MapRangeCompassLayer.DEFAULT_ARC_STROKE_WIDTH = 2; // px
    MapRangeCompassLayer.DEFAULT_ARC_STROKE_COLOR = 'white';
    MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_WIDTH = 6; // px
    MapRangeCompassLayer.DEFAULT_HEADING_LABEL_OUTLINE_COLOR = 'black';
    MapRangeCompassLayer.DEFAULT_HEADING_LABEL_RADIAL_OFFSET = 0; // px
    MapRangeCompassLayer.vec2Cache = Array.from({ length: 4 }, () => new Float64Array(2));
    /**
     * A rotating compass rose with unlabeled graduated bearing ticks.
     */
    class MapRangeCompassRose extends msfsSdk.MapCanvasLayer {
        constructor() {
            super(...arguments);
            this.bearingStep = this.props.tickMajorInterval / this.props.tickMinorMultiplier * Avionics.Utils.DEG2RAD;
            this.numMinorBearingTicks = Math.floor(2 * Math.PI / this.bearingStep);
        }
        /**
         * Redraws the canvas.
         */
        redraw() {
            const center = this.props.compassCenterSubject.get();
            const radius = this.props.compassRadiusSubject.get();
            const canvasSize = Math.ceil(radius) * 2;
            this.setWidth(canvasSize);
            this.setHeight(canvasSize);
            this.display.canvas.style.left = `${center[0] - canvasSize / 2}px`;
            this.display.canvas.style.top = `${center[1] - canvasSize / 2}px`;
            this.display.clear();
            this.composeBearingTicksPath(radius);
            this.display.context.lineWidth = this.props.tickStrokeWidth + 3;
            this.display.context.strokeStyle = 'black';
            this.display.context.stroke();
            this.composeBearingTicksPath(radius);
            this.display.context.lineWidth = this.props.tickStrokeWidth;
            this.display.context.strokeStyle = this.props.tickStrokeColor;
            this.display.context.stroke();
        }
        /**
         * Composes the path of the bearing ticks.
         * @param radius The radius of the compass, in pixels.
         */
        composeBearingTicksPath(radius) {
            const canvasSize = this.getWidth();
            const center = msfsSdk.Vec2Math.set(canvasSize / 2, canvasSize / 2, MapRangeCompassRose.vec2Cache[0]);
            this.display.context.beginPath();
            for (let i = 0; i < this.numMinorBearingTicks; i++) {
                const bearing = i * this.bearingStep;
                const angle = bearing - Math.PI / 2;
                let start;
                if (i % MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR === 0) {
                    // major tick
                    start = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(radius - this.props.tickMajorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
                }
                else {
                    // minor tick
                    start = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(radius - this.props.tickMinorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
                }
                const end = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(radius, angle, MapRangeCompassRose.vec2Cache[2]), center, MapRangeCompassRose.vec2Cache[2]);
                this.display.context.moveTo(start[0], start[1]);
                this.display.context.lineTo(end[0], end[1]);
            }
        }
        /**
         * Updates the rotation of this rose.
         */
        updateRotation() {
            this.display.canvas.style.transform = `rotate(${this.props.compassRotationSubject.get()}rad)`;
        }
    }
    MapRangeCompassRose.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
    /**
     * Bearing labels for a rotating range compass rose.
     */
    class MapRangeCompassRoseLabels extends msfsSdk.MapSyncedCanvasLayer {
        constructor() {
            super(...arguments);
            this.normalFont = `${this.props.fontSize}px ${this.props.font}`;
            this.majorFont = `${this.props.fontSize + 4}px ${this.props.font}`;
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.initStyles();
        }
        /**
         * Initializes styles on this layer's canvas context.
         */
        initStyles() {
            this.display.context.lineWidth = this.props.outlineWidth * 2;
            this.display.context.strokeStyle = this.props.outlineColor;
            this.display.context.font = this.normalFont;
            this.display.context.fillStyle = this.props.fontColor;
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            super.onMapProjectionChanged(mapProjection, changeFlags);
            if (msfsSdk.BitFlags.isAll(changeFlags, msfsSdk.MapProjectionChangeType.ProjectedSize)) {
                this.initStyles();
            }
        }
        /**
         * Redraws the bearing labels.
         */
        redraw() {
            this.display.clear();
            const PI2 = Math.PI * 2;
            const center = this.props.compassCenterSubject.get();
            const radius = this.props.compassRadiusSubject.get();
            const rotation = this.props.compassRotationSubject.get();
            const dtk = this.props.compassWptBearingSubject.get();
            const halfAngularWidth = this.props.angularWidth / 2 * Avionics.Utils.DEG2RAD;
            const centerBearing = (-rotation + PI2) % PI2;
            const intervalRad = this.props.interval * Avionics.Utils.DEG2RAD;
            for (let bearing = 0; bearing < PI2; bearing += intervalRad) {
                if (Math.min(Math.abs(bearing - centerBearing), PI2 - Math.abs(bearing - centerBearing)) > halfAngularWidth) {
                    continue;
                }
                this.drawBearingLabel(center, radius, rotation, bearing);
            }
            this.drawBearingPointer(center, radius, rotation, dtk);
        }
        /**
         * Draws a bearing label.
         * @param center The center of the compass, in pixels.
         * @param radius The radius of the compass, in pixels.
         * @param rotation The rotation of the compass, in radians.
         * @param bearing The label's bearing, in radians.
         */
        drawBearingLabel(center, radius, rotation, bearing) {
            // TODO: support the T superscript for true bearings.
            const bearingDeg = (360 - (360 - (bearing * Avionics.Utils.RAD2DEG)) % 360);
            let text = (bearingDeg / 10).toFixed(0);
            let font = this.normalFont;
            switch (text) {
                case '36':
                case '0':
                    text = 'N';
                    font = this.majorFont;
                    break;
                case '9':
                    text = 'E';
                    font = this.majorFont;
                    break;
                case '18':
                    text = 'S';
                    font = this.majorFont;
                    break;
                case '27':
                    text = 'W';
                    font = this.majorFont;
                    break;
            }
            if (this.display.context.font !== font) {
                this.display.context.font = font;
            }
            const angle = bearing - Math.PI / 2 + rotation;
            const textWidth = this.display.context.measureText(text).width;
            const textHeight = this.props.fontSize;
            const textOffset = Math.hypot(textWidth, textHeight) / 2 + this.props.radialOffset;
            const textRadius = radius - textOffset;
            const labelPos = msfsSdk.Vec2Math.add(msfsSdk.Vec2Math.setFromPolar(textRadius, angle, MapRangeCompassRoseLabels.vec2Cache[0]), msfsSdk.Vec2Math.set(center[0] - textWidth / 2, center[1] + textHeight / 2, MapRangeCompassRoseLabels.vec2Cache[1]), MapRangeCompassRoseLabels.vec2Cache[0]);
            if (this.props.outlineWidth > 0) {
                this.display.context.strokeText(text, labelPos[0], labelPos[1]);
            }
            this.display.context.fillText(text, labelPos[0], labelPos[1]);
        }
        /**
         * Draws the waypoint bearing pointer.
         * @param center The center of the arc.
         * @param radius The radius of the arc.
         * @param rotation The current polar rotation of the map.
         * @param bearing The bearing to the current waypoint, in true degrees north.
         */
        drawBearingPointer(center, radius, rotation, bearing) {
            if (bearing !== undefined) {
                const PI2 = Math.PI * 2;
                const halfPi = Math.PI / 2;
                const dtkRadians = bearing * Avionics.Utils.DEG2RAD;
                const centerBearing = (-rotation + PI2) % PI2;
                let angle = (centerBearing - dtkRadians + Math.PI) % PI2 - Math.PI;
                angle = angle < -180 ? angle + PI2 : angle;
                const oldStrokeStyle = this.display.context.strokeStyle;
                this.display.context.strokeStyle = '#0f0';
                this.display.context.lineWidth = 3;
                this.display.context.beginPath();
                const maxAngularWidth = (this.props.angularWidth / 2) * Avionics.Utils.DEG2RAD;
                if (angle >= maxAngularWidth || angle <= -maxAngularWidth) {
                    const sign = angle > maxAngularWidth ? -1 : 1;
                    const polarAngle = (maxAngularWidth * sign) + halfPi;
                    const ySwappedPolarAngle = (polarAngle + Math.PI) % PI2;
                    const pos = msfsSdk.Vec2Math.add(center, msfsSdk.Vec2Math.setFromPolar(radius, ySwappedPolarAngle, MapRangeCompassRoseLabels.vec2Cache[0]), MapRangeCompassRoseLabels.vec2Cache[0]);
                    this.display.context.moveTo(pos[0], pos[1]);
                    this.display.context.lineTo(pos[0] + (3 * -sign), pos[1] + 6);
                    this.display.context.lineTo(pos[0] + (9 * -sign), pos[1] + 6);
                    this.display.context.stroke();
                }
                else {
                    const correctedAngle = -angle + halfPi;
                    const correctedOppositeAngle = (correctedAngle + Math.PI) % PI2;
                    const pos = msfsSdk.Vec2Math.add(center, msfsSdk.Vec2Math.setFromPolar(radius, correctedOppositeAngle, MapRangeCompassRoseLabels.vec2Cache[0]), MapRangeCompassRoseLabels.vec2Cache[0]);
                    const arrowAngularWidth = 30 * Avionics.Utils.DEG2RAD;
                    this.display.context.moveTo(pos[0], pos[1]);
                    const leftAngle = msfsSdk.Vec2Math.setFromPolar(14, correctedAngle + (arrowAngularWidth / 2), MapRangeCompassRoseLabels.vec2Cache[1]);
                    const leftEndPos = msfsSdk.Vec2Math.add(pos, leftAngle, MapRangeCompassRoseLabels.vec2Cache[1]);
                    this.display.context.lineTo(leftEndPos[0], leftEndPos[1]);
                    const rightAngle = msfsSdk.Vec2Math.setFromPolar(14, correctedAngle - (arrowAngularWidth / 2), MapRangeCompassRoseLabels.vec2Cache[1]);
                    const rightEndPos = msfsSdk.Vec2Math.add(pos, rightAngle, MapRangeCompassRoseLabels.vec2Cache[1]);
                    this.display.context.moveTo(pos[0], pos[1]);
                    this.display.context.lineTo(rightEndPos[0], rightEndPos[1]);
                    this.display.context.stroke();
                }
                this.display.context.strokeStyle = oldStrokeStyle;
            }
        }
    }
    MapRangeCompassRoseLabels.vec2Cache = [new Float64Array(2), new Float64Array(2)];

    msfsSdk.ImageCache.addToCache('INTERSECTION', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/intersection_cyan.png');
    msfsSdk.ImageCache.addToCache('AIRPORT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/airport_magenta.png');
    msfsSdk.ImageCache.addToCache('VOR', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/vor.png');
    msfsSdk.ImageCache.addToCache('VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/vordme.png');
    msfsSdk.ImageCache.addToCache('NDB_MH', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/ndb.png');
    msfsSdk.ImageCache.addToCache('NDB', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/ndbdme.png');
    msfsSdk.ImageCache.addToCache('LEGICON_DEFAULT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_default.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_ARC_LEFT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_arc_left.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_ARC_RIGHT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_arc_right.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_DIRECTTO', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_directto.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_DIRECTTO_WHITE', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_directto_white.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_HOLD_LEFT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_hold_left.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_HOLD_RIGHT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_hold_right.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_PTURN_LEFT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_pturn_left.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_PTURN_RIGHT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_pturn_right.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_PTURN_LEFT_GREEN', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_pturn_left_green.svg');
    msfsSdk.ImageCache.addToCache('LEGICON_PTURN_RIGHT_GREEN', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legicon_pturn_right_green.svg');
    /**
     * Gets facility icon data.
     */
    class Icons {
        /**
         * Gets the icon image source for a given facility.
         * @param facility The facility to get the source for.
         * @returns The icon image source URI.
         */
        static getByFacility(facility) {
            switch (msfsSdk.ICAO.getFacilityType(facility.icao)) {
                case msfsSdk.FacilityType.Airport:
                    return msfsSdk.ImageCache.get('AIRPORT');
                case msfsSdk.FacilityType.VOR:
                    return facility.type === msfsSdk.VorType.VORDME ? msfsSdk.ImageCache.get('VORDME') : msfsSdk.ImageCache.get('VOR');
                case msfsSdk.FacilityType.NDB:
                    return facility.type === msfsSdk.NdbType.MH ? msfsSdk.ImageCache.get('NDB_MH') : msfsSdk.ImageCache.get('NDB');
                default:
                    return msfsSdk.ImageCache.get('INTERSECTION');
            }
        }
    }

    const OwnshipIconPath = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/ownship.png';
    var AdditionalRoles;
    (function (AdditionalRoles) {
        AdditionalRoles["ActiveFlightPlan"] = "ActiveFlightPlan";
    })(AdditionalRoles || (AdditionalRoles = {}));
    /** Map waypoint roles for the GNS map. */
    const GNSMapWaypointRoles = Object.assign(Object.assign({}, msfsSdk.MapSystemWaypointRoles), AdditionalRoles);
    /** A collection of static flight path render styles. */
    class FlightPathStyles {
        /**
         * Builds non-active leg styles for hold legs.
         * @param vector The vector being rendered.
         * @param isIngress Whether or not this vector is an ingress vector.
         * @returns The appropriate hold leg display style.
         */
        static buildWhiteHoldStyles(vector, isIngress) {
            return isIngress ? FlightPathStyles.WhiteDashed : FlightPathStyles.White;
        }
        /**
         * Builds hold displays with an active hold entry.
         * @param vector The vector being rendered.
         * @param isIngress Whether or not this vector is an ingress vector.
         * @returns The appropriate hold leg display style.
         */
        static buildActiveEntryHoldStyles(vector, isIngress) {
            return isIngress ? FlightPathStyles.MagentaDashed : FlightPathStyles.White;
        }
    }
    FlightPathStyles.Magenta = {
        isDisplayed: true,
        width: 3,
        style: 'magenta'
    };
    FlightPathStyles.MagentaDashed = {
        isDisplayed: true,
        width: 3,
        style: 'magenta',
        dash: [6, 4]
    };
    FlightPathStyles.White = {
        isDisplayed: true,
        width: 3,
        style: 'white'
    };
    FlightPathStyles.WhiteDashed = {
        isDisplayed: true,
        width: 3,
        style: 'white',
        dash: [6, 4]
    };
    FlightPathStyles.Gray = {
        isDisplayed: true,
        width: 1,
        style: 'gray'
    };
    FlightPathStyles.InactiveHold = {
        partsToRender: msfsSdk.FlightPathLegRenderPart.Base | msfsSdk.FlightPathLegRenderPart.Ingress,
        styleBuilder: FlightPathStyles.buildWhiteHoldStyles
    };
    FlightPathStyles.ActiveHoldEntry = {
        partsToRender: msfsSdk.FlightPathLegRenderPart.Base | msfsSdk.FlightPathLegRenderPart.Ingress,
        styleBuilder: FlightPathStyles.buildActiveEntryHoldStyles
    };
    /**
     * A class that configures displays on the map system.
     */
    class MapSystemConfig {
        /**
         * Builds a label for facility waypoints.
         * @param size The size of the label.
         * @returns A new factory that will create the label.
         */
        static buildFacilityLabel(size) {
            return (w) => {
                return new msfsSdk.MapCullableLocationTextLabel(msfsSdk.ICAO.getIdent(w.facility.get().icao), 0, w.location, false, {
                    fontSize: size,
                    fontColor: '#ccc',
                    font: 'GreatNiftySymbol-Regular',
                    anchor: new Float64Array([0.5, 1.50]),
                    showBg: true,
                    bgColor: 'black',
                    bgPadding: msfsSdk.VecNMath.create(4, 1, 1, -2, 1)
                });
            };
        }
        /**
         * Builds a label for airport waypoints.
         * @param large The size of the label, for large airports.
         * @param med The size of the label, for medium airports.
         * @param small The size of the label, for small airports.
         * @returns A new factory that will create the label.
         */
        static buildAirportLabel(large, med, small) {
            return (w) => {
                let size = small;
                if (w.size === msfsGarminsdk.AirportSize.Large) {
                    size = large;
                }
                else if (w.size === msfsGarminsdk.AirportSize.Medium) {
                    size = med;
                }
                return new msfsSdk.MapCullableLocationTextLabel(msfsSdk.ICAO.getIdent(w.facility.get().icao), 0, w.location, false, {
                    fontSize: size,
                    fontColor: '#ccc',
                    font: 'GreatNiftySymbol-Regular',
                    anchor: new Float64Array([0.5, 1.50]),
                    showBg: true,
                    bgColor: 'black',
                    bgPadding: msfsSdk.VecNMath.create(4, 1, 1, -2, 1)
                });
            };
        }
        /**
         * Builds an airport facility icon.
         * @param gnsType The type of GNS unit to configure.
         * @returns A function that builds the icon.
         */
        static buildAirportIcon(gnsType) {
            return (w) => new msfsSdk.MapWaypointSpriteIcon(w, 0, Icons.getByFacility(w.facility.get()), 13, 13, gnsType === 'wt430' ? msfsSdk.Vec2Math.create(17, 17) : msfsSdk.Vec2Math.create(13, 13), undefined, (mapProjection) => {
                if (!w.longestRunway) {
                    return 0;
                }
                const mapRotationDeg = mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
                return Math.round(msfsSdk.NavMath.normalizeHeading((w.longestRunway.direction + mapRotationDeg)) / 22.5) % 8;
            });
        }
        /**
         * Configures the GNS waypoint display.
         * @param bus The event bus to use with this waypoints display.
         * @param settingsProvider The GNS settings provider containing map settings.
         * @param gnsType The type of GNS unit to configure.
         * @returns A function that builds the GNS waypoint display.
         */
        static configureWaypoints(bus, settingsProvider, gnsType) {
            const largeAirportWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_large_apt_size'), gnsType);
            const medAirportWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_medium_apt_size'), gnsType);
            const smallAirportWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_small_apt_size'), gnsType);
            const intWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_int_size'), gnsType);
            const ndbWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_ndb_size'), gnsType);
            const vorWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_vor_size'), gnsType);
            const userWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_user_size'), gnsType);
            return (builder) => {
                builder.withSearchCenter('target')
                    .withWaypointCache(msfsGarminsdk.GarminFacilityWaypointCache.getCache(bus))
                    .addDefaultIcon(GNSMapWaypointRoles.Normal, w => new msfsSdk.MapWaypointImageIcon(w, 0, msfsSdk.ImageCache.get('INTERSECTION'), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12)))
                    .addDefaultLabel(GNSMapWaypointRoles.Normal, MapSystemConfig.buildFacilityLabel(intWaypointSize))
                    .addLabel(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.NDB, MapSystemConfig.buildFacilityLabel(ndbWaypointSize))
                    .addLabel(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.VOR, MapSystemConfig.buildFacilityLabel(vorWaypointSize))
                    .addLabel(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.User, MapSystemConfig.buildFacilityLabel(userWaypointSize))
                    .addLabel(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.Airport, MapSystemConfig.buildAirportLabel(largeAirportWaypointSize, medAirportWaypointSize, smallAirportWaypointSize))
                    .addIcon(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.Airport, MapSystemConfig.buildAirportIcon(gnsType))
                    .addIcon(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.VOR, (w) => {
                    if (w.facility.get().type === msfsSdk.VorType.VORDME) {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(17, 17) : msfsSdk.Vec2Math.create(13, 13));
                    }
                    else {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12));
                    }
                })
                    .addIcon(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.NDB, (w) => {
                    if (w.facility.get().type === msfsSdk.NdbType.MH) {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(17, 17) : msfsSdk.Vec2Math.create(13, 13));
                    }
                    else {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12));
                    }
                });
            };
        }
        /**
         * Gets a waypoint size subject from a size setting.
         * @param setting The setting to map.
         * @param gnsType The type of GNS unit to configure.
         * @returns A subject that maps the waypoint size setting to a font size value.
         */
        static getWaypointSize(setting, gnsType) {
            const subject = msfsSdk.Subject.create(gnsType === 'wt430' ? 14 : 10);
            setting.sub(size => {
                switch (size) {
                    case MapSettingsWaypointSizes.Off:
                        subject.set(0);
                        break;
                    case MapSettingsWaypointSizes.Med:
                        subject.set(gnsType === 'wt430' ? 15 : 11);
                        break;
                    case MapSettingsWaypointSizes.Large:
                        subject.set(gnsType === 'wt430' ? 17 : 13);
                        break;
                    default:
                        subject.set(gnsType === 'wt430' ? 14 : 10);
                        break;
                }
            }, true);
            return subject;
        }
        /**
         * Configures the GNS flight plan map display.
         * @param settingsProvider The GNS settings provider containing map settings.
         * @param gnsType The type of GNS unit to configure.
         * @param bus An instance of the event bus.
         * @returns A function that configures the flight plan map display.
         */
        static configureFlightPlan(settingsProvider, gnsType, bus) {
            return (builder) => {
                const fplWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_fpl_size'), gnsType);
                builder
                    .withAnticipationTurns(false)
                    .registerRole(GNSMapWaypointRoles.ActiveFlightPlan)
                    .addDefaultIcon(GNSMapWaypointRoles.FlightPlan, w => new msfsSdk.MapWaypointImageIcon(w, 0, msfsSdk.ImageCache.get('INTERSECTION'), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12)))
                    .addDefaultIcon(GNSMapWaypointRoles.ActiveFlightPlan, w => new msfsSdk.MapWaypointImageIcon(w, 0, msfsSdk.ImageCache.get('INTERSECTION'), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12)))
                    .addDefaultLabel(GNSMapWaypointRoles.FlightPlan, MapSystemConfig.buildFlightPlanLabel('#000', '#ccc', fplWaypointSize))
                    .addDefaultLabel(GNSMapWaypointRoles.ActiveFlightPlan, MapSystemConfig.buildFlightPlanLabel('magenta', '#000', fplWaypointSize));
                builder.withLegWaypointRoles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (legIndex < activeLegIndex) {
                        return 0;
                    }
                    else if (legIndex === activeLegIndex) {
                        return builder.getRoleId(GNSMapWaypointRoles.ActiveFlightPlan);
                    }
                    else {
                        return builder.getRoleId(GNSMapWaypointRoles.FlightPlan);
                    }
                });
                let activeFlightPlanIndex = 0;
                const lnavTransitionType = msfsSdk.ConsumerSubject.create(bus.getSubscriber().on('lnav_transition_mode').whenChanged(), msfsSdk.LNavTransitionMode.None);
                bus.getSubscriber().on('fplIndexChanged').handle(ev => activeFlightPlanIndex = ev.planIndex);
                builder.withLegPathStyles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    const missedApproachActive = activeLeg !== undefined && msfsSdk.BitFlags.isAny(activeLeg.flags, msfsSdk.LegDefinitionFlags.MissedApproach);
                    if (msfsSdk.BitFlags.isAny(leg.flags, msfsSdk.LegDefinitionFlags.MissedApproach) && !missedApproachActive) {
                        return FlightPathStyles.Gray;
                    }
                    const isActivePlan = activeFlightPlanIndex === builder.planIndex;
                    const isHoldLeg = (leg.leg.type === msfsSdk.LegType.HM || leg.leg.type === msfsSdk.LegType.HF || leg.leg.type === msfsSdk.LegType.HA);
                    if (legIndex < activeLegIndex) {
                        return msfsSdk.FlightPathRenderStyle.Hidden;
                    }
                    else if (legIndex === activeLegIndex) {
                        if (isActivePlan) {
                            return isHoldLeg
                                ? (lnavTransitionType.get() === msfsSdk.LNavTransitionMode.Ingress) ? FlightPathStyles.ActiveHoldEntry : FlightPathStyles.Magenta
                                : FlightPathStyles.Magenta;
                        }
                        else {
                            return isHoldLeg ? FlightPathStyles.InactiveHold : FlightPathStyles.White;
                        }
                    }
                    else {
                        return isHoldLeg
                            ? FlightPathStyles.InactiveHold : FlightPathStyles.White;
                    }
                });
            };
        }
        /**
         * Configures the GNS procedure preview plan map display.
         * @param settingsProvider The GNS settings provider containing map settings.
         * @param gnsType The type of GNS unit to configure.
         * @returns A function that configures the preview plan map display.
         */
        static configureProcedurePreviewPlan(settingsProvider, gnsType) {
            return (builder) => {
                const fplWaypointSize = MapSystemConfig.getWaypointSize(settingsProvider.map.getSetting('wpt_fpl_size'), gnsType);
                builder
                    .withAnticipationTurns(false)
                    .addDefaultIcon(GNSMapWaypointRoles.FlightPlan, w => new msfsSdk.MapWaypointImageIcon(w, 0, msfsSdk.ImageCache.get('INTERSECTION'), msfsSdk.Vec2Math.create(12, 12)))
                    .addDefaultLabel(GNSMapWaypointRoles.FlightPlan, MapSystemConfig.buildFlightPlanLabel('#ccc', '#000', fplWaypointSize))
                    .addIcon(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.Airport, MapSystemConfig.buildAirportIcon(gnsType))
                    .addIcon(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.VOR, (w) => {
                    if (w.facility.get().type === msfsSdk.VorType.VORDME) {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(17, 17) : msfsSdk.Vec2Math.create(13, 13));
                    }
                    else {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12));
                    }
                })
                    .addIcon(GNSMapWaypointRoles.Normal, msfsSdk.WaypointTypes.NDB, (w) => {
                    if (w.facility.get().type === msfsSdk.NdbType.MH) {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(17, 17) : msfsSdk.Vec2Math.create(13, 13));
                    }
                    else {
                        return new msfsSdk.MapWaypointImageIcon(w, 0, Icons.getByFacility(w.facility.get()), gnsType === 'wt430' ? msfsSdk.Vec2Math.create(16, 16) : msfsSdk.Vec2Math.create(12, 12));
                    }
                });
                builder.withLegWaypointRoles(() => builder.getRoleId(GNSMapWaypointRoles.FlightPlan));
                const defaultStyle = {
                    isDisplayed: true,
                    width: 3,
                    style: '#ccc'
                };
                const missedApproachStyle = {
                    isDisplayed: true,
                    width: 1,
                    style: '#ccc'
                };
                builder.withLegPathStyles((plan, leg) => {
                    if (msfsSdk.BitFlags.isAny(leg.flags, msfsSdk.LegDefinitionFlags.MissedApproach)) {
                        return missedApproachStyle;
                    }
                    else {
                        return defaultStyle;
                    }
                });
            };
        }
        /**
         * Configures the GNS transition portion of the procedure preview plan map display.
         * @returns A function that configures the transition portion of the preview plan map display.
         */
        static configureTransitionPreviewPlan() {
            return (builder) => {
                builder
                    .withAnticipationTurns(false)
                    .withLegWaypointRoles(() => 0);
                const defaultStyle = {
                    isDisplayed: true,
                    width: 1,
                    style: '#ccc'
                };
                builder.withLegPathStyles(() => defaultStyle);
            };
        }
        /**
         * Builds a label for a flight plan waypoint.
         * @param color The color of the text of the label.
         * @param bgColor The background color of the label.
         * @param size The size of the label.
         * @returns A function that builds the flight plan waypoint label.
         */
        static buildFlightPlanLabel(color, bgColor, size) {
            return (w) => {
                if (msfsSdk.FacilityWaypointUtils.isFacilityWaypoint(w)) {
                    return new msfsSdk.MapCullableLocationTextLabel(msfsSdk.ICAO.getIdent(w.facility.get().icao), 0, w.location, true, {
                        fontSize: size,
                        fontColor: color,
                        font: 'GreatNiftySymbol-Regular',
                        anchor: new Float64Array([0.5, 1.50]),
                        showBg: true,
                        bgColor: bgColor,
                        bgPadding: msfsSdk.VecNMath.create(4, 1, 1, -2, 1)
                    });
                }
                if (w instanceof msfsSdk.FlightPathWaypoint) {
                    if (w.ident.toLowerCase() === 'hold') {
                        return new msfsSdk.MapCullableLocationTextLabel('', 0, w.location, true);
                    }
                    else {
                        return new msfsSdk.MapCullableLocationTextLabel(w.ident, 0, w.location, true, {
                            fontSize: size,
                            fontColor: color,
                            font: 'GreatNiftySymbol-Regular',
                            anchor: new Float64Array([0.5, 1.50]),
                            showBg: true,
                            bgColor: bgColor,
                            bgPadding: msfsSdk.VecNMath.create(4, 1, 1, -2, 1)
                        });
                    }
                }
                throw new Error('Invalid waypoint type');
            };
        }
    }

    /**
     * A layer that displays the NO GPS POSITION banner when GPS integrity is lost.
     */
    class NoGpsPositionLayer extends msfsSdk.MapLayer {
        constructor() {
            super(...arguments);
            this.dataIntegrityModule = this.props.model.getModule(msfsSdk.MapSystemKeys.DataIntegrity);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.dataIntegrityModule.gpsSignalValid.sub(valid => {
                if (valid) {
                    this.el.instance.classList.add('hide-element');
                }
                else {
                    this.el.instance.classList.remove('hide-element');
                }
                this.onMapProjectionChanged(this.props.mapProjection, msfsSdk.MapProjectionChangeType.ProjectedSize);
            }, true);
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            super.onMapProjectionChanged(mapProjection, changeFlags);
            if (msfsSdk.BitFlags.isAll(changeFlags, msfsSdk.MapProjectionChangeType.ProjectedSize)) {
                const size = mapProjection.getProjectedSize();
                this.el.instance.style.width = `${size[0]}px`;
                this.el.instance.style.height = `${size[1]}px`;
                this.el.instance.style.paddingTop = `${(size[1] / 2) - 8}px`;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-no-gps-position', ref: this.el }, "NO GPS POSITION"));
        }
    }

    /**
     * A layer that displays the OBS path.
     */
    class ObsLayer extends msfsSdk.MapLayer {
        constructor() {
            super(...arguments);
            this.lineRenderer = new msfsSdk.GeoCircleLineRenderer();
            this.resampler = new msfsSdk.GeoCircleResampler(Math.PI / 12, 0.25, 8);
            this.streamStack = new msfsSdk.GeoProjectionPathStreamStack(msfsSdk.NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), this.resampler);
            this.canvasLayer = msfsSdk.FSComponent.createRef();
            this.isObsActive = false;
            this.obsCourse = 0;
            this.activePlanIndex = 0;
            this.needsRender = false;
        }
        /** @inheritdoc */
        onAttached() {
            const sub = this.props.bus.getSubscriber();
            this.obsActiveSub = sub.on('gps_obs_active').whenChanged().handle(v => {
                this.isObsActive = v;
                this.needsRender = true;
            });
            this.obsCourseSub = sub.on('gps_obs_value').whenChanged().handle(v => {
                this.obsCourse = v;
                this.needsRender = true;
            });
            this.activePlanSub = sub.on('fplIndexChanged').handle(v => {
                this.activePlanIndex = v.planIndex;
                this.needsRender = true;
            });
            this.canvasLayer.instance.onAttached();
            this.streamStack.setConsumer(this.canvasLayer.instance.display.context);
        }
        /** @inheritdoc */
        onUpdated(time, elapsed) {
            super.onUpdated(time, elapsed);
            this.canvasLayer.instance.onUpdated(time, elapsed);
            this.drawPath();
        }
        /**
         * Draws the OBS path.
         */
        drawPath() {
            var _a, _b, _c;
            const display = this.canvasLayer.instance.tryGetDisplay();
            if (display !== undefined && (display.isInvalid || this.needsRender)) {
                display.clear();
                display.invalidate();
                display.syncWithMapProjection(this.props.mapProjection);
                this.streamStack.setProjection(this.canvasLayer.instance.display.geoProjection);
                const planSubs = this.props.model.getModule(msfsSdk.MapSystemKeys.FlightPlan).getPlanSubjects(this.activePlanIndex);
                const leg = (_a = planSubs.flightPlan.get()) === null || _a === void 0 ? void 0 : _a.tryGetLeg(planSubs.activeLeg.get());
                this.needsRender = false;
                if (!this.isObsActive || leg === undefined || ((_b = leg === null || leg === void 0 ? void 0 : leg.calculated) === null || _b === void 0 ? void 0 : _b.endLat) === undefined || ((_c = leg === null || leg === void 0 ? void 0 : leg.calculated) === null || _c === void 0 ? void 0 : _c.endLon) === undefined) {
                    return;
                }
                const context = display.context;
                const obsFix = ObsLayer.geoPointCache[0].set(leg.calculated.endLat, leg.calculated.endLon);
                const obsLat = obsFix.lat;
                const obsLon = obsFix.lon;
                const obsCourseTrue = msfsSdk.MagVar.magneticToTrue(this.obsCourse, obsLat, obsLon);
                const obsPath = ObsLayer.geoCircleCache[0].setAsGreatCircle(obsFix, obsCourseTrue);
                const start = obsPath.offsetDistanceAlong(obsFix, msfsSdk.UnitType.NMILE.convertTo(-500, msfsSdk.UnitType.GA_RADIAN), ObsLayer.geoPointCache[1]);
                const startLat = start.lat;
                const startLon = start.lon;
                const end = obsPath.offsetDistanceAlong(obsFix, msfsSdk.UnitType.NMILE.convertTo(500, msfsSdk.UnitType.GA_RADIAN), ObsLayer.geoPointCache[1]);
                const endLat = end.lat;
                const endLon = end.lon;
                this.lineRenderer.render(obsPath, startLat, startLon, obsLat, obsLon, context, this.streamStack, 3, 'magenta');
                this.lineRenderer.render(obsPath, obsLat, obsLon, endLat, endLon, context, this.streamStack, 3, 'white');
            }
        }
        /** @inheritdoc */
        onMapProjectionChanged(mapProjection, changeFlags) {
            super.onMapProjectionChanged(mapProjection, changeFlags);
            this.canvasLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
            this.needsRender = true;
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            this.canvasLayer.instance.onVisibilityChanged(isVisible);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.MapCachedCanvasLayer, { useBuffer: true, overdrawFactor: Math.SQRT2, model: this.props.model, mapProjection: this.props.mapProjection, ref: this.canvasLayer }));
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b, _c;
            super.destroy();
            (_a = this.obsActiveSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.obsCourseSub) === null || _b === void 0 ? void 0 : _b.destroy();
            (_c = this.activePlanSub) === null || _c === void 0 ? void 0 : _c.destroy();
        }
    }
    ObsLayer.geoPointCache = [new msfsSdk.GeoPoint(0, 0), new msfsSdk.GeoPoint(0, 0)];
    ObsLayer.geoCircleCache = [new msfsSdk.GeoCircle(new Float64Array(3), 0)];

    /**
     * A map layer that shows the current displayed map range legend.
     */
    class RangeLegendLayer extends msfsSdk.MapLayer {
        constructor() {
            var _a;
            super(...arguments);
            this.declutterSub = (_a = this.props.model.getModule(GNSMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.declutterLevel.map(l => {
                switch (l) {
                    case MapDeclutterLevel.None:
                        return '';
                    case MapDeclutterLevel.One:
                        return '-1';
                    case MapDeclutterLevel.Two:
                        return '-2';
                    case MapDeclutterLevel.Three:
                        return '-3';
                }
            });
            this.overzoomEl = msfsSdk.FSComponent.createRef();
            this.declutterEl = msfsSdk.FSComponent.createRef();
            this.unitType = this.props.model.getModule(GNSMapKeys.Range).nominalRange.map(r => {
                if (r.asUnit(msfsSdk.UnitType.NMILE) < 1) {
                    return msfsSdk.UnitType.FOOT;
                }
                return msfsSdk.UnitType.NMILE;
            });
        }
        /** @inheritdoc */
        onAttached() {
            this.rangeSub = this.props.model.getModule(GNSMapKeys.Range).nominalRange.sub(this.onRangeChanged.bind(this), true);
            const declutterModule = this.props.model.getModule(GNSMapKeys.Declutter);
            if (declutterModule !== undefined) {
                this.declutterEl.instance.classList.remove('hide-element');
            }
        }
        /**
         * A callback called when the map range changes.
         * @param range The range of the map.
         */
        onRangeChanged(range) {
            const rangeNm = range.asUnit(msfsSdk.UnitType.NMILE);
            if (rangeNm < 2) {
                this.overzoomEl.instance.classList.remove('hidden-element');
            }
            else {
                this.overzoomEl.instance.classList.add('hidden-element');
            }
        }
        /** @inheritdoc */
        onDetached() {
            var _a, _b;
            (_a = this.rangeSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.declutterSub) === null || _b === void 0 ? void 0 : _b.destroy();
            this.unitType.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-range-legend' },
                msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'map-range-legend-scale', value: this.props.model.getModule(GNSMapKeys.Range).nominalRange, formatter: (n) => n.toFixed(0), displayUnit: this.unitType }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-range-declutter hide-element', ref: this.declutterEl }, this.declutterSub),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-range-legend-overzoom', ref: this.overzoomEl }, "overzoom")));
        }
    }

    /**
     * A map layer that displays a traffic advisory banner.
     */
    class TrafficBannerLayer extends msfsSdk.MapLayer {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.bannerEl = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAttached() {
            super.onAttached();
            this.taSub = this.props.tcasDataProvider.taIntruders.sub(this.onTrafficAdvisoriesChanged.bind(this));
        }
        /**
         * Handles when the number of TAs changes.
         * @param set The set containing the current TAs.
         */
        onTrafficAdvisoriesChanged(set) {
            if (set.size > 0) {
                this.bannerEl.instance.classList.remove('hide-element');
            }
            else {
                this.bannerEl.instance.classList.add('hide-element');
            }
        }
        /** @inheritdoc */
        onSleep() {
            var _a;
            super.onSleep();
            (_a = this.taSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        /** @inheritdoc */
        onWake() {
            var _a;
            super.onWake();
            this.onTrafficAdvisoriesChanged(this.props.tcasDataProvider.taIntruders.get());
            (_a = this.taSub) === null || _a === void 0 ? void 0 : _a.resume();
        }
        /** @inheritdoc */
        onVisibilityChanged(isVisible) {
            super.onVisibilityChanged(isVisible);
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
            }
            else {
                this.el.instance.classList.add('hide-element');
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-traffic-banner-layer', ref: this.el },
                msfsSdk.FSComponent.buildComponent("span", { class: 'map-traffic-banner hide-element', ref: this.bannerEl }, "TRAFFIC")));
        }
    }

    /**
     * A map module that exposes the current GPS desired track.
     */
    class WaypointBearingModule {
        constructor() {
            /** The current GPS DTK. */
            this.waypointBearing = msfsSdk.Subject.create(undefined);
        }
    }

    /**
     * A map module that manages the map declutter level.
     */
    class MapDeclutterModule {
        constructor() {
            /** The current map declutter level. */
            this.declutterLevel = msfsSdk.Subject.create(MapDeclutterLevel.None);
        }
    }

    /**
     * A class that builds GNS map system maps.
     */
    class GNSMapBuilder {
        /**
         * Creates an arc nav map.
         * @param bus The event bus to use with this map.
         * @param flightPlanner The flight planner to use for flight plan display.
         * @param settingsProvider The GNS system settings provider.
         * @param gnsType The GNS type (430 or 530) that this map will display on.
         * @param instrumentIndex The index of this instrument.
         * @param trafficSystem The GNS traffic system to use to provide traffic data.
         * @param tcasDataProvider The GNS TA data provider to use to provide TA sets.
         * @returns The modified builder.
         */
        static withArcMap(bus, flightPlanner, settingsProvider, gnsType, instrumentIndex, trafficSystem, tcasDataProvider) {
            const builder = msfsSdk.MapSystemBuilder.create(bus)
                .withBing(`${gnsType}_${instrumentIndex}-navmap`)
                .withProjectedSize(msfsSdk.Vec2Math.create(255, 138))
                .withTargetOffset(msfsSdk.Vec2Math.create(0, 60))
                .with(b => GNSMapBuilder.airportRunways(b, gnsType))
                .withModule(GNSMapKeys.Range, () => new GNSMapIndexedRangeModule())
                .withModule(GNSMapKeys.Units, () => new msfsGarminsdk.MapUnitsModule())
                .withModule(GNSMapKeys.WaypointBearing, () => new WaypointBearingModule())
                .withModule(msfsSdk.MapSystemKeys.DataIntegrity, () => new msfsSdk.MapDataIntegrityModule())
                .withModule(GNSMapKeys.Declutter, () => new MapDeclutterModule())
                .withAirspaces(msfsSdk.DefaultLodBoundaryCache.getCache(), msfsGarminsdk.GarminAirspaceShowTypeMap.MAP, MapAirspaceRendering.selectRenderer, MapAirspaceRendering.renderOrder)
                .withNearestWaypoints(MapSystemConfig.configureWaypoints(bus, settingsProvider, gnsType), true)
                .withInit('intersectionFilter', context => {
                context.model.getModule(msfsSdk.MapSystemKeys.NearestWaypoints).intersectionsFilter.set({
                    typeMask: msfsSdk.BitFlags.union(msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.None), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Named), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Unnamed), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Offroute), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.IAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.FAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.RNAV)),
                    showTerminalWaypoints: true
                });
            })
                .withOwnAirplaneIcon(gnsType === 'wt430' ? 22 : 16, OwnshipIconPath, msfsSdk.Vec2Math.create(0.5, 0.5))
                .withOwnAirplaneIconOrientation(msfsSdk.MapOwnAirplaneIconOrientation.TrackUp)
                .withFlightPlan(MapSystemConfig.configureFlightPlan(settingsProvider, gnsType, bus), flightPlanner, 0, true)
                .withFlightPlan(MapSystemConfig.configureFlightPlan(settingsProvider, gnsType, bus), flightPlanner, 1, true)
                .withLayer(GNSMapKeys.Obs, c => msfsSdk.FSComponent.buildComponent(ObsLayer, { bus: bus, model: c.model, mapProjection: c.projection }))
                .with(msfsGarminsdk.GarminMapBuilder.traffic, trafficSystem, GNSTrafficIcons.IconOptions(gnsType), false)
                .withLayer(GNSMapKeys.TrafficBanner, c => msfsSdk.FSComponent.buildComponent(TrafficBannerLayer, { model: c.model, tcasDataProvider: tcasDataProvider, mapProjection: c.projection }))
                .withLayer(GNSMapKeys.RangeLegend, c => msfsSdk.FSComponent.buildComponent(RangeLegendLayer, { model: c.model, mapProjection: c.projection }))
                .withLayer(msfsSdk.MapSystemKeys.DataIntegrity, c => msfsSdk.FSComponent.buildComponent(NoGpsPositionLayer, { model: c.model, mapProjection: c.projection }))
                .withLayer(GNSMapKeys.CompassArc, c => msfsSdk.FSComponent.buildComponent(MapRangeCompassLayer, { bus: bus, bearingTickMajorLength: 7, arcStrokeColor: 'cyan', arcStrokeWidth: 1, bearingTickMinorLength: 7, bearingLabelFont: 'GreatNiftySymbol-Regular', bearingLabelFontSize: 10, bearingLabelOutlineColor: 'black', bearingLabelOutlineWidth: 2, bearingLabelFontColor: 'cyan', model: c.model, mapProjection: c.projection }))
                .withOwnAirplanePropBindings(['position', 'hdgTrue', 'trackTrue', 'isOnGround', 'groundSpeed'], 6)
                .withFollowAirplane()
                .withRotation()
                .withLayerOrder(msfsSdk.MapSystemKeys.OwnAirplaneIcon, 100)
                .withClockUpdate(6);
            const rangeModule = new GNSMapIndexedRangeModule(gnsType === 'wt530' ? this.WT530_RANGE_SIMVAR : this.WT430_RANGE_SIMVAR);
            rangeModule.nominalRanges.set([5, 10, 15, 20, 35, 50, 100, 150, 200].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.NMILE)));
            rangeModule.setNominalRangeIndex(0);
            return builder.withModule(GNSMapKeys.Range, () => rangeModule);
        }
        /**
         * Creates an standard nav map.
         * @param bus The event bus to use with this map.
         * @param flightPlanner The flight planner to use for flight plan display.
         * @param settingsProvider The GNS system settings provider.
         * @param gnsType The GNS type (430 or 530) that this map will display on.
         * @param instrumentIndex The index of this instrument.
         * @param supportDataIntegrity Whether or not to display the NO GPS POSITION display when data integrity has failed.
         * @param trafficSystem The optional GNS traffic system to use to provide traffic data.
         * @param tcasDataProvider The optional GNS TA data provider to use to provide TA sets.
         * @returns The modified builder.
         */
        static withStandardMap(bus, flightPlanner, settingsProvider, gnsType, instrumentIndex, supportDataIntegrity, trafficSystem, tcasDataProvider) {
            const builder = msfsSdk.MapSystemBuilder.create(bus)
                .withBing(`${gnsType}_${instrumentIndex}-navmap`)
                .withTargetOffset(msfsSdk.Vec2Math.create(0, 0))
                .with(b => GNSMapBuilder.airportRunways(b, gnsType))
                .withAirspaces(msfsSdk.DefaultLodBoundaryCache.getCache(), msfsGarminsdk.GarminAirspaceShowTypeMap.MAP, MapAirspaceRendering.selectRenderer, MapAirspaceRendering.renderOrder)
                .withNearestWaypoints(MapSystemConfig.configureWaypoints(bus, settingsProvider, gnsType), true)
                .withInit('intersectionFilter', context => {
                context.model.getModule(msfsSdk.MapSystemKeys.NearestWaypoints).intersectionsFilter.set({
                    typeMask: msfsSdk.BitFlags.union(msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.None), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Named), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Unnamed), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Offroute), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.IAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.FAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.RNAV)),
                    showTerminalWaypoints: true
                });
            })
                .withFlightPlan(MapSystemConfig.configureFlightPlan(settingsProvider, gnsType, bus), flightPlanner, 0, true)
                .withFlightPlan(MapSystemConfig.configureFlightPlan(settingsProvider, gnsType, bus), flightPlanner, 1, true)
                .withLayer(GNSMapKeys.Obs, c => msfsSdk.FSComponent.buildComponent(ObsLayer, { bus: bus, model: c.model, mapProjection: c.projection }))
                .withModule(msfsSdk.MapSystemKeys.DataIntegrity, () => new msfsSdk.MapDataIntegrityModule())
                .withModule(GNSMapKeys.Declutter, () => new MapDeclutterModule());
            if (trafficSystem !== undefined && tcasDataProvider !== undefined) {
                builder.with(msfsGarminsdk.GarminMapBuilder.traffic, trafficSystem, GNSTrafficIcons.IconOptions(gnsType), false)
                    .withLayer(GNSMapKeys.TrafficBanner, c => msfsSdk.FSComponent.buildComponent(TrafficBannerLayer, { model: c.model, tcasDataProvider: tcasDataProvider, mapProjection: c.projection }));
            }
            if (supportDataIntegrity) {
                builder.withLayer(msfsSdk.MapSystemKeys.DataIntegrity, c => msfsSdk.FSComponent.buildComponent(NoGpsPositionLayer, { model: c.model, mapProjection: c.projection }));
            }
            builder.withOwnAirplaneIcon(gnsType === 'wt430' ? 22 : 16, OwnshipIconPath, msfsSdk.Vec2Math.create(0.5, 0.5))
                .withOwnAirplaneIconOrientation(msfsSdk.MapOwnAirplaneIconOrientation.TrackUp)
                .withLayer(GNSMapKeys.RangeLegend, c => msfsSdk.FSComponent.buildComponent(RangeLegendLayer, { model: c.model, mapProjection: c.projection }))
                .withLayer(GNSMapKeys.CompassNorth, c => msfsSdk.FSComponent.buildComponent(CompassNorthLayer, { model: c.model, mapProjection: c.projection }))
                .withOwnAirplanePropBindings(['position', 'hdgTrue', 'trackTrue', 'isOnGround'], 6)
                .withModule(GNSMapKeys.Range, () => new GNSMapIndexedRangeModule())
                .withFollowAirplane()
                .withRotation()
                .withClockUpdate(6);
            const rangeModule = new GNSMapIndexedRangeModule(gnsType === 'wt530' ? this.WT530_RANGE_SIMVAR : this.WT430_RANGE_SIMVAR);
            rangeModule.nominalRanges.set([500, 1000, 1500, 2000, 3500].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.FOOT))
                .concat([1, 2, 3.5, 5, 10, 15, 20, 35, 50, 100, 150, 200].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.NMILE))));
            rangeModule.setNominalRangeIndex(8);
            return builder.withModule(GNSMapKeys.Range, () => rangeModule);
        }
        /**
         * Creates an airport page nav map.
         * @param bus The event bus to use with this map.
         * @param settingsProvider The GNS system settings provider.
         * @param gnsType The GNS type (430 or 530) that this map will display on.
         * @param instrumentIndex The index of this instrument.
         * @returns The modified builder.
         */
        static withAirportMap(bus, settingsProvider, gnsType, instrumentIndex) {
            const builder = msfsSdk.MapSystemBuilder.create(bus)
                .withBing(`${gnsType}_${instrumentIndex}-navmap`)
                .withProjectedSize(msfsSdk.Vec2Math.create(165, gnsType === 'wt530' ? this.WT530_PREVIEW_MAP_HEIGHT : this.WT430_PREVIEW_MAP_HEIGHT))
                .with(b => GNSMapBuilder.airportRunways(b, gnsType))
                .withAirspaces(msfsSdk.DefaultLodBoundaryCache.getCache(), msfsGarminsdk.GarminAirspaceShowTypeMap.MAP, MapAirspaceRendering.selectRenderer, MapAirspaceRendering.renderOrder)
                .withNearestWaypoints(MapSystemConfig.configureWaypoints(bus, settingsProvider, gnsType), true)
                .withInit('intersectionFilter', context => {
                context.model.getModule(msfsSdk.MapSystemKeys.NearestWaypoints).intersectionsFilter.set({
                    typeMask: msfsSdk.BitFlags.union(msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.None), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Named), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Unnamed), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Offroute), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.IAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.FAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.RNAV)),
                    showTerminalWaypoints: true
                });
            })
                .withOwnAirplaneIcon(gnsType === 'wt430' ? 22 : 16, OwnshipIconPath, msfsSdk.Vec2Math.create(0.5, 0.5))
                .withOwnAirplaneIconOrientation(msfsSdk.MapOwnAirplaneIconOrientation.TrackUp)
                .withLayer(GNSMapKeys.RangeLegend, c => msfsSdk.FSComponent.buildComponent(RangeLegendLayer, { model: c.model, mapProjection: c.projection }))
                .withOwnAirplanePropBindings(['position', 'hdgTrue', 'trackTrue', 'isOnGround'], 6)
                .withModule(GNSMapKeys.Range, () => new GNSMapIndexedRangeModule())
                .withModule(msfsSdk.MapSystemKeys.DataIntegrity, () => new msfsSdk.MapDataIntegrityModule())
                .withFollowAirplane()
                .withRotation()
                .withClockUpdate(6);
            const rangeModule = new GNSMapIndexedRangeModule(gnsType === 'wt530' ? this.WT530_RANGE_SIMVAR : this.WT430_RANGE_SIMVAR);
            rangeModule.nominalRanges.set([500, 1000, 1500, 2000, 3500].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.FOOT))
                .concat([1, 2, 3.5, 5, 10, 15, 20, 35, 50, 100, 150, 200].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.NMILE))));
            rangeModule.setNominalRangeIndex(8);
            return builder.withModule(GNSMapKeys.Range, () => rangeModule);
        }
        /**
         * Creates an procedure preview nav map.
         * @param bus The event bus to use with this map.
         * @param settingsProvider The GNS system settings provider.
         * @param gnsType The GNS type (430 or 530) that this map will display on.
         * @param instrumentIndex The index of this instrument.
         * @returns The modified builder.
         */
        static withProcedurePreviewMap(bus, settingsProvider, gnsType, instrumentIndex) {
            const builder = msfsSdk.MapSystemBuilder.create(bus)
                .withBing(`${gnsType}_${instrumentIndex}-navmap`)
                .withProjectedSize(msfsSdk.Vec2Math.create(165, gnsType === 'wt530' ? this.WT530_PREVIEW_MAP_HEIGHT : this.WT430_PREVIEW_MAP_HEIGHT))
                .with(b => GNSMapBuilder.airportRunways(b, gnsType))
                .with(GNSMapBuilder.previewPlan, MapSystemConfig.configureProcedurePreviewPlan(settingsProvider, gnsType), MapSystemConfig.configureTransitionPreviewPlan())
                .withLayer(GNSMapKeys.RangeLegend, c => msfsSdk.FSComponent.buildComponent(RangeLegendLayer, { model: c.model, mapProjection: c.projection }))
                .withModule(GNSMapKeys.Range, () => new GNSMapIndexedRangeModule())
                .withModule(msfsSdk.MapSystemKeys.DataIntegrity, () => new msfsSdk.MapDataIntegrityModule())
                .withRotation()
                .withClockUpdate(6);
            const rangeModule = new GNSMapIndexedRangeModule(gnsType === 'wt530' ? this.WT530_RANGE_SIMVAR : this.WT430_RANGE_SIMVAR);
            rangeModule.nominalRanges.set([500, 1000, 1500, 2000, 3500].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.FOOT))
                .concat([1, 2, 3.5, 5, 10, 15, 20, 35, 50, 100, 150, 200].map(n => new msfsSdk.NumberUnit(n, msfsSdk.UnitType.NMILE))));
            rangeModule.setNominalRangeIndex(8);
            return builder.withModule(GNSMapKeys.Range, () => rangeModule);
        }
        /**
         * Adds a procedure preview plan to the map system.
         * @param builder The map system builder to add the plan to.
         * @param configureProc The procedure flight plan display configuration.
         * @param configureTransitions The transition flight plan display configuration.
         * @returns The modified builder.
         */
        static previewPlan(builder, configureProc, configureTransitions) {
            builder.withModule(msfsSdk.MapSystemKeys.FlightPlan, () => new msfsSdk.MapFlightPlanModule())
                .withModule(msfsSdk.MapSystemKeys.NearestWaypoints, () => new msfsSdk.MapWaypointDisplayModule())
                .withModule(msfsSdk.MapSystemKeys.Airspace, () => new msfsSdk.MapAirspaceModule(msfsGarminsdk.GarminAirspaceShowTypeMap.MAP))
                .withTargetControlModerator()
                .withContext(msfsSdk.MapSystemKeys.IconFactory, () => new msfsSdk.MapSystemIconFactory())
                .withContext(msfsSdk.MapSystemKeys.LabelFactory, () => new msfsSdk.MapSystemLabelFactory())
                .withWaypoints()
                .withContext(msfsSdk.MapSystemKeys.FlightPathRenderer, () => new msfsSdk.MapSystemPlanRenderer(1))
                .withLayer(`${msfsSdk.MapSystemKeys.FlightPlan}_0`, c => msfsSdk.FSComponent.buildComponent(msfsSdk.MapSystemFlightPlanLayer, { bus: c.bus, waypointRenderer: c.waypointRenderer, iconFactory: c.iconFactory, labelFactory: c.labelFactory, flightPathRenderer: c.flightPathRenderer, planIndex: 0, model: c.model, mapProjection: c.projection }))
                .withLayer(`${msfsSdk.MapSystemKeys.FlightPlan}_1`, c => msfsSdk.FSComponent.buildComponent(msfsSdk.MapSystemFlightPlanLayer, { bus: c.bus, waypointRenderer: c.waypointRenderer, iconFactory: c.iconFactory, labelFactory: c.labelFactory, flightPathRenderer: c.flightPathRenderer, planIndex: 1, model: c.model, mapProjection: c.projection }))
                .withTextLayer(false)
                .withInit(msfsSdk.MapSystemKeys.FlightPlan, c => {
                const procBuilder = new msfsSdk.FlightPlanDisplayBuilder(c.iconFactory, c.labelFactory, c.waypointRenderer, c.flightPathRenderer, 0);
                const transitionBuilder = new msfsSdk.FlightPlanDisplayBuilder(c.iconFactory, c.labelFactory, c.waypointRenderer, c.flightPathRenderer, 1);
                c[msfsSdk.MapSystemKeys.WaypointRenderer].insertRenderRole(msfsSdk.MapSystemWaypointRoles.FlightPlan, msfsSdk.MapSystemWaypointRoles.Normal, undefined, `${msfsSdk.MapSystemWaypointRoles.FlightPlan}_0`);
                c[msfsSdk.MapSystemKeys.WaypointRenderer].insertRenderRole(msfsSdk.MapSystemWaypointRoles.FlightPlan, msfsSdk.MapSystemWaypointRoles.Normal, undefined, `${msfsSdk.MapSystemWaypointRoles.FlightPlan}_1`);
                configureProc(procBuilder);
                configureTransitions(transitionBuilder);
            });
            return builder;
        }
        /**
         * Adds airport runway vector display to the map.
         *
         * Adds the following...
         *
         * Modules:
         * * `[GNSMapKeys.Runways]: AirportRunwayDisplayModule`
         *
         * Layers:
         * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
         * * `[GNSMapKeys.Runways]: AirportRunwayLayer`
         *
         * Context Properties:
         * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
         * * `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer`
         *
         * @param builder The builder to use.
         * @param gnsType The type of GNS unit to display the runways on.
         * @returns The modified builder.
         */
        static airportRunways(builder, gnsType) {
            return builder
                .withTextLayer(true)
                .withWaypoints()
                .withModule(GNSMapKeys.Runways, () => new AirportRunwayDisplayModule())
                /* eslint-disable jsdoc/require-jsdoc */
                .withLayer(GNSMapKeys.Runways, ctx => msfsSdk.FSComponent.buildComponent(AirportRunwayLayer, { waypointRenderer: ctx[msfsSdk.MapSystemKeys.WaypointRenderer], model: ctx.model, mapProjection: ctx.projection, gnsType: gnsType }));
        }
    }
    GNSMapBuilder.WT530_PREVIEW_MAP_HEIGHT = 188;
    GNSMapBuilder.WT430_PREVIEW_MAP_HEIGHT = 144;
    GNSMapBuilder.WT530_RANGE_SIMVAR = 'L:AS530_Default_MapZoomRange';
    GNSMapBuilder.WT430_RANGE_SIMVAR = 'L:AS430_MapZoomRange';

    /**
     * A class that holds the GNS map terrain color definitions.
     */
    class TerrainColors {
    }
    TerrainColors.Relative = {
        colors: msfsSdk.BingComponent.createEarthColorsArray('#0000ff', [
            {
                elev: 0,
                color: '#ff0000'
            },
            {
                elev: 99,
                color: '#ff0000'
            },
            {
                elev: 100,
                color: '#ffff00'
            },
            {
                elev: 999,
                color: '#ffff00'
            },
            {
                elev: 1000,
                color: '#000000'
            },
        ], 0, 1000, 11),
        elevationRange: msfsSdk.Vec2Math.create(0, 1000)
    };
    TerrainColors.None = {
        colors: msfsSdk.BingComponent.createEarthColorsArray('#0000ff', [
            {
                elev: 0,
                color: '#000000'
            },
        ], 0, 1000, 1),
        elevationRange: msfsSdk.Vec2Math.create(0, 30000)
    };
    /**
     * A controller that handles maps on the GNS units.
     */
    class GNSMapController extends msfsSdk.MapSystemController {
        /**
         * Creates an instance of the GNSMapController.
         * @param context The map system context to use with this controller.
         * @param settingProvider The GNS settings provider to use with this controller.
         * @param flightPlanner The GNS FMS flight planner.
         * @param forceTrackUp Whether or not the map is forced into track up mode.
         */
        constructor(context, settingProvider, flightPlanner, forceTrackUp) {
            super(context);
            this.settingProvider = settingProvider;
            this.flightPlanner = flightPlanner;
            this.forceTrackUp = forceTrackUp;
            this.rangeObject = { range: msfsSdk.UnitType.NMILE.createNumber(5).asUnit(msfsSdk.UnitType.GA_RADIAN) };
            this.airportFocusTargetConsumer = {
                priority: 100,
                onAcquired: () => this.onAirportFocusClaimed(),
                onCeded: () => { }
            };
            this.focusedRunwayIndex = -1;
            this.nexradEnabled = false;
        }
        /** @inheritdoc */
        onAfterMapRender() {
            var _a;
            const rangeModule = this.context.model.getModule(GNSMapKeys.Range);
            const rotationModule = this.context.model.getModule(msfsSdk.MapSystemKeys.Rotation);
            this.handleRangeChange(rangeModule.nominalRange.get());
            rangeModule.nominalRange.sub(this.handleRangeChange.bind(this));
            if (this.forceTrackUp) {
                rotationModule.rotationType.set(msfsSdk.MapRotation.TrackUp);
            }
            else {
                this.settingProvider.map.getSetting('map_orientation').sub(r => rotationModule.rotationType.set(r), true);
            }
            this.context.bus.getSubscriber().on('lnavdata_waypoint_bearing_true').whenChanged().handle(brg => this.onWaypointBearingChanged(brg));
            this.context.bus.getSubscriber().on('fplActiveLegChange')
                .handle(() => { var _a; return this.onWaypointBearingChanged((_a = this.context.model.getModule(GNSMapKeys.WaypointBearing)) === null || _a === void 0 ? void 0 : _a.waypointBearing.get()); });
            this.settingProvider.map.getAllSettings().forEach(s => s.sub(() => this.syncElementVisibilities(rangeModule.nominalRange.get()), true));
            (_a = this.context.model.getModule(GNSMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.declutterLevel.sub(() => this.syncElementVisibilities(rangeModule.nominalRange.get()), true);
            rotationModule.rotationType.sub(this.onRotationChanged.bind(this), true);
            this.context.bus.getSubscriber().on('gps_system_state_changed_1').handle(state => {
                this.context.model.getModule(msfsSdk.MapSystemKeys.DataIntegrity).gpsSignalValid.set(state === msfsSdk.GPSSystemState.SolutionAcquired || state === msfsSdk.GPSSystemState.DiffSolutionAcquired);
            });
            this.context.model.getModule(msfsSdk.MapSystemKeys.DataIntegrity).gpsSignalValid.sub(valid => {
                var _a, _b;
                if (valid) {
                    (_a = this.context.model.getModule(msfsSdk.MapSystemKeys.OwnAirplaneIcon)) === null || _a === void 0 ? void 0 : _a.show.set(true);
                    if (this.forceTrackUp) {
                        rotationModule.rotationType.set(msfsSdk.MapRotation.TrackUp);
                    }
                    else {
                        rotationModule.rotationType.set(this.settingProvider.map.getSetting('map_orientation').get());
                    }
                }
                else {
                    (_b = this.context.model.getModule(msfsSdk.MapSystemKeys.OwnAirplaneIcon)) === null || _b === void 0 ? void 0 : _b.show.set(false);
                    rotationModule.rotationType.set(msfsSdk.MapRotation.NorthUp);
                }
            }, true);
            //Kick the plan calculated event when the LNAV transition mode changes in order to force
            //a flight plan redraw (needed for switching draw styles during holds)
            this.context.bus.getSubscriber().on('lnav_transition_mode').whenChanged().handle(() => {
                this.context.model.getModule('flightPlan').getPlanSubjects(0).planCalculated.notify(undefined);
            });
            this.context.bus.getSubscriber().on('gps_obs_active').whenChanged().handle(this.onObsActiveChanged.bind(this));
        }
        /**
         * Handles when the active waypoint bearing changes.
         * @param brg The new active waypoint bearing.
         */
        onWaypointBearingChanged(brg) {
            const dtkModule = this.context.model.getModule(GNSMapKeys.WaypointBearing);
            if (dtkModule !== undefined) {
                if (this.flightPlanner.hasActiveFlightPlan() && this.flightPlanner.getActiveFlightPlan().length > 1) {
                    dtkModule.waypointBearing.set(brg);
                }
                else {
                    dtkModule.waypointBearing.set(undefined);
                }
            }
        }
        /**
         * Handles when the map rotation changes.
         * @param type The type of rotation that was changed to.
         */
        onRotationChanged(type) {
            if (!this.forceTrackUp) {
                if (type === msfsSdk.MapRotation.NorthUp) {
                    this.context.projection.setQueued({ targetProjectedOffset: new Float64Array([0, 0]) });
                }
                else {
                    this.context.projection.setQueued({ targetProjectedOffset: new Float64Array([0, 34]) });
                }
            }
        }
        /**
         * Sets the map range.
         * @param range The range to set the map projection to.
         */
        handleRangeChange(range) {
            this.rangeObject.range = range.asUnit(msfsSdk.UnitType.GA_RADIAN) * 1.075;
            this.context.projection.setQueued(this.rangeObject);
            this.syncElementVisibilities(range);
        }
        /**
         * Increases the map range.
         */
        increaseRange() {
            const rangeModule = this.context.model.getModule(GNSMapKeys.Range);
            rangeModule.setNominalRangeIndex(msfsSdk.NavMath.clamp(rangeModule.nominalRangeIndex.get() + 1, 0, rangeModule.nominalRanges.get().length - 1));
        }
        /**
         * Decreases the map range.
         */
        decreaseRange() {
            const rangeModule = this.context.model.getModule(GNSMapKeys.Range);
            rangeModule.setNominalRangeIndex(msfsSdk.NavMath.clamp(rangeModule.nominalRangeIndex.get() - 1, 0, rangeModule.nominalRanges.get().length - 1));
        }
        /**
         * Changes the current provided setting's declutter level.
         * @param setting The declutter user setting to change.
         */
        changeDeclutter(setting) {
            const declutterLevel = setting.get();
            switch (declutterLevel) {
                case MapDeclutterLevel.None:
                    setting.set(MapDeclutterLevel.One);
                    break;
                case MapDeclutterLevel.One:
                    setting.set(MapDeclutterLevel.Two);
                    break;
                case MapDeclutterLevel.Two:
                    setting.set(MapDeclutterLevel.Three);
                    break;
                case MapDeclutterLevel.Three:
                    setting.set(MapDeclutterLevel.None);
                    break;
            }
        }
        /**
         * Targets the map on the airport and automatically sets the range so the selected
         * runway at the runway index is within the map range.
         * @param airport The airport to focus on.
         * @param runwayIndex The index of the runway to focus on.
         */
        focusAirport(airport, runwayIndex) {
            this.focusedAirport = airport;
            this.focusedRunwayIndex = runwayIndex;
            const runwaysModule = this.context.model.getModule(GNSMapKeys.Runways);
            runwaysModule.focusAirport.set(this.focusedAirport);
            this.context.targetControlModerator.forfeit(this.airportFocusTargetConsumer);
            this.context.targetControlModerator.claim(this.airportFocusTargetConsumer);
        }
        /**
         * Unfocuses from an airport and runway, and resumes own aircraft following.
         */
        unfocusAirport() {
            this.focusedAirport = undefined;
            this.focusedRunwayIndex = -1;
            const runwaysModule = this.context.model.getModule(GNSMapKeys.Runways);
            runwaysModule.focusAirport.set(undefined);
            this.context.targetControlModerator.forfeit(this.airportFocusTargetConsumer);
        }
        /**
         * Overrides the default map rotation settings for the map.
         * @param rotation The rotation to set.
         */
        overrideRotation(rotation) {
            this.context.model.getModule(msfsSdk.MapSystemKeys.Rotation).rotationType.set(rotation);
        }
        /**
         * Sets whether or not NEXRAD should be visible on the map.
         * @param isVisible Whether or not NEXRAD is visible.
         */
        setNexradVisible(isVisible) {
            this.nexradEnabled = isVisible;
            const rangeModule = this.context.model.getModule(GNSMapKeys.Range);
            this.syncNexradVisibility(rangeModule.nominalRange.get());
        }
        /**
         * Sets whether or not the terrain display is enabled.
         * @param enabled Whether or not terrain display is enabled.
         */
        setTerrainEnabled(enabled) {
            const terrainModule = this.context.model.getModule(msfsSdk.MapSystemKeys.TerrainColors);
            if (enabled) {
                terrainModule.reference.set(EBingReference.PLANE);
                terrainModule.colors.set(TerrainColors.Relative.colors);
                terrainModule.colorsElevationRange.set(TerrainColors.Relative.elevationRange);
            }
            else {
                terrainModule.reference.set(EBingReference.SEA);
                terrainModule.colors.set(TerrainColors.None.colors);
                terrainModule.colorsElevationRange.set(TerrainColors.None.elevationRange);
            }
        }
        /**
         * A callback called when airport focus is claimed.
         */
        onAirportFocusClaimed() {
            if (this.focusedAirport !== undefined) {
                const runwaysModule = this.context.model.getModule(GNSMapKeys.Runways);
                runwaysModule.focusAirport.set(this.focusedAirport);
                this.context.projection.setQueued({ target: this.focusedAirport.location.get() });
                const rotationModule = this.context.model.getModule(msfsSdk.MapSystemKeys.Rotation);
                rotationModule.rotationType.set(msfsSdk.MapRotation.NorthUp);
                const runway = this.focusedAirport.facility.get().runways[this.focusedRunwayIndex];
                let distance = 0;
                let center = this.focusedAirport.location.get();
                if (runway === undefined) {
                    distance = this.getMaxRunwayDistanceFromPoint(this.focusedAirport.facility.get().runways, this.focusedAirport.location.get());
                }
                else {
                    center = new msfsSdk.GeoPoint(runway.latitude, runway.longitude);
                    distance = this.getMaxRunwayDistanceFromPoint([runway], center);
                }
                const minRange = distance * 2.33;
                const rangeModule = this.context.model.getModule(GNSMapKeys.Range);
                const ranges = rangeModule.nominalRanges.get();
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i].asUnit(msfsSdk.UnitType.GA_RADIAN);
                    if (range > minRange) {
                        rangeModule.setNominalRangeIndex(i);
                        break;
                    }
                }
                this.context.projection.setQueued({ target: center });
            }
        }
        /**
         * Gets the maximum runway extend distance from a supplied point.
         * @param runways The runways to get distances for.
         * @param point The point to reference against.
         * @returns The maximum runway extent distance, in GA radians.
         */
        getMaxRunwayDistanceFromPoint(runways, point) {
            const primaryEnd = new msfsSdk.GeoPoint(0, 0);
            const secondaryEnd = new msfsSdk.GeoPoint(0, 0);
            let distance = 0;
            for (let i = 0; i < runways.length; i++) {
                const runway = runways[i];
                point.offset(runway.direction, msfsSdk.UnitType.METER.convertTo(runway.length / 2, msfsSdk.UnitType.GA_RADIAN), primaryEnd);
                point.offset(msfsSdk.NavMath.normalizeHeading(runway.direction + 180), msfsSdk.UnitType.METER.convertTo(runway.length / 2, msfsSdk.UnitType.GA_RADIAN), secondaryEnd);
                distance = Math.max(distance, point.distance(primaryEnd), point.distance(secondaryEnd));
            }
            return distance;
        }
        /**
         * Synchronizes all map element visibilities when the map range changes.
         * @param range The new map range.
         */
        syncElementVisibilities(range) {
            this.syncWaypointVisibilities(range);
            this.syncAirspaceVisibilities(range);
            this.syncRunwayVisibilities(range);
            this.syncNexradVisibility(range);
            this.syncTrafficVisibility(range);
        }
        /**
         * Syncs the vectorized runway display visibilities when the map range changes.
         * @param range The new map range.
         */
        syncRunwayVisibilities(range) {
            var _a;
            const runwaysModule = this.context.model.getModule(GNSMapKeys.Runways);
            const declutterLevel = (_a = this.context.model.getModule(GNSMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.declutterLevel.get();
            const removeRunways = declutterLevel === MapDeclutterLevel.Three;
            const shouldDisplayRunways = range.compare(msfsSdk.UnitType.NMILE.createNumber(10)) <= 0 && !removeRunways;
            const shouldDisplayRunwayLabels = range.compare(msfsSdk.UnitType.NMILE.createNumber(5)) <= 0 && !removeRunways;
            runwaysModule.displayRunways.set(shouldDisplayRunways);
            runwaysModule.displayLabels.set(shouldDisplayRunwayLabels);
        }
        /**
         * Syncs the airspace display visibilities when the map range changes.
         * @param range The new map range.
         */
        syncAirspaceVisibilities(range) {
            var _a;
            const airspaceModule = this.context.model.getModule(msfsSdk.MapSystemKeys.Airspace);
            let removeNormAirspace = false;
            let removeRestricted = false;
            const declutterLevel = (_a = this.context.model.getModule(GNSMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.declutterLevel.get();
            if (declutterLevel === MapDeclutterLevel.Two) {
                removeNormAirspace = true;
            }
            else if (declutterLevel === MapDeclutterLevel.Three) {
                removeNormAirspace = true;
                removeRestricted = true;
            }
            const shouldDisplayClassB = range.compare(this.getSettingDistance('airspace_classb_range')) <= 0 && !removeNormAirspace;
            const shouldDisplayClassC = range.compare(this.getSettingDistance('airspace_classc_range')) <= 0 && !removeNormAirspace;
            const shouldDisplayClassD = range.compare(this.getSettingDistance('airspace_classd_range')) <= 0 && !removeNormAirspace;
            const shouldDisplayMoa = range.compare(this.getSettingDistance('airspace_moa_range')) <= 0 && !removeNormAirspace;
            const shouldDisplayRestriced = range.compare(this.getSettingDistance('airspace_restricted_range')) <= 0 && !removeRestricted;
            const shouldDisplayOther = range.compare(this.getSettingDistance('airspace_other_range')) <= 0;
            airspaceModule.show.ClassB.set(shouldDisplayClassB);
            airspaceModule.show.ClassC.set(shouldDisplayClassC);
            airspaceModule.show.ClassD.set(shouldDisplayClassD);
            airspaceModule.show.MOA.set(shouldDisplayMoa);
            airspaceModule.show.Other.set(shouldDisplayOther);
            airspaceModule.show.Restricted.set(shouldDisplayRestriced);
        }
        /**
         * Syncs the waypoint display visibilities when the map range changes.
         * @param range The new map range.
         */
        syncWaypointVisibilities(range) {
            var _a;
            const waypointModule = this.context.model.getModule(msfsSdk.MapSystemKeys.NearestWaypoints);
            let removeLevelTwo = false;
            let removeAll = false;
            const declutterLevel = (_a = this.context.model.getModule('declutter')) === null || _a === void 0 ? void 0 : _a.declutterLevel.get();
            if (declutterLevel === MapDeclutterLevel.Two) {
                removeLevelTwo = true;
            }
            else if (declutterLevel === MapDeclutterLevel.Three) {
                removeLevelTwo = true;
                removeAll = true;
            }
            const shouldDisplayInt = range.compare(this.getSettingDistance('wpt_int_range')) <= 0 && !removeLevelTwo;
            waypointModule.showIntersections.set(() => shouldDisplayInt);
            waypointModule.numIntersections.set(250);
            const shouldDisplayNdb = range.compare(this.getSettingDistance('wpt_ndb_range')) <= 0 && !removeLevelTwo;
            waypointModule.showNdbs.set(() => shouldDisplayNdb);
            const shouldDisplayVor = range.compare(this.getSettingDistance('wpt_vor_range')) <= 0 && !removeAll;
            waypointModule.showVors.set(() => shouldDisplayVor);
            const shouldDisplayLargeApt = range.compare(this.getSettingDistance('wpt_large_apt_range')) <= 0 && !removeAll;
            const shouldDisplayMediumApt = range.compare(this.getSettingDistance('wpt_medium_apt_range')) <= 0 && !removeAll;
            const shouldDisplaySmallApt = range.compare(this.getSettingDistance('wpt_small_apt_range')) <= 0 && !removeAll;
            waypointModule.showAirports.set(f => {
                const airport = f;
                switch (airport.size) {
                    case msfsGarminsdk.AirportSize.Small:
                        return shouldDisplaySmallApt;
                    case msfsGarminsdk.AirportSize.Medium:
                        return shouldDisplayMediumApt;
                    case msfsGarminsdk.AirportSize.Large:
                        return shouldDisplayLargeApt;
                }
            });
        }
        /**
         * Syncs visibility of the NEXRAD weather display.
         * @param range The new map range.
         */
        syncNexradVisibility(range) {
            const weatherModule = this.context.model.getModule(msfsSdk.MapSystemKeys.Weather);
            if (this.nexradEnabled && range.compare(msfsSdk.UnitType.NMILE.createNumber(10)) >= 0) {
                weatherModule.weatherRadarMode.set(EWeatherRadar.TOPVIEW);
                weatherModule.isEnabled.set(true);
            }
            else {
                weatherModule.isEnabled.set(false);
            }
        }
        /**
         * Syncs visibility of the traffic elements.
         * @param range The new map range.
         */
        syncTrafficVisibility(range) {
            const garminTrafficModule = this.context.model.getModule(msfsGarminsdk.GarminMapKeys.Traffic);
            const trafficModule = this.context.model.getModule(msfsSdk.MapSystemKeys.Traffic);
            if (garminTrafficModule !== undefined && trafficModule !== undefined) {
                garminTrafficModule.altitudeRestrictionMode.set(msfsGarminsdk.MapTrafficAltitudeRestrictionMode.Unrestricted);
                garminTrafficModule.motionVectorMode.set(msfsGarminsdk.MapTrafficMotionVectorMode.Absolute);
                const trafficModeSetting = this.settingProvider.map.getSetting('map_traffic_mode');
                switch (trafficModeSetting.get()) {
                    case MapTrafficMode.All:
                        trafficModule.alertLevelVisibility.set(msfsSdk.MapTrafficAlertLevelVisibility.All);
                        break;
                    case MapTrafficMode.TAAndProximity:
                        trafficModule.alertLevelVisibility.set(msfsSdk.MapTrafficAlertLevelVisibility.ProximityAdvisory | msfsSdk.MapTrafficAlertLevelVisibility.TrafficAdvisory);
                        break;
                    case MapTrafficMode.TAOnly:
                        trafficModule.alertLevelVisibility.set(msfsSdk.MapTrafficAlertLevelVisibility.TrafficAdvisory);
                        break;
                }
                const showTraffic = range.compare(this.getSettingDistance('map_traffic_symbol_range')) <= 0;
                const showTrafficLabels = range.compare(this.getSettingDistance('map_traffic_label_range')) <= 0;
                garminTrafficModule.show.set(showTraffic);
                garminTrafficModule.showIntruderLabel.set(showTrafficLabels);
            }
        }
        /**
         * Gets the distance unit from a map setting key.
         * @param name The name of the map settin key.
         * @returns The setting distance unit.
         * @throws An error if the setting could not be converted to a distance unit.
         */
        getSettingDistance(name) {
            const value = this.settingProvider.map.getSetting(name).get();
            const range = MapSettingsRangesMapNM.get(value);
            if (range === undefined) {
                throw new Error(`Range enum ${value} could not be converted into a valid range.`);
            }
            return range;
        }
        /**
         * Handles when OBS becomes active or inactive.
         * @param isActive Whether or not OBS is active.
         */
        onObsActiveChanged(isActive) {
            var _a, _b, _c;
            (_a = this.context.getLayer('flightPlan0')) === null || _a === void 0 ? void 0 : _a.setVisible(!isActive);
            (_b = this.context.getLayer('flightPlan1')) === null || _b === void 0 ? void 0 : _b.setVisible(!isActive);
            (_c = this.context.getLayer(GNSMapKeys.Obs)) === null || _c === void 0 ? void 0 : _c.setVisible(isActive);
        }
        /** @inheritdoc */
        onWake() {
            this.context.model.getModule(GNSMapKeys.Range).updateMapRangeSimvar();
        }
    }

    /**
     * A control that displays a map page data field.
     */
    class MapPageDataField extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.fieldEl = msfsSdk.FSComponent.createRef();
            this.labelEl = msfsSdk.FSComponent.createRef();
            this.labelText = msfsSdk.Subject.create('');
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.fieldTypeSub = msfsSdk.SubscribableUtils.toSubscribable(this.props.type, true).sub(this.onFieldTypeChanged.bind(this), true);
        }
        /**
         * A handler called when the data field type has changed.
         * @param type The type that the field has been changed to.
         */
        onFieldTypeChanged(type) {
            this.labelText.set(type);
        }
        /**
         * Updates the field.
         */
        update() {
            var _a;
            (_a = this.fieldEl.getOrDefault()) === null || _a === void 0 ? void 0 : _a.update();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            (_a = this.fieldEl.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.fieldTypeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
        /** @inheritdoc */
        onFocused() {
            this.labelEl.instance.classList.add('selected-cyan');
        }
        /** @inheritdoc */
        onBlurred() {
            this.labelEl.instance.classList.remove('selected-cyan');
        }
        /** @inheritdoc */
        onRightInnerInc() {
            return this.handleInnerKnob();
        }
        /** @inheritdoc */
        onRightInnerDec() {
            return this.handleInnerKnob();
        }
        /** @inheritdoc */
        onEnt() {
            this.scroll('forward');
            return true;
        }
        /**
         * Handles the inner knob being turned.
         * @returns True if handled, false otherwise.
         */
        handleInnerKnob() {
            if (this.props.type.isSubscribable) {
                // FIXME this can probably be optimized (FieldTypeMenu ctor re-creates all the action callbacks)
                ViewService.menu(new FieldTypeMenu(this.props.context.fieldTypeMenuEntries, this.props.type, () => {
                    ViewService.back();
                    this.scroll('forward');
                }));
                return true;
            }
            return false;
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `map-data-field ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-data-field-label' },
                    msfsSdk.FSComponent.buildComponent("span", { ref: this.labelEl }, this.labelText)),
                msfsSdk.FSComponent.buildComponent(GNSDataField, { class: 'map-data-field-field', context: this.props.context, type: this.props.type, ref: this.fieldEl })));
        }
    }

    /**
     * WT5330 CDI
     */
    class WT530Cdi extends ArcCdi {
        constructor() {
            super(...arguments);
            this.cdiWidth = 134;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'arc-cdi-wt530' },
                msfsSdk.FSComponent.buildComponent("svg", { width: '144px', height: '24px', xmlns: "http://www.w3.org/2000/svg" },
                    msfsSdk.FSComponent.buildComponent("rect", { x: '0px', y: '0px', width: '144px', height: '24px', stroke: 'cyan', "stroke-width": '2px' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '18px', y: '10px', width: '4px', height: '4px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '44px', y: '10px', width: '4px', height: '4px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '96px', y: '10px', width: '4px', height: '4px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("rect", { x: '122px', y: '10px', width: '4px', height: '4px', fill: 'cyan' }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 60 14 l 12 -10 l 12 10 z', fill: '#0f0', ref: this.toFlag }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 60 10 l 12 10 l 12 -10 z', fill: '#0f0', ref: this.fromFlag }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 122 10 l 4 0 l 0 -4 l 12 6 l -12 6 l 0 -4 l -4 0 z', fill: '#0f0', ref: this.rightArrow }),
                    msfsSdk.FSComponent.buildComponent("path", { d: 'M 22 10 l -4 0 l 0 -4 l -12 6 l 12 6 l 0 -4 l 4 0 z', fill: '#0f0', ref: this.leftArrow }),
                    msfsSdk.FSComponent.buildComponent("rect", { ref: this.needle, x: '5px', y: '2px', width: '6px', height: '20px', stroke: '#0f0', "stroke-width": '2px', fill: 'transparent' })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'arc-cdi-xtk-label-left', ref: this.xtkLabelLeft }, this.xtkLabel),
                msfsSdk.FSComponent.buildComponent("div", { class: 'arc-cdi-xtk-label-right', ref: this.xtkLabelRight }, this.xtkLabel)));
        }
    }

    /**
     * A component that displays the GNS arc/nav main map.
     */
    class ArcNavMap extends Page {
        constructor() {
            super(...arguments);
            this.fromWaypoint = msfsSdk.FSComponent.createRef();
            this.toWaypoint = msfsSdk.FSComponent.createRef();
            this.legIcon = msfsSdk.FSComponent.createRef();
            this.rootControl = msfsSdk.FSComponent.createRef();
            this.gpsValidity = msfsSdk.Subject.create(msfsGarminsdk.NavDataFieldGpsValidity.Invalid);
            this.ArcMap = GNSMapBuilder
                .withArcMap(this.props.bus, this.props.fms.flightPlanner, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex, this.props.trafficSystem, this.props.tcasDataProvider)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.fms.flightPlanner, true))
                .build('arc-map-container');
            this.fieldContext = {
                modelFactory: new msfsGarminsdk.DefaultNavDataBarFieldModelFactory(this.props.bus, this.props.fms, this.gpsValidity),
                renderer: new GNSDataFieldRenderer(this.props.settingsProvider.units, this.props.settingsProvider.time),
                fieldTypeMenuEntries: [
                    { label: 'BRG - Bearing', disabled: false, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'DIS - Distance', disabled: false, type: msfsGarminsdk.NavDataFieldType.DistanceToWaypoint },
                    { label: 'DTK - Desired Track', disabled: false, type: msfsGarminsdk.NavDataFieldType.DesiredTrack },
                    { label: 'ESA - Enrte Safe Alt', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'ETA - Est Time Arvl', disabled: false, type: msfsGarminsdk.NavDataFieldType.TimeOfWaypointArrival },
                    { label: 'ETE - Est Time Enrte', disabled: false, type: msfsGarminsdk.NavDataFieldType.TimeToWaypoint },
                    { label: 'FLOW - Total Fuel Flow', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'GS - Ground Speed', disabled: false, type: msfsGarminsdk.NavDataFieldType.GroundSpeed },
                    { label: 'MSA - Min Safe Alt', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'TKE - Track Ang Err', disabled: false, type: msfsGarminsdk.NavDataFieldType.TrackAngleError },
                    { label: 'TRK - Track', disabled: false, type: msfsGarminsdk.NavDataFieldType.GroundTrack },
                    { label: 'VSR - Vert Spd Reqd', disabled: false, type: msfsGarminsdk.NavDataFieldType.VerticalSpeedRequired },
                    { label: 'XTK - Cross Track Err', disabled: false, type: msfsGarminsdk.NavDataFieldType.CrossTrack },
                ],
            };
            this.trkField = msfsSdk.FSComponent.createRef();
            this.fields = [
                msfsSdk.FSComponent.createRef(), msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(), msfsSdk.FSComponent.createRef()
            ];
            this.clockSub = this.props.bus.getSubscriber().on('realTime')
                .atFrequency(4).handle(() => {
                var _a, _b;
                for (let i = 0; i < this.fields.length; i++) {
                    (_a = this.fields[i].getOrDefault()) === null || _a === void 0 ? void 0 : _a.update();
                }
                (_b = this.trkField.getOrDefault()) === null || _b === void 0 ? void 0 : _b.update();
            });
            this.pageMenu = new ArcNavMapPageMenu(this.props.settingsProvider);
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.ArcMap.ref.instance.sleep();
            this.props.bus.getSubscriber().on('fplActiveLegChange').handle(this.onActiveLegChanged.bind(this));
            this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
            this.trkField.instance.setDisabled(true);
            this.toWaypoint.instance.setDisabled(true);
            this.fromWaypoint.instance.setDisabled(true);
            this.pageMenu.onRestoreDefaults = () => {
                this.props.settingsProvider.arcMapFields.getAllSettings().forEach(v => v.resetToDefault());
                ViewService.back();
            };
            this.pageMenu.onChangeFieldsSelected = () => {
                ViewService.back();
                this.rootControl.instance.focus(msfsSdk.FocusPosition.First);
            };
            this.props.settingsProvider.map.getSetting('map_arc_nexrad_enabled').sub(v => {
                this.ArcMap.context.getController(GNSMapKeys.Controller).setNexradVisible(v);
            }, true);
            this.props.settingsProvider.map.getSetting('map_arc_declutter_level').sub(v => {
                var _a;
                (_a = this.ArcMap.context.model.getModule(GNSMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.declutterLevel.set(v);
            }, true);
            this.props.bus.getSubscriber().on('gps_system_state_changed_1').handle(state => {
                const valid = state === msfsSdk.GPSSystemState.SolutionAcquired || state === msfsSdk.GPSSystemState.DiffSolutionAcquired;
                this.gpsValidity.set(valid ? msfsGarminsdk.NavDataFieldGpsValidity.Valid : msfsGarminsdk.NavDataFieldGpsValidity.Invalid);
            });
        }
        /**
         * Handles when the active flight plan leg changes.
         * @param data The active flight plan leg change event.
         */
        onActiveLegChanged(data) {
            if (data.planIndex !== this.props.fms.flightPlanner.activePlanIndex) {
                return;
            }
            if (this.props.fms.hasPrimaryFlightPlan() && data.type === msfsSdk.ActiveLegType.Lateral) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                const toLeg = plan.tryGetLeg(data.segmentIndex, data.legIndex);
                this.toWaypoint.instance.setLeg(toLeg);
                if (toLeg !== null) {
                    const toLegIndex = plan.getLegIndexFromLeg(toLeg);
                    const fromLeg = plan.tryGetLeg(toLegIndex - 1);
                    const directToState = this.props.fms.getDirectToState();
                    this.fromWaypoint.instance.setLeg(fromLeg);
                    if (fromLeg === null || directToState === msfsGarminsdk.DirectToState.TOEXISTING || directToState === msfsGarminsdk.DirectToState.TORANDOM) {
                        this.legIcon.instance.updateLegIcon(true, true, toLeg.leg.type, toLeg.leg.turnDirection);
                    }
                    else {
                        this.legIcon.instance.updateLegIcon(true, false, toLeg.leg.type, toLeg.leg.turnDirection);
                    }
                }
                else {
                    this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
                }
            }
            else {
                this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
            }
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            switch (evt) {
                case InteractionEvent.RangeIncrease:
                    this.ArcMap.context.getController(GNSMapKeys.Controller).increaseRange();
                    return true;
                case InteractionEvent.RangeDecrease:
                    this.ArcMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                    return true;
                case InteractionEvent.MENU:
                    ViewService.menu(this.pageMenu);
                    return true;
                case InteractionEvent.CLR:
                    if (!this.rootControl.instance.isFocused) {
                        this.ArcMap.context.getController(GNSMapKeys.Controller).changeDeclutter(this.props.settingsProvider.map.getSetting('map_arc_declutter_level'));
                        return true;
                    }
            }
            let handled = false;
            if (this.rootControl.instance.isFocused) {
                if (evt === InteractionEvent.CLR) {
                    this.rootControl.instance.blur();
                    handled = true;
                }
                else {
                    handled = this.rootControl.instance.onInteractionEvent(evt);
                }
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.ArcMap.ref.instance.sleep();
            this.clockSub.pause();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.ArcMap.ref.instance.wake();
            this.clockSub.resume();
        }
        /** @inheritdoc */
        render() {
            const fieldSettings = this.props.settingsProvider.arcMapFields;
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page page-no-padding hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.rootControl, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'arc-map-topbar' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'arc-map-track' },
                            msfsSdk.FSComponent.buildComponent("svg", { width: '42', height: '10' },
                                msfsSdk.FSComponent.buildComponent("path", { d: 'M 0 0 L 0 4 L 18 4 L 21 7 L 24 4 L 42 4 L 42 0 M 21 7 L 21 10', "stroke-width": '1px', stroke: 'cyan' })),
                            msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: msfsSdk.Subject.create(msfsGarminsdk.NavDataFieldType.GroundTrack), bus: this.props.bus, ref: this.trkField })),
                        msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('arcmap_topLeft_field_type'), bus: this.props.bus, ref: this.fields[0] }),
                        msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('arcmap_topRight_field_type'), bus: this.props.bus, ref: this.fields[1] })),
                    this.ArcMap.map,
                    msfsSdk.FSComponent.buildComponent("div", { class: 'arc-map-bottombar' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'arc-map-waypoints' },
                            msfsSdk.FSComponent.buildComponent(WaypointLeg, { ref: this.fromWaypoint, class: 'arc-map-waypoints-from', isArcMap: true }),
                            msfsSdk.FSComponent.buildComponent(LegIcon, { ref: this.legIcon }),
                            msfsSdk.FSComponent.buildComponent(WaypointLeg, { ref: this.toWaypoint, class: 'arc-map-waypoints-to', isArcMap: true })),
                        msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('arcmap_bottomLeft_field_type'), bus: this.props.bus, ref: this.fields[2] }),
                        msfsSdk.FSComponent.buildComponent(WT530Cdi, { bus: this.props.bus, fms: this.props.fms }),
                        msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('arcmap_bottomRight_field_type'), bus: this.props.bus, ref: this.fields[3] })))));
        }
    }
    /**
     * A page menu for the arc nav map page.
     */
    class ArcNavMapPageMenu extends MenuDefinition {
        /**
         * Creates an instance of a ArcNavMapPageMenu.
         * @param settingsProvider The settings provider to use with this menu.
         */
        constructor(settingsProvider) {
            super();
            this.settingsProvider = settingsProvider;
            this.onChangeFieldsSelected = () => { };
            this.onRestoreDefaults = () => { };
            this.nexradLabel = msfsSdk.Subject.create('Display NEXRAD?');
            /** @inheritdoc */
            this.entries = [
                { label: 'Crossfill?', disabled: true, action: () => { } },
                { label: 'Enable Auto Zoom?', disabled: true, action: () => { } },
                { label: this.nexradLabel, disabled: false, action: this.toggleNexrad.bind(this) },
                { label: 'Change Fields?', disabled: false, action: () => this.onChangeFieldsSelected() },
                { label: 'Restore Defaults?', disabled: false, action: () => this.onRestoreDefaults() },
            ];
            this.nexradSetting = this.settingsProvider.map.getSetting('map_arc_nexrad_enabled');
            this.nexradSetting.sub(v => this.setEntryLabel(2, v ? 'Hide NEXRAD?' : 'Display NEXRAD?'), true);
        }
        /**
         * Toggles NEXRAD for the arc nav map.
         */
        toggleNexrad() {
            this.nexradSetting.set(!this.nexradSetting.get());
            ViewService.back();
        }
        /** @inheritdoc */
        updateEntries() {
            /** no-op */
        }
    }

    /**
     * A UI control that displays items on a full page menu.
     */
    class PageMenuItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.label = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            if (typeof this.props.data.disabled !== 'boolean') {
                this.disabledSub = this.props.data.disabled.sub(this.setDisabled.bind(this), true);
            }
            else {
                this.setDisabled(this.props.data.disabled);
            }
        }
        /** @inheritdoc */
        onDisabled() {
            this.label.instance.classList.add('page-menu-item-disabled');
        }
        /** @inheritdoc */
        onEnabled() {
            this.label.instance.classList.remove('page-menu-item-disabled');
        }
        /** @inheritdoc */
        onFocused() {
            this.label.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.label.instance.classList.remove('selected');
        }
        /** @inheritdoc */
        onEnt() {
            this.props.onSelected(this);
            return true;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page-menu-entry' },
                msfsSdk.FSComponent.buildComponent("div", { ref: this.label }, this.props.data.label)));
        }
    }

    /**
     * menu button popups barebones since no options are selectable in AUX menus
     */
    class AuxPageMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: ' (No Options) ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * Page in AUX groups
     */
    class AuxPage extends GNSUiControl {
        constructor() {
            super(...arguments);
            /**
             * Page root element
             */
            this.el = msfsSdk.FSComponent.createRef();
            /**
             * Menu button dialog
             */
            this.menu = undefined;
        }
        /** @inheritDoc */
        setVisible(isVisible) {
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
            }
            else {
                this.el.instance.classList.add('hide-element');
            }
        }
        /**
         * Whether the page is currently visible
         *
         * @returns a boolean
         */
        get isVisible() {
            return !this.el.instance.classList.contains('hide-element');
        }
        /** @inheritDoc */
        onRightKnobPush() {
            if (this.isFocused) {
                this.setVisible(false);
                this.blur();
                this.props.onDisabled && this.props.onDisabled(this);
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        onClr() {
            if (this.isFocused) {
                this.setVisible(false);
                this.blur();
                this.props.onDisabled && this.props.onDisabled(this);
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        onEnt() {
            if (this.isFocused) {
                this.scroll('forward');
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        onMenu() {
            if (this.menu && this.isFocused) {
                ViewService.menu(this.menu);
                return true;
            }
            return false;
        }
    }
    /**
     * Group of AUX pages
     */
    class AuxPageGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.pages = [];
        }
        /**
         * Gets the length of the page group.
         * @returns The page group length.
         */
        get length() {
            return this.pages.length;
        }
        /** @inheritDoc */
        onInteractionEvent(evt) {
            if (this.currentPage && this.currentPageFocused()) {
                return this.currentPage.onInteractionEvent(evt);
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritDoc */
        focus(focusPosition) {
            const focused = super.focus(focusPosition);
            if (focused && this.currentPage) {
                this.showCurrentPage();
            }
            return focused;
        }
        /** @inheritDoc */
        blur() {
            super.blur();
            this.hideCurrentPage();
        }
        /**
         * Shows the currently selected page
         */
        showCurrentPage() {
            if (this.currentPage) {
                this.currentPage.setVisible(true);
                this.currentPage.focus(msfsSdk.FocusPosition.First);
            }
        }
        /**
         * Hides the currently selected page
         */
        hideCurrentPage() {
            if (this.currentPage) {
                this.currentPage.setVisible(false);
                this.currentPage.blur();
            }
        }
        /**
         * Sets the current active page in the group.
         *
         * @param key The id of the page to set as active.
         */
        setPage(key) {
            this.hideCurrentPage();
            const newPage = this.pages.find((it) => it.props.key === key);
            if (newPage) {
                this.currentPage = newPage;
                this.showCurrentPage();
            }
        }
        /**
         * Whether the current selected page is focused
         *
         * @returns boolean
         */
        currentPageFocused() {
            if (this.currentPage) {
                return this.currentPage.isFocused;
            }
            return false;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            msfsSdk.FSComponent.visitNodes(node, childNode => {
                if (childNode.instance instanceof AuxPage) {
                    this.pages.push(childNode.instance);
                    return true;
                }
                return false;
            });
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null, this.props.children));
        }
    }

    /**
     * An input control which allows the user to select a numeric digit. Digits are not necessarily constrained to be
     * integers in the range [0, 9]. Instead, they can take any valid floating point numeric value.
     */
    class GNSDigitInput extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.rootRef = msfsSdk.FSComponent.createRef();
            this.displayValueSub = msfsSdk.Subject.create(0);
            this.renderedValueSub = this.props.formatter ? this.displayValueSub.map(this.props.formatter) : this.displayValueSub.map(v => v.toString());
            this.renderedValue = null;
            this.minValue = typeof this.props.minValue === 'number' ? msfsSdk.Subject.create(this.props.minValue) : this.props.minValue;
            this.maxValue = typeof this.props.maxValue === 'number' ? msfsSdk.Subject.create(this.props.maxValue) : this.props.maxValue;
            this.increment = typeof this.props.increment === 'number' ? msfsSdk.Subject.create(this.props.increment) : this.props.increment;
            this.wrap = typeof this.props.wrap === 'boolean' ? msfsSdk.Subject.create(this.props.wrap) : this.props.wrap;
            this.scale = typeof this.props.scale === 'number' ? msfsSdk.Subject.create(this.props.scale) : this.props.scale;
            this.solidHighlightTimer = new msfsSdk.DebounceTimer();
            this.valueChangedHandler = this.onValueChanged.bind(this);
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.props.value.sub(this.valueChangedHandler, true);
            this.scale.sub(this.onScaleChanged.bind(this));
            this.renderedValueSub.sub(this.onDisplayValueChanged.bind(this), true);
        }
        /**
         * Responds to changes in the input value.
         * @param value The input value.
         */
        onValueChanged(value) {
            const scale = this.scale.get();
            this.props.value.set(Utils.Clamp(value, this.minValue.get() * scale, this.maxValue.get() * scale));
            this.displayValueSub.set(this.props.value.get() / scale);
        }
        /**
         * Responds to changes in the input scaling factor.
         * @param scale The scaling factor.
         */
        onScaleChanged(scale) {
            this.props.value.set(this.displayValueSub.get() * scale);
        }
        /**
         * Responds to changes in the displayed value.
         * @param display The displayed value, as either a plain string or a VNode.
         */
        onDisplayValueChanged(display) {
            this.rootRef.instance.innerHTML = '';
            this.cleanUpRenderedValue();
            if (typeof display === 'string') {
                this.rootRef.instance.textContent = display;
            }
            else {
                msfsSdk.FSComponent.render(display, this.rootRef.instance);
            }
            this.renderedValue = display;
        }
        /**
         * Cleans up this input's rendered value, destroying any top-level DisplayComponents that are part of the rendered
         * value's VNode tree.
         */
        cleanUpRenderedValue() {
            if (this.renderedValue !== null && typeof this.renderedValue !== 'string') {
                msfsSdk.FSComponent.visitNodes(this.renderedValue, node => {
                    if (node.instance instanceof msfsSdk.DisplayComponent) {
                        node.instance.destroy();
                        return true;
                    }
                    return false;
                });
            }
            this.renderedValue = null;
        }
        /** @inheritdoc */
        onFocused(source) {
            super.onFocused(source);
            this.rootRef.instance.classList.add('selected');
            // this.applySolidHighlight(this.props.solidHighlightDuration ?? GNSDigitInput.DEFAULT_SOLID_HIGHLIGHT_DURATION);
        }
        /** @inheritdoc */
        onBlurred(source) {
            super.onBlurred(source);
            this.rootRef.instance.classList.remove('selected');
            // this.rootRef.instance.classList.remove('highlight-active');
            // this.rootRef.instance.classList.remove('highlight-select');
            // this.solidHighlightTimer.clear();
        }
        /** @inheritdoc */
        onEnabled(source) {
            super.onEnabled(source);
            // this.rootRef.instance.classList.remove('input-disabled');
        }
        /** @inheritdoc */
        onDisabled(source) {
            super.onDisabled(source);
            // this.rootRef.instance.classList.add('input-disabled');
        }
        /**
         * Applies a solid highlight to this input.
         * @param duration The duration, in milliseconds, of the highlight.
         */
        applySolidHighlight(duration) {
            this.rootRef.instance.classList.remove('highlight-select');
            this.rootRef.instance.classList.add('highlight-active');
            this.solidHighlightTimer.schedule(() => {
                this.rootRef.instance.classList.remove('highlight-active');
                if (this.isFocused) {
                    this.rootRef.instance.classList.add('highlight-select');
                }
            }, duration);
        }
        /** @inheritdoc */
        onRightInnerInc() {
            this.changeValue(this.increment.get() * this.scale.get());
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            this.changeValue(-this.increment.get() * this.scale.get());
            return true;
        }
        /**
         * Changes this input's value by a specified amount.
         * @param delta The amount by which to change the value.
         */
        changeValue(delta) {
            const scale = this.scale.get();
            const old = this.props.value.get();
            const oldInt = old / scale;
            const deltaInt = delta / scale;
            const min = this.minValue.get();
            const max = this.maxValue.get();
            let newValue = oldInt;
            if (this.wrap.get()) {
                const mod = max - min;
                newValue = ((oldInt - min + deltaInt) % mod + mod) % mod + min;
            }
            else {
                newValue = Utils.Clamp(oldInt + deltaInt, min, max);
            }
            newValue = newValue / (1 / scale);
            this.props.value.set(newValue);
            // this.applySolidHighlight(this.props.solidHighlightDuration ?? GNSDigitInput.DEFAULT_SOLID_HIGHLIGHT_DURATION);
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("span", { ref: this.rootRef, class: `digit-input ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
        }
        /** @inheritdoc */
        destroy() {
            this.props.value.unsub(this.valueChangedHandler);
            this.solidHighlightTimer.clear();
            this.renderedValueSub.destroy();
            this.cleanUpRenderedValue();
        }
    }
    GNSDigitInput.DEFAULT_SOLID_HIGHLIGHT_DURATION = 1000; // milliseconds

    /**
     * An input control which allows the user to select a numeric sign (+ or −).
     */
    class GNSSignInput extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.rootRef = msfsSdk.FSComponent.createRef();
            this.signText = this.props.sign.map(sign => sign > 0 ? '+' : '-');
            this.solidHighlightTimer = new msfsSdk.DebounceTimer();
        }
        /** @inheritdoc */
        onFocused(source) {
            super.onFocused(source);
            this.rootRef.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred(source) {
            super.onBlurred(source);
            this.rootRef.instance.classList.remove('selected');
        }
        /** @inheritdoc */
        onEnabled(source) {
            super.onEnabled(source);
            this.rootRef.instance.classList.remove('input-disabled');
        }
        /** @inheritdoc */
        onDisabled(source) {
            super.onDisabled(source);
            this.rootRef.instance.classList.add('input-disabled');
        }
        /** @inheritdoc */
        onRightInnerInc() {
            this.changeSign();
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            this.changeSign();
            return true;
        }
        /**
         * Changes this input's sign value.
         */
        changeSign() {
            this.props.sign.set(this.props.sign.get() * -1);
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("span", { ref: this.rootRef, class: `digit-input ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }, this.signText));
        }
        /** @inheritdoc */
        destroy() {
            this.solidHighlightTimer.clear();
            this.signText.destroy();
        }
    }
    GNSSignInput.DEFAULT_SOLID_HIGHLIGHT_DURATION = 1000; // milliseconds

    /**
     * An input which allows users to select a numeric value using a combination of one or more child SignInputs and
     * DigitInputs. The input value is derived from the sum of the values of all child DigitInputs, multiplied by the
     * product of the values of all SignInputs.
     */
    class GNSGenericNumberInput extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.rootRef = msfsSdk.FSComponent.createRef();
            this.inputGroupRef = msfsSdk.FSComponent.createRef();
            this.activeRef = msfsSdk.FSComponent.createRef();
            this.inactiveRef = msfsSdk.FSComponent.createRef();
            this.signValues = [];
            this.digitValues = [];
            this.isEditing = false;
            this.inputValue = 0;
            this.renderedInactiveValue = null;
            this.solidHighlightTimer = new msfsSdk.DebounceTimer();
            this.valueChangedHandler = this.onValueChanged.bind(this);
            this.inputChangedHandler = this.onInputChanged.bind(this);
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.inputGroupRef.instance.setDisabled(true);
            msfsSdk.FSComponent.visitNodes(thisNode, node => {
                if (node.instance instanceof GNSSignInput) {
                    this.signValues.push(node.instance.props.sign);
                    return true;
                }
                else if (node.instance instanceof GNSDigitInput) {
                    this.digitValues.push(node.instance.props.value);
                    return true;
                }
                return false;
            });
            this.inputValue = this.computeValueFromInputs();
            this.props.value.sub(this.valueChangedHandler, true);
            this.signValues.forEach(value => value.sub(this.inputChangedHandler));
            this.digitValues.forEach(value => value.sub(this.inputChangedHandler));
        }
        /**
         * Responds to changes in the input value.
         */
        onValueChanged() {
            this.reconcileValueWithInputs();
            this.updateInactiveDisplay();
        }
        /**
         * Reconciles this component's bound value with the input value derived from this component's individual digit and
         * sign inputs. If the two do not match, a digitizer, if available, is used to change the digit and sign inputs'
         * values such that the input value matches the bound value. If a digitizer is not available or is unable to
         * reconcile the two values, the bound value will be changed to match the input value.
         */
        reconcileValueWithInputs() {
            const value = this.props.value.get();
            // 0 === -0 is true, so we need to differentiate between the two.
            if (value === 0 ? 1 / value === 1 / this.inputValue : value === this.inputValue) {
                return;
            }
            this.props.digitizer && this.props.digitizer(value, this.signValues, this.digitValues);
            this.inputValue = this.computeValueFromInputs();
            if (this.inputValue !== value) {
                this.props.value.set(this.inputValue);
            }
        }
        /**
         * Updates this input's rendered editing-inactive value. If editing is currently active, the rendered editing-
         * inactive value will be hidden. If editing is not active, it will be displayed and updated to reflect this input's
         * current value.
         */
        updateInactiveDisplay() {
            if (!this.isEditing && this.props.renderInactiveValue) {
                const renderedValue = this.props.renderInactiveValue(this.props.value.get());
                if (renderedValue !== this.renderedInactiveValue) {
                    this.cleanUpRenderedInactiveValue();
                    if (typeof renderedValue === 'string') {
                        this.inactiveRef.instance.textContent = renderedValue;
                    }
                    else {
                        this.inactiveRef.instance.innerHTML = '';
                        msfsSdk.FSComponent.render(renderedValue, this.inactiveRef.instance);
                    }
                    this.renderedInactiveValue = renderedValue;
                }
                this.inactiveRef.instance.style.display = '';
                this.activeRef.instance.style.display = 'none';
            }
            else {
                this.inactiveRef.instance.style.display = 'none';
                this.activeRef.instance.style.display = '';
            }
        }
        /**
         * Cleans up this input's rendered editing-inactive value, destroying any top-level DisplayComponents that are part
         * of the rendered value's VNode tree.
         */
        cleanUpRenderedInactiveValue() {
            if (this.renderedInactiveValue !== null && typeof this.renderedInactiveValue !== 'string') {
                msfsSdk.FSComponent.visitNodes(this.renderedInactiveValue, node => {
                    if (node.instance instanceof msfsSdk.DisplayComponent) {
                        node.instance.destroy();
                        return true;
                    }
                    return false;
                });
            }
            this.renderedInactiveValue = null;
        }
        /**
         * Responds to changes in the input value.
         */
        onInputChanged() {
            this.inputValue = this.computeValueFromInputs();
        }
        /**
         * Computes a value from this component's individual digit and sign inputs.
         * @returns The value represented by this component's individual digit and sign inputs.
         */
        computeValueFromInputs() {
            const sign = this.signValues.reduce((prev, curr) => prev * curr.get(), 1);
            const abs = this.digitValues.reduce((prev, curr) => prev + curr.get(), 0);
            return sign * abs;
        }
        /** @inheritdoc */
        onFocused(source) {
            super.onFocused(source);
            this.rootRef.instance.classList.add('selected');
            // this.applySolidHighlight(this.props.solidHighlightDuration ?? GNSGenericNumberInput.DEFAULT_SOLID_HIGHLIGHT_DURATION);
        }
        /** @inheritdoc */
        onBlurred(source) {
            super.onBlurred(source);
            this.rootRef.instance.classList.remove('selected');
            // this.rootRef.instance.classList.remove('highlight-select');
            this.deactivateEditing(false);
        }
        /** @inheritdoc */
        onEnabled(source) {
            super.onEnabled(source);
            // this.rootRef.instance.classList.remove('input-disabled');
        }
        /** @inheritdoc */
        onDisabled(source) {
            super.onDisabled(source);
            // this.rootRef.instance.classList.add('input-disabled');
        }
        /** @inheritdoc */
        onRightInnerInc() {
            this.activateEditing(InteractionEvent.RightInnerInc);
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            this.activateEditing(InteractionEvent.RightInnerDec);
            return true;
        }
        /** @inheritdoc */
        onEnt(source) {
            let handled = false;
            if (this.isEditing) {
                this.deactivateEditing(true);
                handled = true;
            }
            return handled || !!(this.props.onEnt && this.props.onEnt(source));
        }
        /** @inheritdoc */
        onClr(source) {
            var _a;
            let handled = false;
            if (this.isEditing) {
                this.deactivateEditing(false);
                handled = true;
            }
            else if ((_a = this.props.activateOnClr) !== null && _a !== void 0 ? _a : false) {
                this.digitValues.forEach((v) => { var _a; return v.set((_a = this.props.clrValue) !== null && _a !== void 0 ? _a : 0); });
                this.activateEditing();
                handled = true;
            }
            return handled || !!(this.props.onClr && this.props.onClr(source));
        }
        /**
         * Activates editing for this component.
         * @param activatingEvent The event that triggered activation of editing, if any.
         */
        activateEditing(activatingEvent) {
            if (this.isEditing) {
                return;
            }
            this.solidHighlightTimer.clear();
            this.rootRef.instance.classList.remove('selected');
            // this.rootRef.instance.classList.remove('highlight-select');
            this.inactiveRef.instance.style.display = 'none';
            this.activeRef.instance.style.display = '';
            this.inputGroupRef.instance.setDisabled(false);
            this.inputGroupRef.instance.focus(msfsSdk.FocusPosition.First);
            if (activatingEvent !== undefined && this.props.editOnActivate) {
                this.inputGroupRef.instance.onInteractionEvent(activatingEvent);
            }
            this.isEditing = true;
        }
        /**
         * Deactivates editing for this component.
         * @param saveValue Whether to save the current edited input value to this component's bound value.
         */
        deactivateEditing(saveValue) {
            if (!this.isEditing) {
                return;
            }
            this.inputGroupRef.instance.blur();
            this.inputGroupRef.instance.setDisabled(true);
            if (this.isFocused) {
                this.applySolidHighlight();
            }
            else {
                this.solidHighlightTimer.clear();
            }
            if (saveValue) {
                const acceptedValue = this.inputValue;
                this.props.value.set(acceptedValue);
                this.props.onInputAccepted && this.props.onInputAccepted(acceptedValue);
            }
            else {
                const rejectedValue = this.inputValue;
                //this.reconcileValueWithInputs();
                this.props.onInputRejected && this.props.onInputRejected(rejectedValue);
                this.props.digitizer && this.props.digitizer(this.props.value.get(), this.signValues, this.digitValues);
            }
            this.isEditing = false;
            this.updateInactiveDisplay();
        }
        /**
         * Applies a solid highlight to this input.
         */
        applySolidHighlight() {
            this.rootRef.instance.classList.add('selected');
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.rootRef, style: 'display: inline-block;', class: `number-input ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfsSdk.FSComponent.buildComponent("div", { ref: this.activeRef, class: 'number-input-active' },
                    msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.inputGroupRef, isolateScroll: true }, this.props.children)),
                msfsSdk.FSComponent.buildComponent("div", { ref: this.inactiveRef, class: 'number-input-inactive' })));
        }
        /** @inheritdoc */
        destroy() {
            this.solidHighlightTimer.clear();
            this.props.value.unsub(this.valueChangedHandler);
            this.signValues.forEach(value => value.unsub(this.inputChangedHandler));
            this.digitValues.forEach(value => value.unsub(this.inputChangedHandler));
            this.cleanUpRenderedInactiveValue();
        }
    }
    GNSGenericNumberInput.DEFAULT_SOLID_HIGHLIGHT_DURATION = 1000; // milliseconds

    /**
     * An input which allows users to select a numeric value using a combination of one or more child SignInputs and
     * DigitInputs. The input value is derived from the sum of the values of all child DigitInputs, multiplied by the
     * product of the values of all SignInputs.
     */
    class GNSNumberUnitInput extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this._value = msfsSdk.Subject.create(0);
        }
        /** @inheritdoc */
        onAfterRender() {
            this.props.data.sub(this.parseValue.bind(this));
        }
        /**
         * Parses the value from the data in the display unit specified in the props.
         * @param v is the NumberUnitInterface
         */
        parseValue(v) {
            this._value.set(v.asUnit(this.props.displayUnit.get()));
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(GNSGenericNumberInput, { ref: this.props.ref, value: this._value, digitizer: this.props.digitizer, editOnActivate: this.props.editOnActivate, activateOnClr: this.props.activateOnClr, class: this.props.class, renderInactiveValue: this.props.renderInactiveValue, onInputAccepted: this.props.onInputAccepted, onInputRejected: this.props.onInputRejected, solidHighlightDuration: this.props.solidHighlightDuration }, this.props.children));
        }
    }

    /**
     * menu button popups barebones since no options are selectable in AUX menus
     */
    class FuelPlanningMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: 'Flight Plan?', disabled: msfsSdk.Subject.create(false), action: () => { } },
                { label: 'Change Fields?', disabled: msfsSdk.Subject.create(false), action: () => { } },
                { label: 'Restore Defaults?', disabled: msfsSdk.Subject.create(false), action: () => { } },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * Flight planning page for Aux group of pages
     */
    class FuelPlanning extends AuxPage {
        constructor() {
            super(...arguments);
            /** @inheritDoc */
            this.menu = new FuelPlanningMenu();
            this.unitsSettingsManager = this.props.settingsProvider.units;
            this.generalSettingsManager = this.props.settingsProvider.generalSettings;
            this.gpsPosition = msfsSdk.ConsumerSubject.create(this.props.bus.getSubscriber().on('gps-position').whenChanged(), new LatLongAlt());
            this.volumeUnit = msfsSdk.Subject.create(msfsSdk.UnitType.GALLON_FUEL);
            this.distanceUnit = msfsSdk.Subject.create(msfsSdk.UnitType.NMILE);
            this.speedUnit = msfsSdk.ComputedSubject.create(this.distanceUnit.get(), v => {
                switch (v) {
                    case msfsSdk.UnitType.MILE:
                        return msfsSdk.UnitType.MPH;
                    case msfsSdk.UnitType.KILOMETER:
                        return msfsSdk.UnitType.KPH;
                    default:
                        return msfsSdk.UnitType.KNOT;
                }
            });
            this.fromFacility = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '_____';
                }
                return msfsSdk.ICAO.getIdent(v.icao);
            });
            this.toFacility = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '_____';
                }
                return msfsSdk.ICAO.getIdent(v.icao);
            });
            this.fobInput = msfsSdk.FSComponent.createRef();
            this.flowInput = msfsSdk.FSComponent.createRef();
            this.gsInput = msfsSdk.FSComponent.createRef();
            this.fob = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GALLON_FUEL.createNumber(0));
            this.flow = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GALLON_FUEL.createNumber(0));
            this.gs = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            this.req = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GALLON_FUEL.createNumber(NaN));
            this.lfob = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GALLON_FUEL.createNumber(NaN));
            this.lres = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.SECOND.createNumber(NaN));
            this.rng = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            this.endur = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.SECOND.createNumber(NaN));
            this.eff = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '__._';
                }
                return v.toFixed(1);
            });
            this.distance = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            this.selectToFacility = () => {
                return this.selectFacility(true);
            };
            this.selectFromFacility = () => {
                return this.selectFacility(false);
            };
            this.oneDecimalFormat = (value) => {
                return (parseInt(value) / 10).toFixed(1);
            };
        }
        /**
         * Calculate the Fuel Page Output Values
         */
        calculate() {
            if (this.distance.get().isNaN() || this.gs.get().number < 1 || this.flow.get().number < 1 || this.fob.get().number < 1) {
                this.lfob.set(NaN);
                this.lres.set(NaN);
                this.req.set(NaN);
                this.endur.set(NaN);
                this.rng.set(NaN);
                this.eff.set(undefined);
                return;
            }
            const distance = this.distance.get().asUnit(this.unitsSettingsManager.distanceUnitsLarge.get());
            const gs = this.gs.get().asUnit(this.unitsSettingsManager.speedUnits.get());
            // flow is set with a multiplier of 10 to allow for proper decimal place selecting
            // without getting weird JS rounding errors, must be divided by 10 to get the actuall flow rate.
            const flow = this.flow.get().asUnit(this.unitsSettingsManager.fuelUnits.get()) / 10;
            const fob = this.fob.get().asUnit(this.unitsSettingsManager.fuelUnits.get());
            //calc REQ fuel
            const time = distance / gs;
            const req = time * flow;
            this.req.set(req, this.unitsSettingsManager.fuelUnits.get());
            //calc LFOB
            const lfob = fob - req;
            this.lfob.set(lfob, this.unitsSettingsManager.fuelUnits.get());
            //calc LRES
            this.lres.set(lfob / flow, msfsSdk.UnitType.HOUR);
            //calc ENDUR
            const endur = fob / flow;
            this.endur.set(endur, msfsSdk.UnitType.HOUR);
            //calc RNG
            const rng = endur * gs;
            this.rng.set(rng, this.unitsSettingsManager.distanceUnitsLarge.get());
            //calc EFF
            this.eff.set(rng / fob);
        }
        /**
         * Gets the GC distance between two facilities.
         */
        getDistance() {
            const fromFacility = this.fromFacility.getRaw();
            const toFacility = this.toFacility.getRaw();
            if (fromFacility != undefined && toFacility != undefined) {
                this.distance.set(msfsSdk.UnitType.GA_RADIAN.createNumber(new msfsSdk.GeoPoint(fromFacility.lat, fromFacility.lon).distance(toFacility.lat, toFacility.lon)));
            }
            else {
                this.distance.set(NaN);
            }
            this.calculate();
        }
        /**
         * Gets a temporary facility from the present position
         * @returns the temporary facility
         */
        getPresentPositionFacility() {
            return {
                icao: '        P.POS',
                name: 'P.POS',
                lat: this.gpsPosition.get().lat,
                lon: this.gpsPosition.get().long,
                region: '',
                city: '',
                magvar: 0
            };
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.fromFacility.sub(() => this.getDistance());
            this.toFacility.sub(() => this.getDistance());
            this.distanceUnit.sub(() => {
                this.calculate();
            });
            this.volumeUnit.sub(() => {
                this.calculate();
            });
            this.fob.sub(() => this.calculate());
            this.flow.sub(() => this.calculate());
            this.gs.sub(() => this.calculate());
        }
        /**
         * Handles when the inner knob is turned.
         * @param isToFacility whether we are selecting the to facility
         * @returns True as it will always be handled.
         */
        selectFacility(isToFacility) {
            ViewService.getWaypoint().then(facility => {
                if (isToFacility) {
                    this.toFacility.set(facility);
                }
                else {
                    this.fromFacility.set(facility);
                }
            });
            return true;
        }
        /**
         * Callback to render an inactive value.
         * @param value The value to display.
         * @param unit The display unit of the value.
         * @returns a VNODE to render.
         */
        renderInactiveValue(value, unit) {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                value,
                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: unit })));
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page fuel-planning-page hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("h2", { class: "page-header" }, "FUEL PLANNING"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'fuel-planning-page-header cyan' },
                    msfsSdk.FSComponent.buildComponent("h2", null, "POINT TO POINT")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'fuel-planning-input-table' },
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-input-table-cell" }),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-input-table-cell", id: 'fuel-planning-from' },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { data: this.fromFacility, class: '', onClr: () => {
                                this.fromFacility.set(this.getPresentPositionFacility());
                                return true;
                            }, onEnt: () => this.scroll('forward'), onRightInnerDec: this.selectFromFacility, onRightInnerInc: this.selectFromFacility })),
                    msfsSdk.FSComponent.buildComponent("div", { id: 'fuel-planning-arrow' },
                        msfsSdk.FSComponent.buildComponent("svg", { width: "9", height: "10" },
                            msfsSdk.FSComponent.buildComponent("path", { d: "M 8 4 l -5 -4 l 0 3 l -3 0 l 0 2 l 3 0 l 0 3 l 5 -4 z", stroke: "rgb(0, 255, 0)", fill: "rgb(0, 255, 0)", "stroke-width": "1px" }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-input-table-cell", id: 'fuel-planning-to' },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { data: this.toFacility, class: '', onClr: () => {
                                this.toFacility.set(this.getPresentPositionFacility());
                                return true;
                            }, onEnt: () => this.scroll('forward'), onRightInnerDec: this.selectToFacility, onRightInnerInc: this.selectToFacility })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'fuel-planning-input-table-cell', id: "fuel-planning-fob" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.fob, displayUnit: this.unitsSettingsManager.fuelUnits, ref: this.fobInput, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 10000));
                                digitValues[1].set(Math.floor((value % 10000) / 1000));
                                digitValues[2].set(Math.floor((value % 1000) / 100));
                                digitValues[3].set(Math.floor((value % 100) / 10));
                                digitValues[4].set(Math.floor((value % 10) / 1));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => { return this.renderInactiveValue((value).toFixed(0), this.unitsSettingsManager.fuelUnits); }, onInputAccepted: (v) => { this.fob.set(v, this.unitsSettingsManager.fuelUnits.get()); } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.fuelUnits }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'fuel-planning-input-table-cell', id: "fuel-planning-flow" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.flow, displayUnit: this.unitsSettingsManager.fuelUnits, ref: this.flowInput, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 1000));
                                digitValues[1].set(Math.floor((value % 1000) / 100));
                                digitValues[2].set(Math.floor((value % 100) / 10));
                                digitValues[3].set(Math.floor((value % 10) / 1));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => { return this.renderInactiveValue((value / 10).toFixed(1), this.unitsSettingsManager.fuelUnits); }, onInputAccepted: (v) => { this.flow.set(v, this.unitsSettingsManager.fuelUnits.get()); } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent("span", null, "."),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.fuelUnits }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-input-table-cell", id: "fuel-planning-gs" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.gs, displayUnit: this.unitsSettingsManager.speedUnits, ref: this.gsInput, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 100));
                                digitValues[1].set(Math.floor((value % 100) / 10));
                                digitValues[2].set(Math.floor((value % 10) / 1));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => { return this.renderInactiveValue(value.toFixed(0), this.unitsSettingsManager.speedUnits); }, onInputAccepted: (v) => { this.gs.set(v, this.unitsSettingsManager.speedUnits.get()); } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.speedUnits })))),
                msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-labels cyan" },
                    msfsSdk.FSComponent.buildComponent("div", null, "FOB"),
                    msfsSdk.FSComponent.buildComponent("div", null, "FLOW"),
                    msfsSdk.FSComponent.buildComponent("div", null, "GS")),
                msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-labels-bot cyan" },
                    msfsSdk.FSComponent.buildComponent("div", null, "REQ"),
                    msfsSdk.FSComponent.buildComponent("div", null, "LFOB"),
                    msfsSdk.FSComponent.buildComponent("div", null, "LRES")),
                msfsSdk.FSComponent.buildComponent("div", { id: 'fuel-planning-data-table' },
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-output-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 4, nanString: '___._' }), value: this.req, displayUnit: this.unitsSettingsManager.fuelUnits })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-output-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 4, nanString: '___._' }), value: this.lfob, displayUnit: this.unitsSettingsManager.fuelUnits })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-output-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.DurationFormatter.create('{hh}:{mm}', msfsSdk.UnitType.HOUR, 0, '__:__'), value: this.lres, displayUnit: msfsSdk.UnitType.HOUR })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-output-cell" }, this.eff),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-output-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 4, nanString: '_.__' }), value: this.rng, displayUnit: this.unitsSettingsManager.distanceUnitsLarge.get() })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-output-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.DurationFormatter.create('{hh}:{mm}', msfsSdk.UnitType.HOUR, 0, '__:__'), value: this.endur, displayUnit: msfsSdk.UnitType.HOUR }))),
                msfsSdk.FSComponent.buildComponent("div", { class: "fuel-planning-labels cyan" },
                    msfsSdk.FSComponent.buildComponent("div", { style: "text-align: left;" }, "EFF"),
                    msfsSdk.FSComponent.buildComponent("div", { style: "text-align: center;" }, "RNG"),
                    msfsSdk.FSComponent.buildComponent("div", { style: "text-align: right;" }, "ENDUR"))));
        }
    }

    /**
     * Trip planning page
     */
    class TripPlanning extends AuxPage {
        constructor() {
            super(...arguments);
            //settings for the units
            this.unitsSettingsManager = this.props.settingsProvider.units;
            this.notEl = msfsSdk.FSComponent.createRef();
            this.depTimeInput = msfsSdk.FSComponent.createRef();
            this.depDateInput = msfsSdk.FSComponent.createRef();
            this.gsInput = msfsSdk.FSComponent.createRef();
            this.gpsPosition = msfsSdk.ConsumerSubject.create(this.props.bus.getSubscriber().on('gps-position').whenChanged(), new LatLongAlt());
            this.depTimeRaw = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.SECOND.createNumber(NaN));
            this.depDateRaw = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.SECOND.createNumber(NaN));
            this.gs = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            this.timeUnit = msfsSdk.Subject.create(msfsSdk.UnitType.SECOND);
            this.angleUnit = msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE);
            /*
            FIXME - this is really dirty, as we are using numerical values to store time and date. However, the current input system
                    basically only supports that, so for now we have to do this.
           */
            this.depTime = msfsSdk.CombinedSubject.create(this.depTimeRaw, this.depDateRaw).map(([timeRaw, dateRaw]) => {
                if (isNaN(dateRaw.number) || isNaN(timeRaw.number)) {
                    return NaN;
                }
                let y, M, d, m, h;
                const dateFixed = dateRaw.number.toFixed(0);
                if (dateFixed.length === 3) {
                    y = '0';
                    M = dateFixed.substring(0, 1);
                    d = dateFixed.substring(1, 3);
                }
                else if (dateFixed.length === 5) {
                    y = dateFixed.substring(0, 1);
                    M = dateFixed.substring(1, 3);
                    d = dateFixed.substring(3, 5);
                }
                else {
                    y = dateFixed.substring(0, 2);
                    M = dateFixed.substring(2, 4);
                    d = dateFixed.substring(4, 6);
                }
                const timeFixed = timeRaw.number.toFixed(0);
                if (timeFixed.length === 3) {
                    h = timeFixed.substring(0, 1);
                    m = timeFixed.substring(1, 3);
                }
                else {
                    h = timeFixed.substring(0, 2);
                    m = timeFixed.substring(2, 4);
                }
                const yy = y.padStart(2, '0');
                const MM = M.padStart(2, '0');
                const dd = d.padStart(2, '0');
                const hh = h.padStart(2, '0');
                const mm = m.padStart(2, '0');
                return new Date(Date.parse(`20${yy}-${MM}-${dd}T${hh}:${mm}:00`)).getTime();
            });
            this.fromFacility = msfsSdk.Subject.create(undefined);
            this.fromFacilityIdent = this.fromFacility.map((v) => {
                if (v === undefined) {
                    return '_____';
                }
                return msfsSdk.ICAO.getIdent(v.icao);
            });
            this.toFacility = msfsSdk.Subject.create(undefined);
            this.toFacilityIdent = this.toFacility.map((v) => {
                if (v === undefined) {
                    return '_____';
                }
                return msfsSdk.ICAO.getIdent(v.icao);
            });
            this.selectFromFacility = () => {
                return this.selectFacility(false);
            };
            this.selectToFacility = () => {
                return this.selectFacility(true);
            };
            /**
             * Outputs DTK in nautical miles
             */
            this.directTrackOutput = msfsSdk.CombinedSubject.create(this.fromFacility, this.toFacility).map(([from, to]) => {
                if (from && to) {
                    const fromLla = new msfsSdk.GeoPoint(from.lat, from.lon);
                    const toLla = new msfsSdk.GeoPoint(to.lat, to.lon);
                    return fromLla.bearingTo(toLla);
                }
            });
            /**
             * Outputs DIS in nautical miles
             */
            this.distanceOutput = msfsSdk.CombinedSubject.create(this.fromFacility, this.toFacility).map(([from, to]) => {
                if (from && to) {
                    const fromLla = new msfsSdk.GeoPoint(from.lat, from.lon);
                    const toLla = new msfsSdk.GeoPoint(to.lat, to.lon);
                    return msfsSdk.UnitType.GA_RADIAN.convertTo(fromLla.distance(toLla), msfsSdk.UnitType.NMILE);
                }
            });
            /**
             * Outputs ETE in seconds
             */
            this.eteOutput = msfsSdk.CombinedSubject.create(this.distanceOutput, this.gs).map(([distance, gs]) => {
                if (distance !== undefined) {
                    const hours = distance / gs.number;
                    if (hours > 99) {
                        return NaN;
                    }
                    return hours * 3600;
                }
                return NaN;
            });
            /**
             * Outputs ETA in seconds
             */
            this.etaOutput = msfsSdk.CombinedSubject.create(this.depTime, this.eteOutput).map(([simTime, ete]) => {
                if (simTime > 0) {
                    return simTime + (ete * 1000);
                }
                return NaN;
            });
            /**
             * DTK NumberUnitSubject
             */
            this.dtk = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(NaN));
            /**
             * DIS NumberUnitSubject
             */
            this.dis = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            /**
             * ERE NumberUnitSubject
             */
            this.ete = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.SECOND.createNumber(NaN));
            /**
             * ETA NumberUnitSubject
             */
            this.eta = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.SECOND.createNumber(NaN));
        }
        /**
         * Formats a compressed time value into a string for display
         *
         * @param value the compressed time value
         *
         * @returns formatted time string
         */
        formatCompressedTime(value) {
            /*
            FIXME - this is really dirty, as we are using numerical values to store time and date. However, the current input system
                    basically only supports that, so for now we have to do this.
            */
            if (!value || isNaN(value)) {
                return '__:__';
            }
            let h, m;
            const timeFixed = value.toFixed(0);
            if (timeFixed.length === 3) {
                h = timeFixed.substring(0, 1);
                m = timeFixed.substring(1, 3);
            }
            else {
                h = timeFixed.substring(0, 2);
                m = timeFixed.substring(2, 4);
            }
            const hh = h.padStart(2, '0');
            const mm = m.padStart(2, '0');
            return `${hh}:${mm}`;
        }
        /**
         * Formats a compressed date value into a string for display
         *
         * @param value the compressed date value
         *
         * @returns formatted date string
         */
        formatCompressedDate(value) {
            /*
            FIXME - this is really dirty, as we are using numerical values to store time and date. However, the current input system
                    basically only supports that, so for now we have to do this.
            */
            var _a, _b;
            if (!value || isNaN(value)) {
                return '__-___-__';
            }
            let y, M, d;
            const dateFixed = value.toFixed(0);
            if (dateFixed.length === 3) {
                y = '0';
                M = dateFixed.substring(0, 1);
                d = dateFixed.substring(1, 3);
            }
            else if (dateFixed.length === 5) {
                y = dateFixed.substring(0, 1);
                M = dateFixed.substring(1, 3);
                d = dateFixed.substring(3, 5);
            }
            else {
                y = dateFixed.substring(0, 2);
                M = dateFixed.substring(2, 4);
                d = dateFixed.substring(4, 6);
            }
            const yy = y.padStart(2, '0');
            const MMM = (_b = (_a = msfsSdk.DateTimeFormatter.DEFAULT_OPTIONS.monthNamesShort[parseInt(M) - 1]) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : '___';
            const dd = d.padStart(2, '0');
            return `${dd}-${MMM}-${yy}`;
        }
        /** @inheritDoc */
        setVisible(isVisible) {
            if (isVisible) {
                this.notEl.instance.classList.remove('hide-element');
            }
            else {
                this.notEl.instance.classList.add('hide-element');
            }
        }
        /** @inheritDoc */
        onRightKnobPush() {
            if (this.isFocused) {
                this.setVisible(false);
                this.blur();
                this.props.onDisabled && this.props.onDisabled(this);
                return true;
            }
            return false;
        }
        /**
         * Handles when the inner knob is turned.
         * @param isToFacility whether we are selecting the to facility
         * @returns True as it will always be handled.
         */
        selectFacility(isToFacility) {
            ViewService.getWaypoint().then((facility) => {
                if (isToFacility) {
                    this.toFacility.set(facility);
                }
                else {
                    this.fromFacility.set(facility);
                }
            });
            return true;
        }
        /**
         * Gets a temporary facility from the present position
         * @returns the temporary facility
         */
        getPresentPositionFacility() {
            return {
                icao: '        P.POS',
                name: 'P.POS',
                lat: this.gpsPosition.get().lat,
                lon: this.gpsPosition.get().long,
                region: '',
                city: '',
                magvar: 0
            };
        }
        /**
         * Callback to render an inactive value.
         * @param value The value to display.
         * @param unit The display unit of the value.
         * @returns a VNODE to render.
         */
        renderInactiveValue(value, unit) {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                value,
                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: unit })));
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.directTrackOutput.sub((value) => this.dtk.set(value !== null && value !== void 0 ? value : NaN, this.angleUnit.get()));
            this.distanceOutput.sub((value) => this.dis.set(value !== null && value !== void 0 ? value : NaN, this.unitsSettingsManager.distanceUnitsLarge.get()));
            this.eteOutput.sub((value) => this.ete.set(value !== null && value !== void 0 ? value : NaN, this.timeUnit.get()));
            this.etaOutput.sub((value) => this.eta.set(value !== null && value !== void 0 ? value : NaN, this.timeUnit.get()));
        }
        /** @inheritDoc */
        render() {
            return msfsSdk.FSComponent.buildComponent("div", { ref: this.notEl, class: "page trip-planning-page aux-page hide-element" },
                msfsSdk.FSComponent.buildComponent("h2", { class: 'page-header' }, "TRIP PLANNING"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'trip-planning-page-header cyan' },
                    msfsSdk.FSComponent.buildComponent("h2", null, "POINT TO POINT")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table trip-planning-table' },
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" }),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell", id: 'trip-planning-from' },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { data: this.fromFacilityIdent, class: '', onClr: () => {
                                this.fromFacility.set(this.getPresentPositionFacility());
                                return true;
                            }, onEnt: () => this.scroll('forward'), onRightInnerDec: this.selectFromFacility, onRightInnerInc: this.selectFromFacility })),
                    msfsSdk.FSComponent.buildComponent("div", { id: 'trip-planning-arrow' },
                        msfsSdk.FSComponent.buildComponent("svg", { width: "9", height: "10" },
                            msfsSdk.FSComponent.buildComponent("path", { d: "M 8 4 l -5 -4 l 0 3 l -3 0 l 0 2 l 3 0 l 0 3 l 5 -4 z", stroke: "rgb(0, 255, 0)", fill: "rgb(0, 255, 0)", "stroke-width": "1px" }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell", id: 'trip-planning-to' },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { data: this.toFacilityIdent, class: '', onClr: () => {
                                this.toFacility.set(this.getPresentPositionFacility());
                                return true;
                            }, onEnt: () => this.scroll('forward'), onRightInnerDec: this.selectToFacility, onRightInnerInc: this.selectToFacility })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'trip-planning-table-cell', id: "trip-planning-time" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.depTimeRaw, displayUnit: this.timeUnit, ref: this.depTimeInput, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value));
                                digitValues[1].set(Math.floor(value % 100));
                                digitValues[2].set(Math.floor(value % 10));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                const formatted = this.formatCompressedTime(value);
                                return this.renderInactiveValue(formatted, msfsSdk.Subject.create(msfsSdk.UnitType.TON));
                            }, onInputAccepted: (v) => {
                                this.depTimeRaw.set(v, this.timeUnit.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 25, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent("span", null, ":"),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 6, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.weightUnits }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'trip-planning-table-cell', id: "trip-planning-date" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.depDateRaw, displayUnit: this.timeUnit, ref: this.depDateInput, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value % 100));
                                digitValues[2].set(Math.floor(value));
                                digitValues[1].set(Math.floor(value % 1000));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                const formatted = this.formatCompressedDate(value);
                                return this.renderInactiveValue(formatted, msfsSdk.Subject.create(msfsSdk.UnitType.TON));
                            }, onInputAccepted: (v) => {
                                this.depDateRaw.set(v, this.timeUnit.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 31, increment: 1, scale: 1, wrap: true, formatter: (value) => value.toString().padStart(2, '0') }),
                            msfsSdk.FSComponent.buildComponent("span", null, "-"),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 1, maxValue: 13, increment: 1, scale: 100, wrap: true, formatter: (month) => {
                                    return (msfsSdk.DateTimeFormatter.DEFAULT_OPTIONS.monthNamesShort[Math.max(0, month - 1)].toUpperCase());
                                } }),
                            msfsSdk.FSComponent.buildComponent("span", null, "-"),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 99, increment: 1, scale: 10000, wrap: true, formatter: (value) => value.toString().padStart(2, '0') }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.FPM) }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell", id: "trip-planning-gs" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.gs, displayUnit: this.unitsSettingsManager.speedUnits, ref: this.gsInput, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 100));
                                digitValues[1].set(Math.floor((value % 100) / 10));
                                digitValues[2].set(Math.floor((value % 10) / 1));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                return this.renderInactiveValue(value.toFixed(0), this.unitsSettingsManager.speedUnits);
                            }, onInputAccepted: (v) => {
                                this.gs.set(v, this.unitsSettingsManager.speedUnits.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.speedUnits })))),
                msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-labels cyan" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DEP TIME")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DEP DATE")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "GS"))),
                msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-labels-bot cyan" },
                    msfsSdk.FSComponent.buildComponent("div", null, "DTK"),
                    msfsSdk.FSComponent.buildComponent("div", null, "DIS"),
                    msfsSdk.FSComponent.buildComponent("div", null, "ETE")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table trip-planning-table', style: "height: 45px;" },
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({
                                precision: -1,
                                forceDecimalZeroes: true,
                                maxDigits: 3,
                                nanString: '___'
                            }), value: this.dtk, displayUnit: this.angleUnit })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.dis, displayUnit: this.unitsSettingsManager.distanceUnitsLarge })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.DurationFormatter.create('{HH}:{mm}', msfsSdk.UnitType.SECOND, 0, '__:__'), value: this.ete, displayUnit: this.timeUnit })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 5, nanString: '_____' }), value: msfsSdk.NumberUnitSubject.create(new msfsSdk.NumberUnit(NaN, msfsSdk.UnitType.FOOT)), displayUnit: this.unitsSettingsManager.altitudeUnits })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" }),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.DateTimeFormatter.create('{HH}:{mm}', { nanString: '__:__' }), value: this.eta, displayUnit: this.timeUnit }))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels cyan", style: "padding-top:2px;" },
                    msfsSdk.FSComponent.buildComponent("div", null, "ESA"),
                    msfsSdk.FSComponent.buildComponent("div", null),
                    msfsSdk.FSComponent.buildComponent("div", null, "ETA")),
                msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-sun" },
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels-two cyan", style: "padding-bottom:2px;" },
                        msfsSdk.FSComponent.buildComponent("div", null, "SUNRISE AT DEST"),
                        msfsSdk.FSComponent.buildComponent("div", null, "SUNSET AT DEST")),
                    msfsSdk.FSComponent.buildComponent("div", { class: "trip-planning-sun-flex" },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table', style: "width: 100px; height: 23px;" }),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table', style: "width: 100px; height: 23px;" }))));
        }
    }
    TripPlanning.dateFormatter = msfsSdk.DateTimeFormatter.create('{dd}-{MON}-{YY}', { nanString: '__-___-__' });

    /**
     * Air Data Computer Math Utility Class.
     */
    class AdcMath {
        /**
         * Gets the ISA Standard Temp and Press from Altitude.
         * @param altitude The altitude in feet.
         * @returns an array of [temp K, pressure PA]
         */
        static calcIsaFromAltitude(altitude) {
            let temp = 0.0;
            let pressure = 0.0;
            if (altitude <= 36089) {
                // 36089 is the altitude of the top of the troposphere
                temp = AdcMath.slIsaTemp + (-AdcMath.lapseFt * altitude);
                pressure = AdcMath.slIsaPres * Math.pow((AdcMath.slIsaTemp / temp), (0.034163203 / -0.0065));
            }
            else if (altitude <= 65616) {
                // 65616 is the altitude of the tropopause
                // 22632.06 is the pressure at the base of the tropopause in PA
                const tropoPres = 22632.06;
                const tropoTemp = 216.65;
                temp = tropoTemp;
                pressure = tropoPres * Math.exp((0.010412944 / 216.65) * (65616 - altitude));
            }
            else {
                temp = NaN;
                pressure = NaN;
            }
            return [temp, pressure];
        }
        /**
         * Calculate the pressure altitude from Indicated Altitude and Sea Level Pressure.
         * @param indicatedAltitude The indicated altitude.
         * @param baroSettingInHg The altimeter setting in inHg.
         * @returns The Pressure Altitude.
         */
        static calcPressureAltitude(indicatedAltitude, baroSettingInHg) {
            return indicatedAltitude + (1000 * (29.92 - baroSettingInHg));
        }
        /**
         * Calculate the static pre
         * @param indicatedAltitude The indicated altitude.
         * @param baroSettingInHg The altimeter setting in inHg.
         * @returns The Static Pressure in inHg.
         */
        static calcStaticPressure(indicatedAltitude, baroSettingInHg) {
            return AdcMath.calcIsaFromAltitude(AdcMath.calcPressureAltitude(indicatedAltitude, baroSettingInHg))[1];
        }
        /**
         * Calculate the Impact Pressure.
         * @param cas Calibrated Airspeed in knots.
         * @returns the Impact Pressure in Pa.
         */
        static calcImpactPressure(cas) {
            return AdcMath.airDensity * Math.pow(msfsSdk.UnitType.KNOT.convertTo(cas, msfsSdk.UnitType.MPS), 2) / 2;
        }
        /**
         * Calculate the Mach number from airspeed, altitude and pressure.
         * @param cas Calibrated Airspeed in knots.
         * @param indicatedAltitude Indicated Altitude in Feet.
         * @param baroSettingInHg The local altimeter setting in inHg.
         * @returns The current Mach Number.
         */
        static calcMachFromSpeedAltitudePressure(cas, indicatedAltitude, baroSettingInHg) {
            const impactPressure = AdcMath.calcImpactPressure(cas);
            const staticPressure = AdcMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
            return Math.sqrt(5 * (Math.pow((impactPressure / staticPressure) + 1, 2 / 7) - 1));
        }
        /**
         * Calculate static air temperature (SAT, also OAT), from total air temperature (TAT) and Mach.
         * @param tat Total Air Temp in degrees C.
         * @param mach Mach number.
         * @returns The Static Air Temperature in degrees C.
         */
        static calcSatFromTatAndMach(tat, mach) {
            // Gamma minus 1 / 2 = 0.2
            return msfsSdk.UnitType.KELVIN.convertTo(msfsSdk.UnitType.CELSIUS.convertTo(tat, msfsSdk.UnitType.KELVIN) / (1 + (Math.pow(mach, 2) * 0.2)), msfsSdk.UnitType.CELSIUS);
        }
        /**
         * Calculate the True Airspeed from Altitude, Temperature and Calibrated Airspeed.
         * @param altitude Altitude in Feet.
         * @param tat Total Air Temp in degrees C.
         * @param cas Calibrated Airspeed in KT.
         * @param baroSettingInHg The altimeter setting in inHg.
         * @returns True Airspeed in KT.
         */
        static calcTasfromCas(altitude, tat, cas, baroSettingInHg) {
            const pressureAltitude = AdcMath.calcPressureAltitude(altitude, baroSettingInHg);
            const isa = AdcMath.calcIsaFromAltitude(pressureAltitude);
            const isaPres = isa[1];
            const mach = AdcMath.calcMachFromSpeedAltitudePressure(cas, altitude, baroSettingInHg);
            const temp = msfsSdk.UnitType.CELSIUS.convertTo(AdcMath.calcSatFromTatAndMach(tat, mach), msfsSdk.UnitType.KELVIN);
            const alpha = Math.sqrt(AdcMath.gammaGasVolume * temp);
            const tas = Math.sqrt(5) * alpha * Math.sqrt(Math.pow(((AdcMath.slIsaPres / isaPres) *
                (Math.pow((cas * cas / AdcMath.sqrtGammaGasSlNmSqd5) + 1, AdcMath.gammaOverGammaMinus1) - 1) + 1), AdcMath.gammaMinus1OverGamma) - 1);
            return msfsSdk.UnitType.FPS.convertTo(tas, msfsSdk.UnitType.KNOT);
        }
        /**
         * Calculate density altitude from indicated altitude, barometer setting and static air temperature.
         * @param indicatedAltitude indicated altitude in feet (ft)
         * @param baroSettingInHg barometer setting in inches of mercury (inHg)
         * @param sat static air temperature in degrees celsius (°C)
         * @returns density altitude in feet (ft)
         */
        static calcDensityAltitude(indicatedAltitude, baroSettingInHg, sat) {
            const stationPressurePa = AdcMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
            const stationPressureinHg = msfsSdk.UnitType.HPA.convertTo(stationPressurePa / 100, msfsSdk.UnitType.IN_HG);
            const tempR = 459.67 + msfsSdk.UnitType.CELSIUS.convertTo(sat, msfsSdk.UnitType.FAHRENHEIT);
            // NWS Calculation for ASOS/AWOS
            return 145422.16 * (1 - Math.pow(17.326 * stationPressureinHg / tempR, 0.235));
        }
        /**
         * Calculate observed wind from true airspeed, ground speed, magnetic heading and magnetic track.
         * @param tas The true airspeed in KT.
         * @param gs The ground speed in KT.
         * @param heading The current magnetic heading in degrees.
         * @param track The current magnetic ground track in degrees.
         * @returns Array of [wind direction degrees mag, wind speed kt].
         */
        static calcWind(tas, gs, heading, track) {
            const headingRad = msfsSdk.UnitType.DEGREE.convertTo(heading, msfsSdk.UnitType.RADIAN);
            const trackRad = msfsSdk.UnitType.DEGREE.convertTo(track, msfsSdk.UnitType.RADIAN);
            const windComponentNorth = gs * Math.cos(trackRad) - tas * Math.cos(headingRad);
            const windComponentEast = gs * Math.sin(trackRad) - tas * Math.sin(headingRad);
            const windDirection = msfsSdk.NavMath.normalizeHeading(90 - Math.round(msfsSdk.UnitType.RADIAN.convertTo(Math.atan2(-windComponentNorth, -windComponentEast), msfsSdk.UnitType.DEGREE)));
            const windSpeed = Math.sqrt(Math.pow(windComponentNorth, 2) + Math.pow(windComponentEast, 2));
            return [windDirection, windSpeed];
        }
        /**
         * Calculate headwind and crosswind components from the current ground track, wind speed and wind direction.
         * @param track Current magnetic ground track.
         * @param windSpeed Current wind speed in kt.
         * @param windDirection Current wind direction in degrees magnetic.
         * @returns Array of [headwind component in kt (+ is headwind, - is tailwind),
         * crosswind component in kt (+ is Left crosswind, - is Right crosswind)].
         */
        static calcRelativeWindComponents(track, windSpeed, windDirection) {
            const trackRad = msfsSdk.UnitType.DEGREE.convertTo(track, msfsSdk.UnitType.RADIAN);
            const windDirectionRad = msfsSdk.UnitType.DEGREE.convertTo(windDirection, msfsSdk.UnitType.RADIAN);
            return [
                Math.round(windSpeed * (Math.cos(trackRad - windDirectionRad))),
                Math.round(windSpeed * (Math.sin(trackRad - windDirectionRad)))
            ];
        }
    }
    /** ISA temp at Sea Level in Kelvin  */
    AdcMath.slIsaTemp = 288.15;
    /** ISA pressure at Sea Level in Pascals  */
    AdcMath.slIsaPres = 101325;
    /** Specific heat ratio for air  */
    AdcMath.gamma = 1.4;
    /** Constant: gamma over gamma minus 1 */
    AdcMath.gammaOverGammaMinus1 = AdcMath.gamma / (AdcMath.gamma - 1);
    /** Constant: gamma minus 1 over gamma */
    AdcMath.gammaMinus1OverGamma = (AdcMath.gamma - 1) / AdcMath.gamma;
    /** Specific gas constant  */
    AdcMath.gas = 287.05;
    /** Specific heat ratio for air times gas constant.  */
    AdcMath.gammaGas = AdcMath.gamma * AdcMath.gas;
    /** Specific heat ratio for air times gas constant divided per cubic ft.  */
    AdcMath.gammaGasVolume = AdcMath.gammaGas / Math.pow(msfsSdk.UnitType.FOOT.convertTo(1, msfsSdk.UnitType.METER), 2);
    /** Constant: gammaGas * slIsaTemp */
    AdcMath.gammaGasSl = AdcMath.gammaGas * AdcMath.slIsaTemp;
    /** Constant: sqrt gammaGasSl * nm */
    AdcMath.sqrtGammaGasSlNm = Math.sqrt(AdcMath.gammaGasSl) * msfsSdk.UnitType.METER.convertTo(3600.0, msfsSdk.UnitType.NMILE);
    /** Constant: 5 * sqrtGammaGasSlNm squared  */
    AdcMath.sqrtGammaGasSlNmSqd5 = 5.0 * AdcMath.sqrtGammaGasSlNm * AdcMath.sqrtGammaGasSlNm;
    /** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
    AdcMath.lapseFt = 0.0019812;
    /** Fluid density of Air in kg/m^3.  */
    AdcMath.airDensity = 1.225;

    /**
     * DENSITY / ALT / TAS / WINDS
     */
    class DensityAltTasWinds extends AuxPage {
        constructor() {
            super(...arguments);
            // User Settings
            this.unitsSettingsManager = this.props.settingsProvider.units;
            this.generalSettingsManager = this.props.settingsProvider.generalSettings;
            // ADC Data
            this.adcGpsSubscriber = this.props.bus.getSubscriber();
            this.groundSpeedSub = msfsSdk.ConsumerSubject.create(this.adcGpsSubscriber.on('ground_speed'), null);
            this.magneticTrackSub = msfsSdk.ConsumerSubject.create(this.adcGpsSubscriber.on('track_deg_magnetic'), null);
            this.magvarSub = msfsSdk.ConsumerSubject.create(this.adcGpsSubscriber.on('magvar'), null);
            // Inputs
            this.indAlt = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FOOT.createNumber(0));
            this.cas = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            // FIXME we store the baro here as inHg * 100, because the digit inputs do not play well with decimals at
            //       the moment
            this.baro = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.IN_HG.createNumber(0)); // TODO hPa
            this.tat = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.CELSIUS.createNumber(0));
            this.hdg = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(0));
            // Outputs
            this.denAlt = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FOOT.createNumber(0));
            this.tas = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            this.windSpeedOut = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            this.windDirectionOut = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(0));
            this.headwind = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            this.headwindAbs = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.KNOT.createNumber(0));
            //these need to stay angle unit does not change in the units/position menu
            this.baroUnit = msfsSdk.Subject.create(msfsSdk.UnitType.IN_HG);
            this.angleUnit = msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE);
        }
        /**
         * Callback to render an inactive value.
         * @param value The value to display.
         * @param unit The display unit of the value.
         * @returns a VNODE to render.
         */
        renderInactiveValue(value, unit) {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                value,
                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: unit })));
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            // TODO re-enable this when bugs on digit inputs are fixed
            // this.indAlt.set(UnitType.FOOT.createNumber(23_597));
            // this.baro.set(UnitType.IN_HG.createNumber(29.92));
            // Calculate density altitude from inputs
            msfsSdk.MappedSubject.create(this.indAlt, this.baro, this.tat).map(([indAtl, baro, tat]) => {
                // We divide baro by 100 because we store it like this. See comment on baro field
                const denAlt = AdcMath.calcDensityAltitude(indAtl.number, baro.unit === msfsSdk.UnitType.IN_HG ? baro.number / 100 : baro.number, tat.number);
                this.denAlt.set(msfsSdk.UnitType.FOOT.createNumber(denAlt));
            });
            // Calculate TAS from inputs
            msfsSdk.MappedSubject.create(this.denAlt, this.tat, this.cas, this.baro).map(([denAlt, tat, cas, baro]) => {
                const tas = AdcMath.calcTasfromCas(denAlt.number, tat.number, cas.number, baro.unit === msfsSdk.UnitType.IN_HG ? baro.number / 100 : baro.number);
                this.tas.set(msfsSdk.UnitType.KNOT.createNumber(tas));
            });
            msfsSdk.MappedSubject.create(this.tas, this.groundSpeedSub, this.hdg, this.magneticTrackSub, this.magvarSub).map(([tas, gs, hdg, magneticTrack, magvar]) => {
                if (gs !== null && magneticTrack !== null && magvar !== null) {
                    const wind = AdcMath.calcWind(tas.asUnit(msfsSdk.UnitType.KNOT), gs, hdg.number, magneticTrack);
                    const windDirection = wind[0];
                    const windSpeed = wind[1];
                    this.windDirectionOut.set(windDirection, msfsSdk.UnitType.DEGREE);
                    this.windSpeedOut.set(windSpeed, this.unitsSettingsManager.speedUnits.get());
                    const windComponents = AdcMath.calcRelativeWindComponents(hdg.number, windSpeed, windDirection + magvar);
                    const headwind = windComponents[0];
                    this.headwind.set(headwind, this.unitsSettingsManager.speedUnits.get());
                    this.headwindAbs.set(Math.abs(headwind), this.unitsSettingsManager.speedUnits.get());
                }
            });
        }
        /**
         * Gets the unit setting of the Baro.
         * @returns Unit Type that is selected in the system.
         */
        getBaroSetting() {
            if (this.generalSettingsManager.getSetting('baroHpa')) {
                this.baroUnit.set(msfsSdk.UnitType.IN_HG);
                return this.baroUnit;
            }
            else {
                //will need to be changed
                this.baroUnit.set(msfsSdk.UnitType.IN_HG);
                return this.baroUnit;
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, class: "page aux-page hide-element" },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "DENSITY ALT / TAS / WINDS"),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels cyan", style: "padding-bottom: 2px;" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "IND ALT")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "CAS")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "BARO"))),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table datw-table' },
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.indAlt, displayUnit: this.unitsSettingsManager.altitudeUnits, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value));
                                digitValues[1].set(Math.floor((value % 10000)));
                                digitValues[2].set(Math.floor((value % 1000)));
                                digitValues[3].set(Math.floor((value % 100)));
                                digitValues[4].set(Math.floor((value % 10)));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                return this.renderInactiveValue(value.toFixed(0), this.unitsSettingsManager.altitudeUnits);
                            }, onInputAccepted: (v) => {
                                this.indAlt.set(v, this.unitsSettingsManager.altitudeUnits.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.altitudeUnits }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell", id: "trip-planning-gs" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.cas, displayUnit: this.unitsSettingsManager.speedUnits, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 100));
                                digitValues[1].set(Math.floor((value % 100) / 10));
                                digitValues[2].set(Math.floor((value % 10) / 1));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                return this.renderInactiveValue(value.toFixed(0), this.unitsSettingsManager.speedUnits);
                            }, onInputAccepted: (v) => {
                                this.cas.set(v, this.unitsSettingsManager.speedUnits.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.speedUnits }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.baro, displayUnit: this.getBaroSetting(), digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 1000) * 1000);
                                digitValues[1].set(Math.floor(((value % 1000) / 100) * 100));
                                digitValues[2].set(Math.floor(((value % 100) / 10) * 10));
                                digitValues[3].set(Math.floor((value % 10)));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                const valueStr = value.toString();
                                const a = valueStr.substring(0, 2);
                                const b = valueStr.substring(2, 4);
                                return this.renderInactiveValue(`${a}.${b}`, this.getBaroSetting());
                            }, onInputAccepted: (v) => {
                                const baroUnit = this.baroUnit.get();
                                if (baroUnit === msfsSdk.UnitType.IN_HG) {
                                    const clampedValue = Math.max(2600, Math.min(3400, v));
                                    this.baro.set(clampedValue, baroUnit);
                                }
                                else {
                                    const clampedValue = Math.max(880.5, Math.min(1151, v));
                                    this.baro.set(clampedValue, baroUnit);
                                }
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent("span", null, "."),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.baroUnit }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.tat, displayUnit: this.unitsSettingsManager.temperatureUnits, digitizer: (value, signValues, digitValues) => {
                                digitValues[2].set(Math.floor((value)));
                                digitValues[2].set(Math.floor((value % 100)));
                                digitValues[2].set(Math.floor((value % 10)));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => {
                                return this.renderInactiveValue(value.toFixed(0), this.unitsSettingsManager.temperatureUnits);
                            }, onInputAccepted: (v) => {
                                this.tat.set(v, this.unitsSettingsManager.temperatureUnits.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSSignInput, { sign: msfsSdk.Subject.create(1) }),
                            " ",
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.temperatureUnits }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.hdg, displayUnit: this.angleUnit, digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 10) * 10);
                                digitValues[1].set(Math.floor(value % 10));
                            }, editOnActivate: false, activateOnClr: true, class: '', renderInactiveValue: (value) => (msfsSdk.FSComponent.buildComponent("div", null,
                                value.toFixed(0).padStart(3, '0'),
                                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit }))), onInputAccepted: (v) => {
                                this.hdg.set(v, this.angleUnit.get());
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 36, increment: 1, scale: 10, wrap: true, formatter: (v) => v.toString().padStart(2, '0') }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit })))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels cyan", style: "padding-bottom: 3px; padding-top: 2px;" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "TAT")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "HDG")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels cyan", style: "padding-top: 3px; padding-bottom: 2px;" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DEN ALT")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "TAS"))),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table datw-table' },
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ forceSign: true, precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.denAlt, displayUnit: this.unitsSettingsManager.altitudeUnits })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.tas, displayUnit: this.unitsSettingsManager.speedUnits })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" }),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.windDirectionOut, displayUnit: msfsSdk.UnitType.DEGREE }),
                        msfsSdk.FSComponent.buildComponent("span", { class: "datw-table-at" }, "at")),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.windSpeedOut, displayUnit: this.unitsSettingsManager.speedUnits })),
                    msfsSdk.FSComponent.buildComponent("div", { class: "datw-table-cell" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.headwindAbs, displayUnit: this.unitsSettingsManager.speedUnits }))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels cyan", style: "padding-bottom: 10px; padding-top:2px;" },
                    msfsSdk.FSComponent.buildComponent("div", { style: "grid-column: span 2;" },
                        msfsSdk.FSComponent.buildComponent("span", null, "WIND")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, this.headwind.map((value) => value.number >= 0 ? 'HEAD WIND' : 'TAIL WIND'))))));
        }
    }

    /**
     * Flight planning page for Aux group of pages
     */
    class AuxFlightPlanning extends Page {
        constructor() {
            super(...arguments);
            this.page1OptionsArray = [
                {
                    label: 'Fuel Planning', disabled: false, action: () => {
                        this.changePage('fuel-planning');
                    }
                },
                {
                    label: 'Trip Planning', disabled: false, action: () => {
                        this.changePage('trip-planning');
                    }
                },
                {
                    label: 'Density Alt / TAS / Winds', disabled: false, action: () => {
                        this.changePage('density-alt-tas-winds');
                    }
                },
                {
                    label: 'Scheduler', disabled: true, action: () => {
                        //TODO finish the scheduler
                    }
                },
                {
                    label: 'Crossfill', disabled: true, action: () => {
                    }
                },
            ];
            this.menu = new AuxPageMenu();
            this.auxPageGroupRef = msfsSdk.FSComponent.createRef();
            this.page1Options = msfsSdk.ArraySubject.create(this.page1OptionsArray);
            this.auxFlightPlanningMenuItems = msfsSdk.FSComponent.createRef();
            /**
             * Picks the next page to be loaded
             * @param listMenuItem the menuEntry
             * @returns if the page has been loaded
             */
            this.onListItemSelected = (listMenuItem) => {
                const menuEntry = listMenuItem.props.data;
                if (menuEntry !== null) {
                    if (menuEntry.action instanceof msfsSdk.Subject) {
                        const action = menuEntry.action.get();
                        action();
                    }
                    else {
                        menuEntry.action();
                    }
                }
                return true;
            };
            this.onSubpageClr = () => {
                const list = this.auxFlightPlanningMenuItems.instance;
                this.auxPageGroup.blur();
                this.onResume();
                list.focus(msfsSdk.FocusPosition.MostRecent);
            };
        }
        /**
         * Return the aux page group in this page
         *
         * @returns the aux page group
         */
        get auxPageGroup() {
            return this.auxPageGroupRef.instance;
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            const list = this.auxFlightPlanningMenuItems.instance;
            if (this.auxPageGroup.currentPageFocused()) {
                return this.auxPageGroup.onInteractionEvent(evt);
            }
            if (evt === InteractionEvent.RightKnobPush) {
                if (!list.isFocused) {
                    list.focus(msfsSdk.FocusPosition.MostRecent);
                }
                else {
                    list.blur();
                }
                return true;
            }
            else if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.menu);
                return true;
            }
            let handled = false;
            if (this.auxFlightPlanningMenuItems.instance.isFocused) {
                handled = this.auxFlightPlanningMenuItems.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (([InteractionEvent.RightOuterInc, InteractionEvent.RightOuterDec, InteractionEvent.RightInnerDec, InteractionEvent.RightInnerInc].includes(evt))) {
                return this.auxFlightPlanningMenuItems.instance.isFocused;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritDoc */
        get isActive() {
            var _a, _b, _c;
            return super.isActive || ((_c = (_b = (_a = this.auxPageGroup) === null || _a === void 0 ? void 0 : _a.currentPage) === null || _b === void 0 ? void 0 : _b.isVisible) !== null && _c !== void 0 ? _c : false);
        }
        /** @inheritDoc */
        onSuspend() {
            super.onSuspend();
            this.auxPageGroup.blur();
        }
        /**
         * Change the currently displayed page of the aux page group
         *
         * @param key the page key
         */
        changePage(key) {
            this.onSuspend();
            this.auxPageGroup.setPage(key);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                msfsSdk.FSComponent.buildComponent("div", { class: 'page aux-page hide-element', ref: this.el },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "FLIGHT PLANNING")),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table aux-table-full-width aux-table-full-height' },
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.page1Options, renderItem: (data) => msfsSdk.FSComponent.buildComponent(PageMenuItem, { data: data, onSelected: this.onListItemSelected }), ref: this.auxFlightPlanningMenuItems, hideScrollbar: true, class: "aux-page-menu-list" }))),
                msfsSdk.FSComponent.buildComponent(AuxPageGroup, { ref: this.auxPageGroupRef },
                    msfsSdk.FSComponent.buildComponent(FuelPlanning, { key: 'fuel-planning', bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(TripPlanning, { key: 'trip-planning', bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(DensityAltTasWinds, { key: 'density-alt-tas-winds', bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }))));
        }
    }

    /**
     * A control that allows a selection on a waypoint procedure page.
     *
     * TODO move this to Dialogs/ and extend Dialog<T> instead
     */
    class OptionDialog extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.selectedItem = msfsSdk.Subject.create('NONE');
            this.items = msfsSdk.ArraySubject.create();
            this.itemsList = msfsSdk.FSComponent.createRef();
            this.popout = msfsSdk.FSComponent.createRef();
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.closePopout();
        }
        /**
         * Sets the available items in the selector.
         * @param items The items available in the selector.
         * @param notify Whether or not to notify onSelected.
         */
        setItems(items, notify = true) {
            this.items.clear();
            this.items.insertRange(0, items);
            if (items.length !== 0) {
                this.selectedItem.set(this.items.get(0));
                this.setDisabled(false);
                notify && this.props.onSelected(0, true);
            }
            else {
                this.selectedItem.set('NONE');
                this.setDisabled(true);
                notify && this.props.onSelected(-1, true);
            }
        }
        /**
         * Handles when an item is selected in the list.
         * @param index The index of the selected item.
         */
        onItemSelected(index) {
            this.closePopout();
            this.props.onClosed && this.props.onClosed();
            this.selectedItem.set(this.items.get(index));
            this.props.onSelected(index, false);
            this.scroll('forward');
        }
        /** @inheritDoc */
        onClr() {
            if (this.itemsList.instance.isFocused) {
                this.closePopout();
                this.props.onClosed && this.props.onClosed();
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        onRightInnerInc() {
            if (this.itemsList.instance.isFocused) {
                this.scroll('forward');
            }
            else {
                this.openPopout();
            }
            return true;
        }
        /** @inheritDoc */
        onRightInnerDec() {
            if (this.itemsList.instance.isFocused) {
                this.scroll('backward');
            }
            else {
                this.openPopout();
            }
            return true;
        }
        /** @inheritDoc */
        onRightKnobPush() {
            if (this.itemsList.instance.isFocused) {
                this.closePopout();
                this.props.onClosed && this.props.onClosed();
                return true;
            }
            return true;
        }
        /**
         * Opens the item selection popout, optionally to a selected index.
         * @param focusedIndex Index to focus; by default most recent.
         */
        openPopout(focusedIndex) {
            const parent = this.popout.instance.parentElement;
            if (parent !== null) {
                const rect = parent.getBoundingClientRect();
                this.popout.instance.style.top = `${rect.top + 24}px`;
            }
            this.itemsList.instance.setDisabled(false);
            this.popout.instance.classList.remove('hide-element');
            if (focusedIndex !== undefined) {
                const child = this.itemsList.instance.getChild(focusedIndex);
                if (child !== undefined) {
                    child.focus(msfsSdk.FocusPosition.MostRecent);
                    this.selectedItem.set(this.items.get(focusedIndex));
                }
            }
            else {
                this.itemsList.instance.focus(msfsSdk.FocusPosition.MostRecent);
            }
        }
        /**
         * Selects the item index.
         * @param index The index we want to select.
         */
        setSelectedItem(index) {
            if (index < this.items.length && index >= 0) {
                this.selectedItem.set(this.items.get(index));
                this.itemsList.instance.setFocusedIndex(index);
            }
        }
        /**
         * Closes the item selection popout.
         */
        closePopout() {
            this.itemsList.instance.setDisabled(true);
            this.popout.instance.classList.add('hide-element');
            this.focus(msfsSdk.FocusPosition.None);
        }
        /** @inheritDoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `option-dialog ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfsSdk.FSComponent.buildComponent("div", { class: 'dialog-box', ref: this.popout },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'dialog-box-inner' },
                        msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, this.props.label),
                        msfsSdk.FSComponent.buildComponent("hr", null),
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { ref: this.itemsList, class: 'dialog-box-items', data: this.items, innerKnobScroll: true, isolateScroll: true, renderItem: (label, index) => msfsSdk.FSComponent.buildComponent(OptionDialogItem, { label: label, onSelected: () => this.onItemSelected(index) }) })))));
        }
    }
    /**
     * An item in the option dialog selector list.
     */
    class OptionDialogItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritDoc */
        onFocused() {
            this.el.instance.classList.add('selected-white');
        }
        /** @inheritDoc */
        onBlurred() {
            this.el.instance.classList.remove('selected-white');
        }
        /** @inheritDoc */
        onEnt() {
            this.props.onSelected();
            return true;
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'option-dialog-item', ref: this.el }, this.props.label));
        }
    }

    /**
     * DISPLAY BACKLIGHT page menu
     */
    class DisplayBacklightMenu extends MenuDefinition {
        /**
         * Ctor
         *
         * @param page the display backlight page instance
         */
        constructor(page) {
            super();
            this.page = page;
            this.entries = [
                {
                    label: 'Reset Defaults?',
                    disabled: msfsSdk.Subject.create(false),
                    action: () => {
                        this.page.resetDefaults();
                        ViewService.back();
                    },
                },
            ];
        }
        /** @inheritDoc */
        updateEntries() {
            // noop
        }
    }
    /**
     * Backlight control modes
     */
    var BacklightMode;
    (function (BacklightMode) {
        BacklightMode["Auto"] = "Auto";
        BacklightMode["Manual"] = "Manual";
    })(BacklightMode || (BacklightMode = {}));
    /**
     * DISPLAY BACKLIGHT page
     */
    class DisplayBacklight extends AuxPage {
        /** @inheritDoc */
        constructor(props) {
            var _a, _b, _c;
            super(props);
            this.menu = new DisplayBacklightMenu(this);
            this.scrollContainerRef = msfsSdk.FSComponent.createRef();
            this.scrollContainerRef2 = msfsSdk.FSComponent.createRef();
            this.modeRef = msfsSdk.FSComponent.createRef();
            this.modeRef2 = msfsSdk.FSComponent.createRef();
            this.dialogRef = msfsSdk.FSComponent.createRef();
            this.mode = msfsSdk.Subject.create(BacklightMode.Auto);
            this.brightness = msfsSdk.Subject.create(8000);
            // Figure out the manual brightness LVars based on the provided panel XML config
            const xml = this.props.xmlConfig;
            const targetName = this.props.gnsType === 'wt530' ? 'AS530' : 'AS430';
            const instrumentTags = Array.from(xml.querySelectorAll('Instrument'));
            const matchingInstrumentTag = instrumentTags.find((it) => { var _a, _b; return ((_b = (_a = it.querySelector('Name')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) === targetName; });
            const name = (_a = matchingInstrumentTag === null || matchingInstrumentTag === void 0 ? void 0 : matchingInstrumentTag.querySelector('Name')) === null || _a === void 0 ? void 0 : _a.textContent;
            const comIndex = (_b = matchingInstrumentTag === null || matchingInstrumentTag === void 0 ? void 0 : matchingInstrumentTag.querySelector('ComIndex')) === null || _b === void 0 ? void 0 : _b.textContent;
            const navIndex = (_c = matchingInstrumentTag === null || matchingInstrumentTag === void 0 ? void 0 : matchingInstrumentTag.querySelector('NavIndex')) === null || _c === void 0 ? void 0 : _c.textContent;
            if (name !== undefined && comIndex !== undefined && navIndex !== undefined) {
                this.manualBrightnessEnabledLVar = `L:${name}_ManualBrightness_Enabled${navIndex}_${comIndex}`;
                this.manualBrightnessValueLVar = `L:${name}_ManualBrightness_Value${navIndex}_${comIndex}`;
            }
        }
        /** @inheritDoc */
        focus(focusPosition) {
            return this.scrollContainerRef.instance.focus(focusPosition);
        }
        /**
         * Resets settings to default
         */
        resetDefaults() {
            this.mode.set(BacklightMode.Auto);
            this.brightness.set(8000);
        }
        /**
         * Updates the backlight related LVars
         */
        updateToLVars() {
            // If the LVars do not exist, we do nothing
            if (!this.manualBrightnessEnabledLVar || !this.manualBrightnessValueLVar) {
                return;
            }
            const mode = this.mode.get();
            if (mode === BacklightMode.Auto) {
                SimVar.SetSimVarValue(this.manualBrightnessEnabledLVar, 'Boolean', false);
            }
            else {
                const brightness = this.brightness.get();
                SimVar.SetSimVarValue(this.manualBrightnessEnabledLVar, 'Boolean', true);
                SimVar.SetSimVarValue(this.manualBrightnessValueLVar, 'percent over 100', brightness);
            }
        }
        /**
         * handles opening the popup
         *
         * @returns true
         */
        handleOpenPopup() {
            this.scrollContainerRef.instance.blur();
            this.dialogRef.instance.openPopout(0);
            this.dialogRef.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * handles opening the popup
         *
         * @returns true
         */
        handleClosePopup() {
            this.dialogRef.instance.closePopout();
            this.dialogRef.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * Handles incrementing the brightness by 1
         *
         * @returns true
         */
        handleIncrementBrightness() {
            const value = this.brightness.get();
            this.brightness.set(Math.min(8000, value + 1));
            return true;
        }
        /**
         * Handles decrementing the brightness by 1
         *
         * @returns true
         */
        handleDecrementBrightness() {
            const value = this.brightness.get();
            this.brightness.set(Math.min(8000, value - 1));
            return true;
        }
        /**
         * Handles changing the backlight mode using the dialog
         *
         * @param mode the new mode to set
         */
        handleModChange(mode) {
            this.mode.set(mode);
            if (mode === BacklightMode.Auto) {
                this.modeRef.instance.setIsolated(true);
            }
            else {
                this.modeRef.instance.setIsolated(false);
            }
            this.handleClosePopup();
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.dialogRef.instance.setItems([BacklightMode.Auto, BacklightMode.Manual]);
            // Update backlight LVars every time mode or brightness change
            msfsSdk.CombinedSubject.create(this.mode, this.brightness).sub(() => this.updateToLVars());
        }
        /**
         * Renders the Contrast in the display in the 430
         * @returns a div that will render certain controls
         */
        renderContrast() {
            if (this.props.gnsType === 'wt430') {
                return (msfsSdk.FSComponent.buildComponent("div", null,
                    msfsSdk.FSComponent.buildComponent("div", { class: "display-backlight-table-header2 cyan" },
                        msfsSdk.FSComponent.buildComponent("span", null, "MODE"),
                        msfsSdk.FSComponent.buildComponent("span", null, this.props.gnsType === 'wt430' ? 'LVL' : 'LEVEL')),
                    msfsSdk.FSComponent.buildComponent("div", { class: "display-backlight-side-title2 cyan" }, "CONTRAST"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table display-backlight-table2" },
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.scrollContainerRef2, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.modeRef2, class: "aux-entry display-backlight-mode2", data: this.mode, onRightInnerInc: this.handleOpenPopup.bind(this), onRightInnerDec: this.handleOpenPopup.bind(this) }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { class: "aux-entry display-backlight-brightness2", data: this.brightness.map((it) => it.toString()), onRightInnerInc: this.handleIncrementBrightness.bind(this), onRightInnerDec: this.handleDecrementBrightness.bind(this) })),
                        msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.dialogRef, class: "backlight-mode-option-dialog", label: "MODE", onSelected: (index) => this.handleModChange(index === 0 ? BacklightMode.Auto : BacklightMode.Manual) }))));
            }
            else {
                return (msfsSdk.FSComponent.buildComponent("div", null));
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page aux-page hide-element", ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "DISPLAY"),
                msfsSdk.FSComponent.buildComponent("div", { class: "display-backlight-container" },
                    msfsSdk.FSComponent.buildComponent("div", null),
                    msfsSdk.FSComponent.buildComponent("div", { class: "display-backlight-table-header cyan" },
                        msfsSdk.FSComponent.buildComponent("span", null, "MODE"),
                        msfsSdk.FSComponent.buildComponent("span", null, this.props.gnsType === 'wt430' ? 'LVL' : 'LEVEL')),
                    msfsSdk.FSComponent.buildComponent("div", { class: "display-backlight-side-title cyan" }, "BACKLIGHT"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table display-backlight-table" },
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.scrollContainerRef, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.modeRef, class: "aux-entry display-backlight-mode", data: this.mode, onRightInnerInc: this.handleOpenPopup.bind(this), onRightInnerDec: this.handleOpenPopup.bind(this) }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { class: "aux-entry display-backlight-brightness", data: this.brightness.map((it) => it.toString()), onRightInnerInc: this.handleIncrementBrightness.bind(this), onRightInnerDec: this.handleDecrementBrightness.bind(this) })),
                        msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.dialogRef, class: "backlight-mode-option-dialog", label: "MODE", onSelected: (index) => this.handleModChange(index === 0 ? BacklightMode.Auto : BacklightMode.Manual) })),
                    this.renderContrast())));
        }
    }

    /**
     * DISPLAY BACKLIGHT page menu
     */
    class NearestAirportCriteriaMenu extends MenuDefinition {
        /**
         * Ctor
         *
         * @param page the display backlight page instance
         */
        constructor(page) {
            super();
            this.page = page;
            this.entries = [
                {
                    label: 'Reset Defaults?',
                    disabled: msfsSdk.Subject.create(false),
                    action: () => {
                        this.page.resetDefaults();
                        ViewService.back();
                    },
                },
            ];
        }
        /** @inheritDoc */
        updateEntries() {
            // noop
        }
    }
    const SURFACE_TYPE_OPTION_NAME_LIST = {
        [SurfaceTypeOption.Any]: 'Any',
        [SurfaceTypeOption.HardOnly]: 'Hard Only',
        [SurfaceTypeOption.HardOrSoft]: 'Hard/Soft',
        [SurfaceTypeOption.Water]: 'Water',
    };
    /**
     * NEAREST AIRPORT CRITERIA page
     */
    class NearestAirportCriteria extends AuxPage {
        constructor() {
            super(...arguments);
            this.menu = new NearestAirportCriteriaMenu(this);
            this.dialogRef = msfsSdk.FSComponent.createRef();
            this.generalSettingsManager = GeneralUserSettingsManager.getManager(this.props.bus);
            this.surfaceTypeSetting = this.generalSettingsManager.getSetting('nearest_airport_criteria_surface_type');
            this.minimumLengthSetting = this.generalSettingsManager.getSetting('nearest_airport_criteria_min_length');
            this.minimumLengthNumberUnitSub = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FOOT.createNumber(0));
        }
        /**
         * Resets settings to default
         */
        resetDefaults() {
            this.surfaceTypeSetting.set(SurfaceTypeOption.Any);
            this.minimumLengthSetting.set(0);
        }
        /**
         * handles opening the popup
         *
         * @returns true
         */
        handleOpenPopup() {
            this.dialogRef.instance.openPopout(0);
            this.dialogRef.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * handles opening the popup
         *
         * @returns true
         */
        handleClosePopup() {
            this.dialogRef.instance.closePopout();
            this.dialogRef.instance.blur();
            return true;
        }
        /**
         * Handles a surface type being selected in the dialog
         *
         * @param index the surface type, index of {@link SurfaceTypeOption}
         */
        handleSelectSurfaceType(index) {
            this.surfaceTypeSetting.set(index);
            this.handleClosePopup();
        }
        /**
         * Handles a minimum length being input
         *
         * @param length the minimum length
         */
        handleSelectMinimumLength(length) {
            this.minimumLengthSetting.set(length);
            this.handleClosePopup();
        }
        /**
         * Callback to render an inactive value.
         * @param value The value to display.
         * @param unit The display unit of the value.
         * @returns a VNODE to render.
         */
        renderInactiveValue(value, unit) {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                value,
                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: unit })));
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.dialogRef.instance.setItems(Object.values(SURFACE_TYPE_OPTION_NAME_LIST));
            this.minimumLengthSetting.sub((value) => this.minimumLengthNumberUnitSub.set(value));
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page aux-page hide-element", ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "NEAREST AIRPORT CRITERIA"),
                msfsSdk.FSComponent.buildComponent("div", { class: "nearest-airport-criteria-container" },
                    msfsSdk.FSComponent.buildComponent("div", { class: "nearest-airport-criteria-side-title cyan" }, "RUNWAY SURFACE"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table nearest-airport-criteria-table" },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { class: "aux-entry nearest-airport-criteria-surface", data: this.surfaceTypeSetting.map((it) => SURFACE_TYPE_OPTION_NAME_LIST[it]), onRightInnerInc: this.handleOpenPopup.bind(this), onRightInnerDec: this.handleOpenPopup.bind(this) }),
                        msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.dialogRef, class: "nearest-airport-criteria-option-dialog", label: "SURFACE TYPE", onSelected: (index) => this.handleSelectSurfaceType(index) })),
                    msfsSdk.FSComponent.buildComponent("div", null),
                    msfsSdk.FSComponent.buildComponent("div", null),
                    msfsSdk.FSComponent.buildComponent("div", { class: "nearest-airport-criteria-side-title cyan" }, "MINIMUM LENGTH"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table nearest-airport-criteria-table" },
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { class: "aux-entry nearest-airport-criteria-surface", data: this.minimumLengthNumberUnitSub, displayUnit: msfsSdk.Subject.create(msfsSdk.UnitType.FOOT), digitizer: (value, signValues, digitValues) => {
                                digitValues[0].set(Math.floor(value / 10000) * 10000);
                                digitValues[1].set(Math.floor(value / 1000) % 10 * 1000);
                                digitValues[2].set(Math.floor(value / 100) % 10 * 100);
                                digitValues[3].set(Math.floor(value / 10) % 10 * 10);
                                digitValues[4].set(value % 10);
                            }, editOnActivate: false, activateOnClr: true, renderInactiveValue: (value) => {
                                return this.renderInactiveValue(value.toFixed(0), msfsSdk.Subject.create(msfsSdk.UnitType.FOOT));
                            }, onInputAccepted: (value) => {
                                this.handleSelectMinimumLength(value);
                            } },
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.UnitType.FOOT }))))));
        }
    }

    const COM_FREQUENCY_SPACING_NAME_LIST = {
        [msfsSdk.ComSpacing.Spacing833Khz]: '8.33 kHz',
        [msfsSdk.ComSpacing.Spacing25Khz]: '25.0 kHz',
    };
    /**
     * COM CONFIGURATION page
     */
    class ComConfiguration extends AuxPage {
        constructor() {
            super(...arguments);
            this.scrollContainerRef = msfsSdk.FSComponent.createRef();
            this.dialogRef = msfsSdk.FSComponent.createRef();
            this.generalSettings = GeneralUserSettingsManager.getManager(this.props.bus);
            this.comFrequencySpacingSetting = this.generalSettings.getSetting('com_frequency_spacing');
        }
        /**
         * handles opening the popup
         *
         * @returns true
         */
        handleOpenPopup() {
            this.scrollContainerRef.instance.blur();
            this.dialogRef.instance.openPopout(0);
            this.dialogRef.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * handles opening the popup
         *
         * @returns true
         */
        handleClosePopup() {
            this.dialogRef.instance.closePopout();
            this.dialogRef.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * Handles changing the COM spacing mode using the dialog
         *
         * @param mode the new mode to set
         */
        handleModeChange(mode) {
            this.comFrequencySpacingSetting.set(mode);
            this.handleClosePopup();
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.dialogRef.instance.setItems(Object.values(COM_FREQUENCY_SPACING_NAME_LIST));
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page aux-page hide-element", ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "COM CONFIGURATION"),
                msfsSdk.FSComponent.buildComponent("div", { class: "com-configuration-container" },
                    msfsSdk.FSComponent.buildComponent("div", { class: "com-configuration-side-title cyan" }, "CHANNEL SPACING"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table com-configuration-table" },
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.scrollContainerRef, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent(SelectableText, { class: "aux-entry com-configuration-spacing", data: this.comFrequencySpacingSetting.map((it) => COM_FREQUENCY_SPACING_NAME_LIST[it]), onRightInnerInc: this.handleOpenPopup.bind(this), onRightInnerDec: this.handleOpenPopup.bind(this) })),
                        msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.dialogRef, class: "com-configuration-dialog", label: "SPACING", onSelected: (index) => this.handleModeChange(index === 1 ? msfsSdk.ComSpacing.Spacing833Khz : msfsSdk.ComSpacing.Spacing25Khz) })))));
        }
    }

    /**
     * A control that allows a selection on a waypoint procedure page.
     */
    class WaypointPageSelector extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.selectedItem = msfsSdk.Subject.create('NONE');
            this.items = msfsSdk.ArraySubject.create();
            this.itemsList = msfsSdk.FSComponent.createRef();
            this.popout = msfsSdk.FSComponent.createRef();
            this.selection = msfsSdk.FSComponent.createRef();
        }
        /**
         * Gets the current number of items in the items list.
         * @returns The current number of items in the items list.
         */
        get listLength() {
            return this.items.length;
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.closePopout();
            this.onBlurred();
        }
        /**
         * Sets the available items in the selector.
         * @param items The items available in the selector.
         */
        setItems(items) {
            this.items.clear();
            this.items.insertRange(0, items);
            if (items.length !== 0) {
                this.selectedItem.set(this.items.get(0));
                this.setDisabled(false);
            }
            else {
                this.selectedItem.set('NONE');
                this.setDisabled(true);
            }
        }
        /**
         * Handles when an item is selected in the list.
         * @param index The index of the selected item.
         */
        onItemSelected(index) {
            this.closePopout();
            this.selectedItem.set(this.items.get(index));
            this.props.onSelected(index);
            this.scroll('forward');
        }
        /** @inheritdoc */
        onFocused() {
            this.selection.instance.classList.add('selected');
            this.selection.instance.classList.remove('paused');
        }
        /** @inheritdoc */
        onBlurred() {
            this.selection.instance.classList.remove('selected');
        }
        /**
         * Pauses selection animations.
         */
        pauseAnimations() {
            this.selection.instance.classList.add('paused');
        }
        /** @inheritdoc */
        onClr() {
            if (this.itemsList.instance.isFocused) {
                this.closePopout();
                return true;
            }
            return false;
        }
        /** @inheritdoc */
        onRightInnerInc() {
            if (this.itemsList.instance.isFocused) {
                this.scroll('forward');
            }
            else {
                this.openPopout();
            }
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            if (this.itemsList.instance.isFocused) {
                this.scroll('backward');
            }
            else {
                this.openPopout();
            }
            return true;
        }
        /**
         * Opens the item selection popout, optionally to a selected index.
         * @param focusedIndex Index to focus; by default most recent.
         */
        openPopout(focusedIndex) {
            const parent = this.popout.instance.parentElement;
            if (parent !== null) {
                const rect = parent.getBoundingClientRect();
                this.popout.instance.style.top = `${rect.top + 24}px`;
            }
            this.itemsList.instance.setDisabled(false);
            this.popout.instance.classList.remove('hide-element');
            if (focusedIndex !== undefined) {
                const child = this.itemsList.instance.getChild(focusedIndex);
                if (child !== undefined) {
                    child.focus(msfsSdk.FocusPosition.MostRecent);
                    this.selectedItem.set(this.items.get(focusedIndex));
                }
            }
            else {
                this.itemsList.instance.focus(msfsSdk.FocusPosition.MostRecent);
            }
            setTimeout(() => this.pauseAnimations());
        }
        /**
         * Selects the item index.
         * @param index The index we want to select.
         * @param notify Whether or not to notify onSelected.
         */
        setSelectedItem(index, notify = true) {
            if (index < this.items.length && index >= 0) {
                this.selectedItem.set(this.items.get(index));
                this.itemsList.instance.setFocusedIndex(index);
                notify && this.props.onSelected(index);
            }
        }
        /**
         * Closes the item selection popout.
         */
        closePopout() {
            this.itemsList.instance.setDisabled(true);
            this.popout.instance.classList.add('hide-element');
            this.focus(msfsSdk.FocusPosition.None);
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `waypoint-page-selector ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-selector-label' }, this.props.label),
                msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-selector-box' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-selector-selected', ref: this.selection }, this.selectedItem)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'dialog-box', ref: this.popout },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'dialog-box-inner' },
                        msfsSdk.FSComponent.buildComponent("h2", null, this.props.label),
                        msfsSdk.FSComponent.buildComponent("hr", null),
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.items, ref: this.itemsList, innerKnobScroll: true, isolateScroll: true, class: 'waypoint-page-selector-items', renderItem: (label, index) => msfsSdk.FSComponent.buildComponent(WaypointPageSelectorItem, { label: label, onSelected: () => this.onItemSelected(index) }), onRightKnobPush: () => this.onClr() })))));
        }
    }
    /**
     * An item in the waypoint page selector list.
     */
    class WaypointPageSelectorItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onFocused() {
            this.el.instance.classList.add('selected-white');
        }
        /** @inheritdoc */
        onBlurred() {
            this.el.instance.classList.remove('selected-white');
        }
        /** @inheritdoc */
        onEnt() {
            this.props.onSelected();
            return true;
        }
        /**
         * Renders if there is a GPS vertical unit for the given selector.
         * @returns The Vertical units for GPS
         */
        renderText() {
            if (this.props.label.endsWith('GPS')) {
                return (msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-selector-item', ref: this.el },
                    this.props.label.slice(0, -4),
                    "\u00C9"));
            }
            else {
                return (msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-selector-item', ref: this.el }, this.props.label));
            }
        }
        /** @inheritdoc */
        render() {
            return (this.renderText());
        }
    }

    /**
     * menu button popups barebones since no options are selectable in AUX menus
     */
    class DateTimePageMenu extends MenuDefinition {
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        constructor(restoreDefaultValues) {
            super();
            this.restoreDefaultValues = restoreDefaultValues;
            this.entries = [
                { label: 'Restore Defaults?', disabled: msfsSdk.Subject.create(false), action: () => { this.restoreDefaultValues(); ViewService.back(); } },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * The WaypointNonDirectionalBeacon page
     */
    class DateTimePage extends AuxPage {
        constructor() {
            super(...arguments);
            this.menu = new DateTimePageMenu(() => {
                return this.restoreDefaultValues();
            });
            this.dateTimeSettingManager = msfsGarminsdk.DateTimeUserSettings.getManager(this.props.bus);
            this.dateTimeFormatSub = msfsSdk.ConsumerSubject.create(this.dateTimeSettingManager.whenSettingChanged('dateTimeFormat'), this.dateTimeSettingManager.getSetting('dateTimeFormat').value);
            this.timeFormat = msfsSdk.FSComponent.createRef();
            this.timeUnit = msfsSdk.Subject.create(msfsSdk.UnitType.SECOND);
            this.offsetInput = msfsSdk.FSComponent.createRef();
            this.offset = msfsSdk.Subject.create(0);
            this.time = msfsSdk.FSComponent.createRef();
            this.date = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '';
                }
                const month = v.substring(4, 7).toUpperCase();
                const day = v.substring(7, 10);
                const year = v.substring(13, 15);
                return day + '-' + month + '-' + year;
            });
            this.timerStr = msfsSdk.Subject.create('0:00:00');
        }
        /** @inheritdoc */
        onAfterRender(node) {
            this.timeFormat.instance.setItems(['Local 12 Hour', 'Local 24 Hour', 'UTC']);
            this.date.set(Date());
            super.onAfterRender(node);
        }
        /**
         * When the Time formate changes this will auto change the Date and Time Fields.
         * @param index index of the option selected
         */
        timeFormatChanged(index) {
            if (index === 0) {
                this.dateTimeSettingManager.getSetting('dateTimeFormat').set(msfsGarminsdk.DateTimeFormatSettingMode.Local12);
                this.time.instance.props.format = msfsGarminsdk.TimeDisplayFormat.Local12;
            }
            if (index == 1) {
                this.dateTimeSettingManager.getSetting('dateTimeFormat').set(msfsGarminsdk.DateTimeFormatSettingMode.Local24);
                this.time.instance.props.format = msfsGarminsdk.TimeDisplayFormat.Local24;
            }
            if (index == 2) {
                this.dateTimeSettingManager.getSetting('dateTimeFormat').set(msfsGarminsdk.DateTimeFormatSettingMode.UTC);
                this.time.instance.props.format = msfsGarminsdk.TimeDisplayFormat.UTC;
            }
        }
        /**
         * Sets the offset
         * @param v The offset being set
         */
        onOffsetAccepted(v) {
            let hours = '0';
            let mins = '0';
            let milliTime = 0;
            let posOffset = true;
            if (v < 0) {
                posOffset = false;
            }
            const numberString = String(v);
            if (numberString.length === 4) {
                hours = numberString.slice(0, 2);
                mins = numberString.slice(2, 4);
            }
            else if (numberString.length === 3) {
                hours = numberString.slice(0, 1);
                mins = numberString.slice(1, 3);
            }
            else if (numberString.length === 2) {
                mins = numberString.slice(0, 2);
            }
            else if (numberString.length === 1) {
                mins = numberString.slice(0, 1);
            }
            // The hours portion is negative already if we have a negative offset due to the string parsing,
            // but minutes will need to be inverted manually.
            if (hours != '0' || mins != '0') {
                milliTime = ((Number(hours) * 3600000) + (Number(mins) * 60000 * (posOffset ? 1 : -1)));
            }
            this.offset.set(milliTime);
            this.dateTimeSettingManager.getSetting('dateTimeLocalOffset').set(milliTime);
        }
        /**
         * Sets the time format to 24 hours and the offset back to 0 (defaults).
         */
        restoreDefaultValues() {
            this.dateTimeSettingManager.getSetting('dateTimeFormat').set(msfsGarminsdk.DateTimeFormatSettingMode.Local24);
            this.time.instance.props.format = msfsGarminsdk.TimeDisplayFormat.Local24;
            this.offset.set(0);
            this.dateTimeSettingManager.getSetting('dateTimeLocalOffset').set(0);
            this.onOffsetAccepted(0);
            this.timeFormatChanged(1);
            this.timeFormat.instance.setSelectedItem(1);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page date-time-page hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-header' },
                    msfsSdk.FSComponent.buildComponent("h2", null, "DATE / TIME")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-date' },
                    "DATE",
                    msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-date-div' }, this.date)),
                msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-time' },
                    "TIME",
                    msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-time-div' },
                        msfsSdk.FSComponent.buildComponent(GNSTimeDisplay, { ref: this.time, time: msfsSdk.ConsumerSubject.create(this.props.bus.getSubscriber().on('simTime'), 0), format: this.dateTimeFormatSub.map(setting => {
                                return DateTimePage.FORMAT_SETTING_MAP[setting];
                            }), localOffset: msfsSdk.ConsumerSubject.create(this.dateTimeSettingManager.whenSettingChanged('dateTimeLocalOffset'), this.dateTimeSettingManager.getSetting('dateTimeLocalOffset').value), class: 'utc-time-display size20' }))),
                msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-time-format' },
                    msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'time-format', label: 'TIME FORMAT', onSelected: this.timeFormatChanged.bind(this), ref: this.timeFormat })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-time-offset' },
                    "TIME OFFSET",
                    msfsSdk.FSComponent.buildComponent("div", { class: 'date-time-page-time-offset-div' },
                        msfsSdk.FSComponent.buildComponent(GNSGenericNumberInput, { value: this.offset, ref: this.offsetInput, onInputAccepted: (v) => { this.onOffsetAccepted(v); }, activateOnClr: true },
                            msfsSdk.FSComponent.buildComponent(GNSSignInput, { sign: msfsSdk.Subject.create(1) }),
                            " ",
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 24, increment: 1, scale: 100, wrap: true }),
                            msfsSdk.FSComponent.buildComponent("span", null, ":"),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 6, increment: 1, scale: 10, wrap: true }),
                            msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }))))));
        }
    }
    DateTimePage.FORMAT_SETTING_MAP = {
        [msfsGarminsdk.DateTimeFormatSettingMode.Local12]: msfsGarminsdk.TimeDisplayFormat.Local12,
        [msfsGarminsdk.DateTimeFormatSettingMode.Local24]: msfsGarminsdk.TimeDisplayFormat.Local24,
        [msfsGarminsdk.DateTimeFormatSettingMode.UTC]: msfsGarminsdk.TimeDisplayFormat.UTC
    };

    var HeadingSetting;
    (function (HeadingSetting) {
        HeadingSetting["Magnetic"] = "Magnetic";
        HeadingSetting["True"] = "True";
    })(HeadingSetting || (HeadingSetting = {}));
    var DisSpdUnits;
    (function (DisSpdUnits) {
        DisSpdUnits["Metric"] = "Metric (km, kph)";
        DisSpdUnits["Nautical"] = "Nautical (nm, kt)";
        DisSpdUnits["Statute"] = "Statute (mi, mph)";
    })(DisSpdUnits || (DisSpdUnits = {}));
    var AltVs;
    (function (AltVs) {
        AltVs["Feet"] = "Feet (ft, fpm)";
        AltVs["Meters"] = "Meters (m, mpm)";
        AltVs["Meters2"] = "Meters (m, mps)";
    })(AltVs || (AltVs = {}));
    var Pressure;
    (function (Pressure) {
        Pressure["Inches"] = "Inches (hg)";
        Pressure["Millibars"] = "Millibars (mb)";
    })(Pressure || (Pressure = {}));
    var Temp;
    (function (Temp) {
        Temp["Celsius"] = "Celsius (C)";
        Temp["Fahrenheit"] = "Fahrenheit (F)";
    })(Temp || (Temp = {}));
    var Fuel;
    (function (Fuel) {
        Fuel["Gallons"] = "Gallons (gl)";
        Fuel["ImpGals"] = "Imp Gals (ig)";
        Fuel["Kilograms"] = "Kilograms (kg)";
        Fuel["Liters"] = "Liters (lt)";
        Fuel["Pounds"] = "Pounds (lb)";
    })(Fuel || (Fuel = {}));
    var positionFormat$1;
    (function (positionFormat) {
        positionFormat["hdddmmmmm"] = "hddd\u00B0 mm.mmm'";
        positionFormat["hdddmmsss"] = "hddd\u00B0mm'ss.s\"";
        positionFormat["MGRS"] = "MGRS";
        positionFormat["UTMUPS"] = "UTM/UPS";
    })(positionFormat$1 || (positionFormat$1 = {}));
    /**
     * Units / Position page.
     */
    class UnitsPosition extends AuxPage {
        constructor() {
            super(...arguments);
            this.scrollContainerRef = msfsSdk.FSComponent.createRef();
            this.unitsSettingsManager = this.props.settingsProvider.units;
            this.generalSettingsManager = this.props.settingsProvider.generalSettings;
            //all selectable text
            this.headingModeRef = msfsSdk.FSComponent.createRef();
            this.disSpdModeRef = msfsSdk.FSComponent.createRef();
            this.altVsModeRef = msfsSdk.FSComponent.createRef();
            this.pressureModeRef = msfsSdk.FSComponent.createRef();
            this.tempModeRef = msfsSdk.FSComponent.createRef();
            this.fuelModeRef = msfsSdk.FSComponent.createRef();
            this.positionFormatModeRef = msfsSdk.FSComponent.createRef();
            //makes all the modes the settings should be on (by default)
            this.headingMode = this.unitsSettingsManager.getSetting('unitsNavAngle').map(v => {
                switch (v) {
                    case msfsGarminsdk.UnitsNavAngleSettingMode.Magnetic:
                        return HeadingSetting.Magnetic;
                    case msfsGarminsdk.UnitsNavAngleSettingMode.True:
                        return HeadingSetting.True;
                }
            });
            this.disSpdMode = this.unitsSettingsManager.getSetting('unitsDistance').map(v => {
                switch (v) {
                    case msfsGarminsdk.UnitsDistanceSettingMode.Metric:
                        return DisSpdUnits.Metric;
                    case msfsGarminsdk.UnitsDistanceSettingMode.Nautical:
                        return DisSpdUnits.Nautical;
                    case msfsGarminsdk.UnitsDistanceSettingMode.Statute:
                        return DisSpdUnits.Statute;
                }
            });
            this.altVsMode = this.unitsSettingsManager.getSetting('unitsAltitude').map(v => {
                switch (v) {
                    case msfsGarminsdk.UnitsAltitudeSettingMode.Feet:
                        return AltVs.Feet;
                    case msfsGarminsdk.UnitsAltitudeSettingMode.Meters:
                        return AltVs.Meters;
                    case msfsGarminsdk.UnitsAltitudeSettingMode.MetersMps:
                        return AltVs.Meters2;
                }
            });
            this.pressureMode = this.generalSettingsManager.getSetting('baroHpa').map(v => {
                if (v) {
                    return Pressure.Millibars;
                }
                else {
                    return Pressure.Inches;
                }
            });
            this.tempMode = this.unitsSettingsManager.getSetting('unitsTemperature').map(v => {
                switch (v) {
                    case msfsGarminsdk.UnitsTemperatureSettingMode.Celsius:
                        return Temp.Celsius;
                    case msfsGarminsdk.UnitsTemperatureSettingMode.Fahrenheit:
                        return Temp.Fahrenheit;
                }
            });
            this.fuelMode = this.unitsSettingsManager.getSetting('unitsFuel').map(v => {
                switch (v) {
                    case msfsGarminsdk.UnitsFuelSettingMode.Gallons:
                        return Fuel.Gallons;
                    case msfsGarminsdk.UnitsFuelSettingMode.ImpGal:
                        return Fuel.ImpGals;
                    case msfsGarminsdk.UnitsFuelSettingMode.Kilograms:
                        return Fuel.Kilograms;
                    case msfsGarminsdk.UnitsFuelSettingMode.Liters:
                        return Fuel.Liters;
                    case msfsGarminsdk.UnitsFuelSettingMode.Pounds:
                        return Fuel.Pounds;
                }
            });
            this.positionFormatMode = msfsSdk.Subject.create(positionFormat$1.hdddmmmmm);
            //all the unit selectors
            this.heading = msfsSdk.FSComponent.createRef();
            this.disSpd = msfsSdk.FSComponent.createRef();
            this.altVs = msfsSdk.FSComponent.createRef();
            this.pressure = msfsSdk.FSComponent.createRef();
            this.temp = msfsSdk.FSComponent.createRef();
            this.fuel = msfsSdk.FSComponent.createRef();
            this.positionFormat = msfsSdk.FSComponent.createRef();
            this.ppos = new msfsSdk.GeoPoint(0, 0);
            this.vor = msfsSdk.Subject.create(undefined);
            this.magvarRef = msfsSdk.FSComponent.createRef();
            this.magvar = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '____°';
                }
                const value = msfsSdk.MagVar.get(v.lat, v.lon);
                if (value >= 0) {
                    return 'E' + (Math.abs(value)).toFixed(0).padStart(3, '0') + '°';
                }
                else {
                    return 'W' + (Math.abs(value)).toFixed(0).padStart(3, '0') + '°';
                }
            });
            this.onDialogBoxClr = () => {
                this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            };
        }
        /**
         * Sets the heading type to use.
         * @param index The option the user selects.
         */
        setHeading(index) {
            var _a, _b;
            if (index === 0) {
                (_a = this.unitsSettingsManager) === null || _a === void 0 ? void 0 : _a.getSetting('unitsNavAngle').set(msfsGarminsdk.UnitsNavAngleSettingMode.Magnetic);
                if (this.vor !== undefined) {
                    this.magvar.set(this.ppos);
                    this.magvarRef.instance.classList.remove('hide-element');
                }
            }
            else if (index === 1) {
                this.magvarRef.instance.classList.add('hide-element');
                (_b = this.unitsSettingsManager) === null || _b === void 0 ? void 0 : _b.getSetting('unitsNavAngle').set(msfsGarminsdk.UnitsNavAngleSettingMode.True);
            }
            this.heading.instance.closePopout();
            this.heading.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /**
         * Sets the Dis Spd type to use.
         * @param index The option the user selects.
         */
        setDisSpd(index) {
            var _a, _b, _c;
            if (index === 0) {
                (_a = this.unitsSettingsManager) === null || _a === void 0 ? void 0 : _a.getSetting('unitsDistance').set(msfsGarminsdk.UnitsDistanceSettingMode.Metric);
            }
            else if (index === 1) {
                (_b = this.unitsSettingsManager) === null || _b === void 0 ? void 0 : _b.getSetting('unitsDistance').set(msfsGarminsdk.UnitsDistanceSettingMode.Nautical);
            }
            else if (index === 2) {
                (_c = this.unitsSettingsManager) === null || _c === void 0 ? void 0 : _c.getSetting('unitsDistance').set(msfsGarminsdk.UnitsDistanceSettingMode.Statute);
            }
            this.disSpd.instance.closePopout();
            this.disSpd.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /**
         * Sets the Alt Vs type to use.
         * @param index The option the user selects.
         */
        setAltVsUnits(index) {
            var _a, _b, _c;
            if (index === 0) {
                (_a = this.unitsSettingsManager) === null || _a === void 0 ? void 0 : _a.getSetting('unitsAltitude').set(msfsGarminsdk.UnitsAltitudeSettingMode.Feet);
            }
            else if (index === 1) {
                (_b = this.unitsSettingsManager) === null || _b === void 0 ? void 0 : _b.getSetting('unitsAltitude').set(msfsGarminsdk.UnitsAltitudeSettingMode.Meters);
            }
            else if (index === 2) {
                (_c = this.unitsSettingsManager) === null || _c === void 0 ? void 0 : _c.getSetting('unitsAltitude').set(msfsGarminsdk.UnitsAltitudeSettingMode.Meters);
            }
            this.altVs.instance.closePopout();
            this.altVs.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /**
         * Sets the pressure type to use.
         * @param index The option the user selects.
         */
        setPressure(index) {
            var _a, _b;
            if (index === 0) {
                (_a = this.generalSettingsManager) === null || _a === void 0 ? void 0 : _a.getSetting('baroHpa').set(false);
            }
            else if (index === 1) {
                (_b = this.generalSettingsManager) === null || _b === void 0 ? void 0 : _b.getSetting('baroHpa').set(true);
            }
            this.pressure.instance.closePopout();
            this.pressure.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /**
         * Sets the fuel type to use.
         * @param index The option the user selects.
         */
        setFuel(index) {
            var _a, _b, _c, _d, _e;
            if (index === 0) {
                (_a = this.unitsSettingsManager) === null || _a === void 0 ? void 0 : _a.getSetting('unitsFuel').set(msfsGarminsdk.UnitsFuelSettingMode.Gallons);
            }
            else if (index === 1) {
                (_b = this.unitsSettingsManager) === null || _b === void 0 ? void 0 : _b.getSetting('unitsFuel').set(msfsGarminsdk.UnitsFuelSettingMode.ImpGal);
            }
            else if (index === 2) {
                (_c = this.unitsSettingsManager) === null || _c === void 0 ? void 0 : _c.getSetting('unitsFuel').set(msfsGarminsdk.UnitsFuelSettingMode.Kilograms);
            }
            else if (index === 3) {
                (_d = this.unitsSettingsManager) === null || _d === void 0 ? void 0 : _d.getSetting('unitsFuel').set(msfsGarminsdk.UnitsFuelSettingMode.Liters);
            }
            else if (index === 4) {
                (_e = this.unitsSettingsManager) === null || _e === void 0 ? void 0 : _e.getSetting('unitsFuel').set(msfsGarminsdk.UnitsFuelSettingMode.Pounds);
            }
            this.fuel.instance.closePopout();
            this.fuel.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /**
         * Sets the temp type to use.
         * @param index The option the user selects.
         */
        setTemp(index) {
            var _a, _b;
            if (index === 0) {
                (_a = this.unitsSettingsManager) === null || _a === void 0 ? void 0 : _a.getSetting('unitsTemperature').set(msfsGarminsdk.UnitsTemperatureSettingMode.Celsius);
            }
            else if (index === 1) {
                (_b = this.unitsSettingsManager) === null || _b === void 0 ? void 0 : _b.getSetting('unitsTemperature').set(msfsGarminsdk.UnitsTemperatureSettingMode.Fahrenheit);
            }
            this.temp.instance.closePopout();
            this.temp.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /**
         * Sets the position type to use.
         * @param index The option the user selects.
         */
        setPositionFormat(index) {
            if (index === 0) {
                this.positionFormatMode.set(positionFormat$1.hdddmmmmm);
            }
            else if (index === 1) {
                this.positionFormatMode.set(positionFormat$1.hdddmmsss);
            }
            else if (index === 2) {
                this.positionFormatMode.set(positionFormat$1.MGRS);
            }
            else if (index === 3) {
                this.positionFormatMode.set(positionFormat$1.UTMUPS);
            }
            this.positionFormat.instance.closePopout();
            this.positionFormat.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            if (this.props.gnsType === 'wt530') {
                this.positionFormatModeRef.instance.setDisabled(true);
            }
            this.heading.instance.setItems([HeadingSetting.Magnetic, HeadingSetting.True], false);
            this.disSpd.instance.setItems([DisSpdUnits.Metric, DisSpdUnits.Nautical, DisSpdUnits.Statute], false);
            this.altVs.instance.setItems([AltVs.Feet, AltVs.Meters, AltVs.Meters2], false);
            this.pressure.instance.setItems([Pressure.Inches, Pressure.Millibars], false);
            this.temp.instance.setItems([Temp.Celsius, Temp.Fahrenheit], false);
            this.fuel.instance.setItems([Fuel.Gallons, Fuel.ImpGals, Fuel.Kilograms, Fuel.Liters, Fuel.Pounds], false);
            this.positionFormat.instance.setItems([positionFormat$1.hdddmmmmm, positionFormat$1.hdddmmsss, positionFormat$1.MGRS, positionFormat$1.UTMUPS], false);
            this.props.bus.getSubscriber()
                .on('gps-position')
                .handle(pos => { this.ppos.set(pos.lat, pos.long); this.magvar.set(this.ppos); });
        }
        /**
         * this renders the bottom part of the page.
         * The 430 dose not have the lower half.
         * @returns the bottom half of the page
         */
        renderBottom() {
            if (this.props.gnsType !== 'wt430') {
                return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-position-format-title" },
                        "POSITION FORMAT",
                        msfsSdk.FSComponent.buildComponent("div", { class: "aux-table units-position-position-format" },
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.positionFormatModeRef, class: "aux-entry com-configuration-spacing", data: this.positionFormatMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.positionFormat.instance.openPopout(0);
                                    this.positionFormat.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.positionFormat.instance.openPopout(0);
                                    this.positionFormat.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-position-map-title" },
                        "MAP DATUM",
                        msfsSdk.FSComponent.buildComponent("div", { class: "aux-table units-position-map-datum-format" }, "WGS 84"))));
            }
            else {
                //return nothing since this part does not show in the 430
                return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null));
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page aux-page hide-element", ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "UNITS / POSITION"),
                msfsSdk.FSComponent.buildComponent("div", { class: "units-position-container" },
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-side-title cyan" }, "HEADING"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-side-title cyan" }, "DIS, SPD"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-side-title cyan" }, "ALT, VS"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-side-title cyan" }, "PRESSURE"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-side-title cyan" }, "TEMP"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-side-title cyan" }, "FUEL")),
                msfsSdk.FSComponent.buildComponent("div", null,
                    msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.scrollContainerRef, isolateScroll: true },
                        msfsSdk.FSComponent.buildComponent("div", { class: "aux-table units-position-table" },
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.headingModeRef, class: "aux-entry com-configuration-spacing", data: this.headingMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.heading.instance.openPopout(0);
                                    this.heading.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.heading.instance.openPopout(0);
                                    this.heading.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.disSpdModeRef, class: "aux-entry com-configuration-spacing", data: this.disSpdMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.disSpd.instance.openPopout(0);
                                    this.disSpd.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.disSpd.instance.openPopout(0);
                                    this.disSpd.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.altVsModeRef, class: "aux-entry com-configuration-spacing", data: this.altVsMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.altVs.instance.openPopout(0);
                                    this.altVs.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.altVs.instance.openPopout(0);
                                    this.altVs.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.pressureModeRef, class: "aux-entry com-configuration-spacing", data: this.pressureMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.pressure.instance.openPopout(0);
                                    this.pressure.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.pressure.instance.openPopout(0);
                                    this.pressure.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.tempModeRef, class: "aux-entry com-configuration-spacing", data: this.tempMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.temp.instance.openPopout(0);
                                    this.temp.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.temp.instance.openPopout(0);
                                    this.temp.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } }),
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.fuelModeRef, class: "aux-entry com-configuration-spacing", data: this.fuelMode, onRightInnerInc: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.fuel.instance.openPopout(0);
                                    this.fuel.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                }, onRightInnerDec: () => {
                                    this.scrollContainerRef.instance.blur();
                                    this.fuel.instance.openPopout(0);
                                    this.fuel.instance.focus(msfsSdk.FocusPosition.First);
                                    return true;
                                } })))),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-heading', label: 'HEADING MODE', onSelected: (index) => this.setHeading(index), ref: this.heading, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-disspf', label: 'DIS, SPD UNITS', onSelected: (index) => this.setDisSpd(index), ref: this.disSpd, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-altvs', label: 'ALT, VS UNITS', onSelected: (index) => this.setAltVsUnits(index), ref: this.altVs, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-pressure', label: 'PRESSURE UNITS', onSelected: (index) => this.setPressure(index), ref: this.pressure, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-temp', label: 'TEMP UNITS', onSelected: (index) => this.setTemp(index), ref: this.temp, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-fuel', label: 'FUEL UNITS', onSelected: (index) => this.setFuel(index), ref: this.fuel, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-position', label: 'POSITION FORMAT', onSelected: (index) => this.setPositionFormat(index), ref: this.positionFormat, onClosed: this.onDialogBoxClr }),
                msfsSdk.FSComponent.buildComponent("div", { ref: this.magvarRef, class: 'units-position-magvar' }, this.magvar),
                this.renderBottom()));
        }
    }

    var positionFormat;
    (function (positionFormat) {
        positionFormat["hdddmmmmm"] = "hddd\u00B0 mm.mmm'";
        positionFormat["hdddmmsss"] = "hddd\u00B0mm'ss.s\"";
        positionFormat["MGRS"] = "MGRS";
        positionFormat["UTMUPS"] = "UTM/UPS";
    })(positionFormat || (positionFormat = {}));
    /**
     * Position and map datum page.
     */
    class PositionMapDatum extends AuxPage {
        constructor() {
            super(...arguments);
            this.scrollContainerRef = msfsSdk.FSComponent.createRef();
            this.positionFormatModeRef = msfsSdk.FSComponent.createRef();
            this.positionFormatMode = msfsSdk.Subject.create(positionFormat.hdddmmmmm);
            this.positionFormat = msfsSdk.FSComponent.createRef();
        }
        /**
         * Sets the position type to use.
         * @param index The option the user selects.
         */
        setPositionFormat(index) {
            if (index === 0) {
                this.positionFormatMode.set(positionFormat.hdddmmmmm);
            }
            else if (index === 1) {
                this.positionFormatMode.set(positionFormat.hdddmmsss);
            }
            else if (index === 2) {
                this.positionFormatMode.set(positionFormat.MGRS);
            }
            else if (index === 3) {
                this.positionFormatMode.set(positionFormat.UTMUPS);
            }
            this.positionFormat.instance.closePopout();
            this.positionFormat.instance.blur();
            this.scrollContainerRef.instance.focus(msfsSdk.FocusPosition.MostRecent);
            this.scroll('forward');
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            if (this.props.gnsType === 'wt530') {
                this.positionFormatModeRef.instance.setDisabled(true);
            }
            this.positionFormat.instance.setItems([positionFormat.hdddmmmmm, positionFormat.hdddmmsss, positionFormat.MGRS, positionFormat.UTMUPS], false);
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page aux-page hide-element", ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "POSITION FORMAT / MAP DATUM"),
                msfsSdk.FSComponent.buildComponent("div", { class: "units-position-position-format-title" },
                    "POSITION FORMAT",
                    msfsSdk.FSComponent.buildComponent("div", { class: "units-position-position-format" },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.positionFormatModeRef, class: "aux-entry com-configuration-spacing", data: this.positionFormatMode, onRightInnerInc: () => {
                                this.scrollContainerRef.instance.blur();
                                this.positionFormat.instance.openPopout(0);
                                this.positionFormat.instance.focus(msfsSdk.FocusPosition.First);
                                return true;
                            }, onRightInnerDec: () => {
                                this.scrollContainerRef.instance.blur();
                                this.positionFormat.instance.openPopout(0);
                                this.positionFormat.instance.focus(msfsSdk.FocusPosition.First);
                                return true;
                            } }))),
                msfsSdk.FSComponent.buildComponent("div", { class: "units-position-position-format-title" },
                    "MAP DATUM",
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table units-position-map-datum-format" }, "WGS 84")),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { class: 'units-position-dialog-position', label: 'POSITION FORMAT', onSelected: (index) => this.setPositionFormat(index), ref: this.positionFormat })));
        }
    }

    /**
     * setup 1 page for Aux group of pages
     */
    class AuxSetup1 extends Page {
        constructor() {
            super(...arguments);
            this.page3OptionsArray430 = [
                {
                    label: 'Airspace Alarms', disabled: true, action: () => {
                    }
                },
                {
                    label: 'CDI / Alarms', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Units / Mag Var', disabled: false, action: () => {
                        this.changePage('units-position');
                    }
                },
                {
                    label: 'Position / Map Datum', disabled: false, action: () => {
                        this.changePage('position-mapdatum');
                    }
                },
                {
                    label: 'Date / Time', disabled: false, action: () => {
                        this.changePage('date-time');
                    }
                }
            ];
            this.page3OptionsArray530 = [
                {
                    label: 'CDI / Alarms', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Units / Position', disabled: false, action: () => {
                        this.changePage('units-position');
                    }
                },
                {
                    label: 'Date / Time', disabled: false, action: () => {
                        this.changePage('date-time');
                    }
                },
                {
                    label: 'Display Backlight', disabled: false, action: () => {
                        this.changePage('display-backlight');
                    }
                },
                {
                    label: 'Nearest Airport Criteria', disabled: false, action: () => {
                        this.changePage('nearest-airport-criteria');
                    }
                },
                {
                    label: 'Data Field Configuration', disabled: true, action: () => {
                    }
                },
                {
                    label: 'COM Configuration', disabled: false, action: () => {
                        this.changePage('com-configuration');
                    }
                }
            ];
            this.menu = new AuxPageMenu();
            this.auxPageGroupRef = msfsSdk.FSComponent.createRef();
            this.page3Options430 = msfsSdk.ArraySubject.create(this.page3OptionsArray430);
            this.page3Options530 = msfsSdk.ArraySubject.create(this.page3OptionsArray530);
            this.auxSetup1MenuItems = msfsSdk.FSComponent.createRef();
            /**
             * Picks the next page to be loaded
             * @param listMenuItem the menuEntry
             * @returns if the page has been loaded
             */
            this.onListItemSelected = (listMenuItem) => {
                const menuEntry = listMenuItem.props.data;
                if (menuEntry !== null) {
                    if (menuEntry.action instanceof msfsSdk.Subject) {
                        const action = menuEntry.action.get();
                        action();
                    }
                    else {
                        menuEntry.action();
                    }
                }
                return true;
            };
            this.onSubpageClr = () => {
                const list = this.auxSetup1MenuItems.instance;
                this.auxPageGroup.blur();
                this.onResume();
                list.focus(msfsSdk.FocusPosition.MostRecent);
            };
        }
        /**
         * Return the aux page group in this page
         *
         * @returns the aux page group
         */
        get auxPageGroup() {
            return this.auxPageGroupRef.instance;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            const list = this.auxSetup1MenuItems.instance;
            if (this.auxPageGroup.currentPageFocused()) {
                return this.auxPageGroup.onInteractionEvent(evt);
            }
            if (evt === InteractionEvent.RightKnobPush) {
                if (!list.isFocused) {
                    list.focus(msfsSdk.FocusPosition.MostRecent);
                }
                else {
                    list.blur();
                }
                return true;
            }
            else if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.menu);
                return true;
            }
            let handled = false;
            if (this.auxSetup1MenuItems.instance.isFocused) {
                handled = this.auxSetup1MenuItems.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (([InteractionEvent.RightOuterInc, InteractionEvent.RightOuterDec, InteractionEvent.RightInnerDec, InteractionEvent.RightInnerInc].includes(evt))) {
                return this.auxSetup1MenuItems.instance.isFocused;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritDoc */
        get isActive() {
            var _a, _b, _c;
            return super.isActive || ((_c = (_b = (_a = this.auxPageGroup) === null || _a === void 0 ? void 0 : _a.currentPage) === null || _b === void 0 ? void 0 : _b.isVisible) !== null && _c !== void 0 ? _c : false);
        }
        /** @inheritDoc */
        onSuspend() {
            super.onSuspend();
            this.auxPageGroup.blur();
        }
        /**
         * Change the currently displayed page of the aux page group
         *
         * @param key the page key
         */
        changePage(key) {
            this.onSuspend();
            this.auxPageGroup.setPage(key);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                msfsSdk.FSComponent.buildComponent("div", { class: 'page aux-page hide-element', ref: this.el },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "SETUP 1")),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table aux-table-full-width aux-table-full-height' },
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.props.gnsType === 'wt430' ? this.page3Options430 : this.page3Options530, renderItem: (data) => msfsSdk.FSComponent.buildComponent(PageMenuItem, { data: data, onSelected: this.onListItemSelected }), ref: this.auxSetup1MenuItems, hideScrollbar: true, class: "aux-page-menu-list" }))),
                msfsSdk.FSComponent.buildComponent(AuxPageGroup, { ref: this.auxPageGroupRef },
                    msfsSdk.FSComponent.buildComponent(DateTimePage, { key: 'date-time', bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(UnitsPosition, { key: 'units-position', bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(PositionMapDatum, { key: 'position-mapdatum', bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(DisplayBacklight, { key: "display-backlight", bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, xmlConfig: this.props.xmlConfig, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(NearestAirportCriteria, { key: "nearest-airport-criteria", bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(ComConfiguration, { key: "com-configuration", bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr, settingsProvider: this.props.settingsProvider, isolateScroll: true }))));
        }
    }

    /**
     * An aux page that allows the user to select SBAS groups.
     */
    class SbasSelectionPage extends AuxPage {
        constructor() {
            super(...arguments);
            this.rootControl = msfsSdk.FSComponent.createRef();
            this.waasDialogRef = msfsSdk.FSComponent.createRef();
            this.egnosDialogRef = msfsSdk.FSComponent.createRef();
            this.gaganDialogRef = msfsSdk.FSComponent.createRef();
            this.msasDialogRef = msfsSdk.FSComponent.createRef();
            this.gpsSettings = this.props.settingsProvider.gps;
            this.currentSetting = this.gpsSettings.getSetting('sbas_waas_enabled');
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.waasDialogRef.instance.setDisabled(true);
            this.egnosDialogRef.instance.setDisabled(true);
            this.gaganDialogRef.instance.setDisabled(true);
            this.msasDialogRef.instance.setDisabled(true);
        }
        /**
         * Opens the option setting popup.
         * @param setting The setting to set.
         * @param dialog The dialog to open.
         * @returns True.
         */
        openPopup(setting, dialog) {
            this.rootControl.instance.blur();
            dialog.instance.setDisabled(false);
            dialog.instance.setItems(['Off', 'On'], false);
            dialog.instance.openPopout(setting.get() ? 1 : 0);
            this.currentSetting = setting;
            return true;
        }
        /**
         * Closes the option setting popup.
         * @param dialog The dialog to close.
         */
        onDialogClosed(dialog) {
            dialog.instance.setDisabled(true);
            this.rootControl.instance.focus(msfsSdk.FocusPosition.MostRecent);
        }
        /**
         * Handles when an option is selected in an option menu.
         * @param index The index that was selected.
         * @param dialog The dialog to close.
         */
        onOptionSelected(index, dialog) {
            this.currentSetting.set(index === 0 ? false : true);
            this.onDialogClosed(dialog);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page aux-page hide-element", ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "SBAS SELECTION"),
                msfsSdk.FSComponent.buildComponent("div", { class: "sbas-selection-page" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-label' }, "WAAS"),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-label' }, "EGNOS"),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-label' }, "GAGAN"),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-label' }, "MSAS")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.rootControl, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-selector' },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { class: 'aux-entry', data: this.gpsSettings.getSetting('sbas_waas_enabled').map(e => e ? 'On' : 'Off'), onRightInnerInc: () => this.openPopup(this.gpsSettings.getSetting('sbas_waas_enabled'), this.waasDialogRef), onRightInnerDec: () => this.openPopup(this.gpsSettings.getSetting('sbas_waas_enabled'), this.waasDialogRef) }),
                                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.waasDialogRef, class: "sbas-configuration-dialog", label: "ENABLED", onSelected: index => this.onOptionSelected(index, this.waasDialogRef), onClosed: () => this.onDialogClosed(this.waasDialogRef), isolateScroll: true })),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-selector' },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { class: 'aux-entry', data: this.gpsSettings.getSetting('sbas_egnos_enabled').map(e => e ? 'On' : 'Off'), onRightInnerInc: () => this.openPopup(this.gpsSettings.getSetting('sbas_egnos_enabled'), this.egnosDialogRef), onRightInnerDec: () => this.openPopup(this.gpsSettings.getSetting('sbas_egnos_enabled'), this.egnosDialogRef) }),
                                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.egnosDialogRef, class: "sbas-configuration-dialog", label: "ENABLED", onSelected: index => this.onOptionSelected(index, this.egnosDialogRef), onClosed: () => this.onDialogClosed(this.egnosDialogRef), isolateScroll: true })),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-selector' },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { class: 'aux-entry', data: this.gpsSettings.getSetting('sbas_gagan_enabled').map(e => e ? 'On' : 'Off'), onRightInnerInc: () => this.openPopup(this.gpsSettings.getSetting('sbas_gagan_enabled'), this.gaganDialogRef), onRightInnerDec: () => this.openPopup(this.gpsSettings.getSetting('sbas_gagan_enabled'), this.gaganDialogRef) }),
                                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.gaganDialogRef, class: "sbas-configuration-dialog", label: "ENABLED", onSelected: index => this.onOptionSelected(index, this.gaganDialogRef), onClosed: () => this.onDialogClosed(this.gaganDialogRef), isolateScroll: true })),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'sbas-selection-selector' },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { class: 'aux-entry', data: this.gpsSettings.getSetting('sbas_msas_enabled').map(e => e ? 'On' : 'Off'), onRightInnerInc: () => this.openPopup(this.gpsSettings.getSetting('sbas_msas_enabled'), this.msasDialogRef), onRightInnerDec: () => this.openPopup(this.gpsSettings.getSetting('sbas_msas_enabled'), this.msasDialogRef) }),
                                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.msasDialogRef, class: "sbas-configuration-dialog", label: "ENABLED", onSelected: index => this.onOptionSelected(index, this.msasDialogRef), onClosed: () => this.onDialogClosed(this.msasDialogRef), isolateScroll: true })))))));
        }
    }

    /**
     * setup 2 page for Aux group of pages
     */
    class AuxSetup2 extends Page {
        constructor() {
            super(...arguments);
            this.menu = new AuxPageMenu();
            this.auxPageGroupRef = msfsSdk.FSComponent.createRef();
            this.page4OptionsArray430 = [
                {
                    label: 'Display', disabled: false, action: () => {
                        this.changePage('display-backlight');
                    }
                },
                {
                    label: 'NearestAirport Criteria', disabled: false, action: () => {
                        this.changePage('nearest-airport-criteria');
                    }
                },
                {
                    label: 'SBAS Selection', disabled: false, action: () => this.changePage('sbas-selection')
                },
                {
                    label: 'COM Configuration', disabled: false, action: () => {
                        this.changePage('com-configuration');
                    }
                },
            ];
            this.page4OptionsArray530 = [
                {
                    label: 'SBAS Selection', disabled: false, action: () => this.changePage('sbas-selection')
                },
            ];
            this.page4Options530 = msfsSdk.ArraySubject.create(this.page4OptionsArray530);
            this.page4Options430 = msfsSdk.ArraySubject.create(this.page4OptionsArray430);
            this.AuxSetup2MenuItems = msfsSdk.FSComponent.createRef();
            /**
             * Picks the next page to be loaded
             * @param listMenuItem the menuEntry
             * @returns if the page has been loaded
             */
            this.onListItemSelected = (listMenuItem) => {
                const menuEntry = listMenuItem.props.data;
                if (menuEntry !== null) {
                    if (menuEntry.action instanceof msfsSdk.Subject) {
                        const action = menuEntry.action.get();
                        action();
                    }
                    else {
                        menuEntry.action();
                    }
                }
                return true;
            };
        }
        /**
         * Return the aux page group in this page
         *
         * @returns the aux page group
         */
        get auxPageGroup() {
            return this.auxPageGroupRef.instance;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            const list = this.AuxSetup2MenuItems.instance;
            if (this.auxPageGroupRef.instance.currentPageFocused()) {
                return this.auxPageGroupRef.instance.onInteractionEvent(evt);
            }
            if (evt === InteractionEvent.RightKnobPush) {
                if (!list.isFocused) {
                    list.focus(msfsSdk.FocusPosition.MostRecent);
                }
                else {
                    list.blur();
                }
                return true;
            }
            else if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.menu);
                return true;
            }
            let handled = false;
            if (this.AuxSetup2MenuItems.instance.isFocused) {
                handled = this.AuxSetup2MenuItems.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (([InteractionEvent.RightOuterInc, InteractionEvent.RightOuterDec, InteractionEvent.RightInnerDec, InteractionEvent.RightInnerInc].includes(evt))) {
                return this.AuxSetup2MenuItems.instance.isFocused;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritDoc */
        get isActive() {
            var _a, _b, _c;
            return super.isActive || ((_c = (_b = (_a = this.auxPageGroup) === null || _a === void 0 ? void 0 : _a.currentPage) === null || _b === void 0 ? void 0 : _b.isVisible) !== null && _c !== void 0 ? _c : false);
        }
        /** @inheritDoc */
        onSuspend() {
            super.onSuspend();
            this.auxPageGroup.blur();
        }
        /**
         * Change the currently displayed page of the aux page group
         *
         * @param key the page key
         */
        changePage(key) {
            this.onSuspend();
            this.auxPageGroupRef.instance.setPage(key);
        }
        /**
         * Handles when an aux subpage CLR is pressed.
         * @returns True.
         */
        onSubpageClr() {
            const list = this.AuxSetup2MenuItems.instance;
            this.auxPageGroupRef.instance.blur();
            this.onResume();
            list.focus(msfsSdk.FocusPosition.MostRecent);
            return true;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent("div", { class: 'page aux-page hide-element', ref: this.el },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "SETUP 2")),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table aux-table-full-width aux-table-full-height' },
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.props.gnsType === 'wt430' ? this.page4Options430 : this.page4Options530, renderItem: (data) => msfsSdk.FSComponent.buildComponent(PageMenuItem, { data: data, onSelected: this.onListItemSelected }), ref: this.AuxSetup2MenuItems, hideScrollbar: true, class: "aux-page-menu-list" }))),
                msfsSdk.FSComponent.buildComponent(AuxPageGroup, { ref: this.auxPageGroupRef },
                    msfsSdk.FSComponent.buildComponent(SbasSelectionPage, { key: 'sbas-selection', bus: this.props.bus, gnsType: this.props.gnsType, settingsProvider: this.props.settingsProvider, onDisabled: this.onSubpageClr.bind(this), isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(DisplayBacklight, { key: "display-backlight", bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr.bind(this), xmlConfig: this.props.xmlConfig, settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(NearestAirportCriteria, { key: "nearest-airport-criteria", bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr.bind(this), settingsProvider: this.props.settingsProvider, isolateScroll: true }),
                    msfsSdk.FSComponent.buildComponent(ComConfiguration, { key: "com-configuration", bus: this.props.bus, gnsType: this.props.gnsType, onDisabled: this.onSubpageClr.bind(this), settingsProvider: this.props.settingsProvider, isolateScroll: true }))));
        }
    }

    /**
     * Utility page for Aux group of pages
     */
    class AuxUtility extends Page {
        constructor() {
            super(...arguments);
            this.page2OptionsArray430 = [
                {
                    label: 'Checklists', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Flight Timers', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Trip Statistics', disabled: true, action: () => {
                    }
                },
                {
                    label: 'RAIM Prediction', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Sunrise / Sunset', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Software Versions', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Database Versions', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Terrain Database Versions', disabled: true, action: () => {
                    }
                }
            ];
            this.page2OptionsArray530 = [
                {
                    label: 'Checklists', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Flight Timers', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Trip Statistics', disabled: true, action: () => {
                    }
                },
                {
                    label: 'RAIM Prediction', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Software Versions', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Datebase Versions', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Terrain Database Versions', disabled: true, action: () => {
                    }
                },
            ];
            this.page2Options530 = msfsSdk.ArraySubject.create(this.page2OptionsArray530);
            this.page2Options430 = msfsSdk.ArraySubject.create(this.page2OptionsArray430);
            this.auxUtilityMenuItems = msfsSdk.FSComponent.createRef();
            /**
             * Picks the next page to be loaded
             * @param listMenuItem the menuEntry
             * @returns if the page has been loaded
             */
            this.onListItemSelected = (listMenuItem) => {
                const menuEntry = listMenuItem.props.data;
                if (menuEntry !== null) {
                    if (menuEntry.action instanceof msfsSdk.Subject) {
                        const action = menuEntry.action.get();
                        action();
                    }
                    else {
                        menuEntry.action();
                    }
                }
                return true;
            };
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RightKnobPush) {
                const list = this.auxUtilityMenuItems.instance;
                if (!list.isFocused) {
                    list.focus(msfsSdk.FocusPosition.MostRecent);
                }
                else {
                    list.blur();
                }
                return true;
            }
            else if (evt === InteractionEvent.ENT) {
                //get the current event then render the new page
                const list = this.auxUtilityMenuItems.instance;
                list.getFocusedIndex();
            }
            let handled = false;
            if (this.auxUtilityMenuItems.instance.isFocused) {
                handled = this.auxUtilityMenuItems.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (([InteractionEvent.RightOuterInc, InteractionEvent.RightOuterDec, InteractionEvent.RightInnerDec, InteractionEvent.RightInnerInc].includes(evt))) {
                return this.auxUtilityMenuItems.instance.isFocused;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page aux-page hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' },
                    msfsSdk.FSComponent.buildComponent("h2", null, "UTILITY")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table aux-table-full-width aux-table-full-height' },
                    msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.props.gnsType === 'wt430' ? this.page2Options430 : this.page2Options530, renderItem: (data) => msfsSdk.FSComponent.buildComponent(PageMenuItem, { data: data, onSelected: this.onListItemSelected }), ref: this.auxUtilityMenuItems, hideScrollbar: true, class: "aux-page-menu-list" }))));
        }
    }

    /**
     * A page that displays a modal dialog.
     */
    class Dialog extends Page {
        constructor() {
            super(...arguments);
            this.root = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.onSuspend();
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            let handled = false;
            if (this.root.instance.isFocused) {
                handled = this.root.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.root.instance.focus(msfsSdk.FocusPosition.First);
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.root.instance.blur();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'dialog', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'dialog-box' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'dialog-box-inner' }, this.renderDialog()))),
                this.renderOuterDialog()));
        }
        /**
         * Renders the dialog box content.
         * @returns The content of the dialog box.
         */
        renderDialog() {
            return null;
        }
        /**
         * Renders the outside of the dialog box content.
         * @returns The content of the outer dialog box.
         */
        renderOuterDialog() {
            return null;
        }
    }

    /**
     * A confirmation dialog for activating a future leg in the flight plan.
     */
    class ActivateLegDialog extends Dialog {
        constructor() {
            super(...arguments);
            this.activatePromptContainer = msfsSdk.FSComponent.createRef();
            this.activatePrompt = msfsSdk.FSComponent.createRef();
            this.fromWaypoint = msfsSdk.FSComponent.createRef();
            this.toWaypoint = msfsSdk.FSComponent.createRef();
            this.legIcon = msfsSdk.FSComponent.createRef();
            this.headerText = msfsSdk.Subject.create('');
            this.targetLegIndex = -1;
        }
        /**
         * Set the index for the target leg.
         * @param idx The global index of the leg to activate.
         */
        set legIndex(idx) {
            this.targetLegIndex = idx;
            if (idx >= 0) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                const toLeg = plan.tryGetLeg(idx);
                const fromLeg = plan.tryGetLeg(idx - 1);
                this.toWaypoint.instance.setLeg(toLeg);
                this.fromWaypoint.instance.setLeg(fromLeg);
                if (toLeg !== null) {
                    if (fromLeg === null) {
                        // We can't rely on direct to state, because everything is a direct to when this runs.
                        this.headerText.set('Direct To');
                        this.legIcon.instance.updateLegIcon(true, true, toLeg.leg.type, toLeg.leg.turnDirection);
                    }
                    else {
                        this.headerText.set('Fly Leg');
                        this.legIcon.instance.updateLegIcon(true, false, toLeg.leg.type, toLeg.leg.turnDirection);
                    }
                }
                else {
                    this.legIcon.instance.updateLegIcon(true, false, msfsSdk.LegType.TF);
                }
            }
        }
        /**
         * Get the target leg index.
         * @returns The global index of the set target leg.
         */
        get legIndex() {
            return this.targetLegIndex;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.toWaypoint.instance.setDisabled(true);
            this.fromWaypoint.instance.setDisabled(true);
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "activate-leg-dialog" },
                msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "ACTIVATE LEG"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'activate-leg-dialog-middle' },
                    msfsSdk.FSComponent.buildComponent("p", { class: 'activate-leg-header' }, this.headerText),
                    msfsSdk.FSComponent.buildComponent("p", null,
                        msfsSdk.FSComponent.buildComponent(WaypointLeg, { ref: this.fromWaypoint, class: 'activate-leg-waypoints-from', isArcMap: true, nullIsBlank: true }),
                        msfsSdk.FSComponent.buildComponent(LegIcon, { ref: this.legIcon }),
                        msfsSdk.FSComponent.buildComponent(WaypointLeg, { ref: this.toWaypoint, class: 'activate-leg-waypoints-to', isArcMap: true, nullIsBlank: true }))),
                msfsSdk.FSComponent.buildComponent("div", { class: "activate-leg-row" },
                    msfsSdk.FSComponent.buildComponent("div", { ref: this.activatePromptContainer, class: "activate-leg-confirm" },
                        msfsSdk.FSComponent.buildComponent("div", { class: "activate-leg-spacer" }),
                        msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.activatePrompt, class: "activate-leg-prompt", selectedClass: 'selected-white', data: msfsSdk.Subject.create('Activate?'), onEnt: () => {
                                const plan = this.props.fms.getPrimaryFlightPlan();
                                this.props.fms.activateLeg(plan.getSegmentIndex(this.legIndex), plan.getSegmentLegIndex(this.legIndex), msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX, true);
                                ViewService.back();
                                ViewService.back();
                                ViewService.back(); // for dtodto
                                return true;
                            } })))));
        }
    }

    /**
     *
     */
    class ConfirmDialog extends Dialog {
        constructor() {
            super(...arguments);
            this.resolve = msfsSdk.Subject.create(() => { });
            this.title = msfsSdk.Subject.create('');
            this.body = msfsSdk.Subject.create('');
        }
        /**
         * Sets the promise resolution function for this dialog.
         * @param resolve The promise resolution function.
         */
        setResolve(resolve) {
            this.resolve.set(resolve);
        }
        /**
         * Sets the title of the dialog.
         * @param title The title of the dialog.
         */
        setTitle(title) {
            this.title.set(title);
        }
        /**
         * Sets the body of the dialog.
         * @param body The body of the dialog.
         */
        setBody(body) {
            this.body.set(body);
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, this.title),
                msfsSdk.FSComponent.buildComponent("hr", null),
                msfsSdk.FSComponent.buildComponent("p", null, this.body),
                msfsSdk.FSComponent.buildComponent("hr", null),
                msfsSdk.FSComponent.buildComponent(DialogControl, { resolve: this.resolve, value: true }, "Yes?"),
                msfsSdk.FSComponent.buildComponent("span", null, " or "),
                msfsSdk.FSComponent.buildComponent(DialogControl, { resolve: this.resolve, value: false }, "No?")));
        }
    }
    /**
     * A control on a confirmation dialog.
     */
    class DialogControl extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onFocused() {
            this.el.instance.classList.add('selected-white');
        }
        /** @inheritdoc */
        onBlurred() {
            this.el.instance.classList.remove('selected-white');
        }
        /** @inheritdoc */
        onEnt() {
            this.props.resolve.get()(this.props.value);
            return true;
        }
        /** @inheritdoc */
        onRightKnobPush() {
            this.props.resolve.get()(false);
            return true;
        }
        /** @inheritdoc */
        onClr() {
            this.props.resolve.get()(false);
            return true;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: 'confirm-dialog-control', ref: this.el }, this.props.children));
        }
    }

    /**
     * A control that allows a user to input an alphanumeric string via the right inner knob.
     */
    class AlphaNumInput extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.currentValue = ''.padEnd(this.props.length !== undefined ? this.props.length : 5, '_');
            this.el = msfsSdk.FSComponent.createRef();
            this.root = msfsSdk.FSComponent.createRef();
            this.activeRef = msfsSdk.FSComponent.createRef();
            this.inactiveRef = msfsSdk.FSComponent.createRef();
            this.keyboardRef = msfsSdk.FSComponent.createRef();
            this.isEditing = false;
            this.inactiveRenderedValue = null;
            this.keyboardIcon = msfsSdk.FSComponent.createRef();
            this.textBox = msfsSdk.FSComponent.createRef();
            this.currentSlotIndex = 0;
            this.inputId = this.genGuid();
            this.setValueFromOS = (text) => {
                this.textBox.instance.value = text;
                for (let i = 0; i < text.length; i++) {
                    const char = text[i].toUpperCase();
                    this.onSlotChanged(i, char);
                }
                this.textBox.instance.blur();
                Coherent.off('SetInputTextFromOS', this.setValueFromOS);
            };
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            if (this.props.enableKeyboard) {
                this.textBox.instance.onkeydown = (e) => this.onKeyboardEvent(e);
                this.textBox.instance.onfocus = (e) => this.onKeyboardFocus(e);
                this.textBox.instance.onblur = (e) => this.onKeyboardBlur(e);
                this.textBox.instance.disabled = true;
                this.el.instance.onclick = () => {
                    if (this.props.enableKeyboard) {
                        if (this.textBox.instance.disabled) {
                            this.textBox.instance.disabled = false;
                            this.textBox.instance.focus();
                        }
                        else {
                            this.textBox.instance.disabled = true;
                            this.textBox.instance.blur();
                        }
                    }
                };
            }
            this.updateInactiveDisplay();
            this.displayKeyboardIcon(false);
            const charWidth = this.props.gnsType === 'wt530' ? 10 : 12;
            this.el.instance.style.setProperty('--alpha-num-input-width', `${this.props.length ? this.props.length * charWidth : 50}px`);
        }
        /**
         * Handles when a character in a slot changes.
         * @param index The index of the character.
         * @param val The value at that index.
         */
        onSlotChanged(index, val) {
            var _a;
            const newValue = this.currentValue.substr(0, index) + val;
            this.set(newValue);
            const underscoreIndex = this.currentValue.indexOf('_');
            let valWithoutUnderscores = newValue;
            if (underscoreIndex !== -1) {
                valWithoutUnderscores = this.currentValue.substr(0, this.currentValue.indexOf('_'));
            }
            this.props.onChanged(valWithoutUnderscores, index, val);
            this.currentSlotIndex = index;
            this.manageSelected();
            (_a = this.root.instance.getChild(index)) === null || _a === void 0 ? void 0 : _a.focus(msfsSdk.FocusPosition.First);
        }
        /**
         * Sets the value of the input control.
         * @param val The value to set.
         */
        set(val) {
            const isEditing = this.isEditing;
            this.isEditing = true;
            for (let i = 0; i < this.currentValue.length; i++) {
                const slot = this.root.instance.getChild(i);
                if (i >= val.length) {
                    slot.set('_');
                }
                else {
                    slot.set(val[i]);
                }
            }
            //Only update the current slot index if we're not in keyboard mode
            //else keyboard mode is tracking that for us
            if (document.activeElement !== this.textBox.instance) {
                this.currentSlotIndex = val.length - 1;
            }
            this.currentValue = val.padEnd(this.props.length !== undefined ? this.props.length : 5, '_');
            if (this.props.enableKeyboard) {
                this.textBox.instance.value = val;
                isEditing && document.activeElement === this.textBox.instance && this.textBox.instance.setSelectionRange(val.length - 1, val.length - 1);
            }
            this.updateInactiveDisplay();
            this.isEditing = isEditing;
        }
        /** @inheritdoc */
        onFocused() {
            if (this.root.instance.getFocusedIndex() === -1) {
                this.focusSelf();
            }
        }
        /**
         * Focuses the whole input component itself.
         */
        focusSelf() {
            this.root.instance.blur();
            this.disableSlots();
            this.displayKeyboardIcon(true);
            this.manageSelected();
        }
        /** @inheritdoc */
        onRightInnerInc() {
            var _a;
            this.enableSlots();
            (_a = this.root.instance.getChild(0)) === null || _a === void 0 ? void 0 : _a.focus(msfsSdk.FocusPosition.First);
            this.manageSelected();
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            var _a;
            this.enableSlots();
            (_a = this.root.instance.getChild(0)) === null || _a === void 0 ? void 0 : _a.focus(msfsSdk.FocusPosition.First);
            this.manageSelected();
            return true;
        }
        /**
         * Disables the individual input slots.
         */
        disableSlots() {
            var _a;
            for (let i = 0; i < this.root.instance.length; i++) {
                (_a = this.root.instance.getChild(i)) === null || _a === void 0 ? void 0 : _a.setDisabled(true);
            }
            this.isEditing = false;
            this.updateInactiveDisplay();
        }
        /**
         * Enables the individual input slots.
         */
        enableSlots() {
            for (let i = 0; i < this.root.instance.length; i++) {
                const child = this.root.instance.getChild(i);
                child === null || child === void 0 ? void 0 : child.setDisabled(false);
                child === null || child === void 0 ? void 0 : child.set(this.currentValue[i]);
            }
            this.displayKeyboardIcon(true);
            this.isEditing = true;
            this.updateInactiveDisplay();
        }
        /** @inheritDoc */
        onBlurred() {
            this.root.instance.setFocusedIndex(0);
            this.manageSelected();
            !this.isEditing && this.displayKeyboardIcon(false);
            if (this.props.enableKeyboard) {
                this.textBox.instance.blur();
            }
        }
        /**
         * Shows the Keyboard icon.
         * @param display Boolean to show keyboard icon.
         */
        displayKeyboardIcon(display) {
            this.keyboardRef.instance.style.display = display ? '' : 'none';
        }
        /**
         * An event fired when keyboard focus receives a key event.
         * @param e The keyboard event.
         */
        onKeyboardEvent(e) {
            if (e.keyCode === 8) {
                if (this.currentSlotIndex === 0 && this.currentValue[0] !== '_') {
                    this.onSlotChanged(0, '_');
                }
                else if (this.currentSlotIndex === this.root.instance.length - 1 && this.currentValue[this.root.instance.length - 1] !== '_') {
                    this.onSlotChanged(this.root.instance.length - 1, '_');
                }
                else if (this.currentValue[0] !== '_') {
                    this.scroll('backward');
                    this.onSlotChanged(this.currentSlotIndex - 1, '_');
                }
                else {
                    this.focusSelf();
                }
            }
            else {
                const key = String.fromCharCode(e.keyCode).toUpperCase();
                if (InputSlot.CharacterMap.includes(key)) {
                    this.enableSlots();
                    this.onSlotChanged(this.currentSlotIndex, key);
                    this.scroll('forward');
                    this.currentSlotIndex = Math.min(this.currentSlotIndex + 1, this.root.instance.length - 1);
                }
            }
            e.preventDefault();
        }
        /**
         * An event triggered when keyboard focus is entered.
         * @param e The event that was triggered.
         */
        onKeyboardFocus(e) {
            var _a;
            e.preventDefault();
            this.enableSlots();
            (_a = this.root.instance.getChild(0)) === null || _a === void 0 ? void 0 : _a.focus(msfsSdk.FocusPosition.First);
            this.manageSelected();
            this.currentSlotIndex = this.root.instance.getFocusedIndex();
            this.textBox.instance.focus({ preventScroll: true });
            const underscoreIndex = this.currentValue.indexOf('_');
            let valWithoutUnderscores = this.currentValue;
            if (underscoreIndex !== -1) {
                valWithoutUnderscores = this.currentValue.substring(0, this.currentValue.indexOf('_'));
            }
            Coherent.on('SetInputTextFromOS', this.setValueFromOS);
            Coherent.trigger('FOCUS_INPUT_FIELD', this.inputId, '', '', valWithoutUnderscores, false);
            Coherent.on('mousePressOutsideView', () => {
                this.textBox.instance.blur();
            });
            this.keyboardIcon.instance.style.backgroundColor = 'cyan';
        }
        /**
         * An event triggered when keyboard focus is exited.
         * @param e The event that was triggered.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onKeyboardBlur(e) {
            e.preventDefault();
            Coherent.off('SetInputTextFromOS', this.setValueFromOS);
            Coherent.trigger('UNFOCUS_INPUT_FIELD', '');
            Coherent.off('mousePressOutsideView');
            this.keyboardIcon.instance.style.backgroundColor = 'transparent';
        }
        /**
         * Manages whether the inactive ref is selected.
         */
        manageSelected() {
            if (this.isEditing) {
                this.inactiveRef.instance.classList.remove('selected');
            }
            else if (this.isFocused) {
                this.inactiveRef.instance.classList.add('selected');
            }
            else {
                this.inactiveRef.instance.classList.remove('selected');
            }
        }
        /**
         * Updates this input's rendered editing-inactive value. If editing is currently active, the rendered editing-
         * inactive value will be hidden. If editing is not active, it will be displayed and updated to reflect this input's
         * current value.
         */
        updateInactiveDisplay() {
            var _a;
            if (!this.isEditing) {
                const index = this.currentValue.indexOf('_');
                this.inactiveRenderedValue = this.currentValue.substr(0, index < 0 ? (_a = this.props.length) !== null && _a !== void 0 ? _a : 5 : index);
                this.inactiveRef.instance.textContent = this.inactiveRenderedValue === '' ? ''.padEnd(this.props.length !== undefined ? this.props.length : 5, '_') : this.inactiveRenderedValue;
                this.inactiveRef.instance.style.display = '';
                this.activeRef.instance.style.display = 'none';
            }
            else {
                this.inactiveRef.instance.style.display = 'none';
                this.activeRef.instance.style.display = '';
                this.inactiveRef.instance.textContent = '';
            }
        }
        /**
         * Generates a unique id.
         * @returns A unique ID string.
         */
        genGuid() {
            return 'INPT-xxxyxxyy'.replace(/[xy]/g, function (c) {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `alpha-num-input ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`, ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'alpha-num-active alpha-num-input-width', ref: this.activeRef }, Array(this.props.length !== undefined ? this.props.length : 5).fill(0)
                        .map((val, index) => (msfsSdk.FSComponent.buildComponent(InputSlot, { onChanged: this.onSlotChanged.bind(this, index) })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'alpha-num-inactive alpha-num-input-width', ref: this.inactiveRef }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'alpha-num-keyboard', ref: this.keyboardRef },
                        this.props.enableKeyboard && msfsSdk.FSComponent.buildComponent("img", { ref: this.keyboardIcon, src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/keyboard.png', class: 'alpha-num-kb-icon' }),
                        this.props.enableKeyboard && msfsSdk.FSComponent.buildComponent("input", { id: this.inputId, tabindex: "-1", ref: this.textBox, width: "0px", style: "border:1px; background-color:black; opacity:0; display: inline-block;", type: "text", size: "1", maxLength: "5" })))));
        }
    }
    /**
     * A control that allows scrolling between alphanumeric characters.
     */
    class InputSlot extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.char = msfsSdk.Subject.create('_');
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onRightInnerInc() {
            return this.changeChar('inc');
        }
        /** @inheritdoc */
        onRightInnerDec() {
            return this.changeChar('dec');
        }
        /**
         * Changes the character in the input slot.
         * @param direction The direction to change in.
         * @returns Whether or not the change was handled.
         */
        changeChar(direction) {
            const currentIndex = InputSlot.CharacterMap.indexOf(this.char.get());
            let nextIndex = direction === 'inc' ? currentIndex + 1 : currentIndex - 1;
            if (nextIndex >= InputSlot.CharacterMap.length) {
                nextIndex = 0;
            }
            else if (nextIndex < 0) {
                nextIndex = InputSlot.CharacterMap.length - 1;
            }
            this.char.set(InputSlot.CharacterMap[nextIndex]);
            this.props.onChanged(this.char.get());
            return true;
        }
        /**
         * Sets the character value for the input slot.
         * @param val The value to set.
         */
        set(val) {
            this.char.set(val[0]);
        }
        /** @inheritdoc */
        onFocused() {
            this.el.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.el.instance.classList.remove('selected');
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: 'alpha-num-slot', ref: this.el }, this.char));
        }
    }
    InputSlot.CharacterMap = ['_', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

    /** The store for the DTO view */
    class GnsDirectToStore {
        /**
         * Constructor.
         *
         * @param waypoint A subscribable which provides the preview waypoint
         * @param planePos A subscribable which provides the current airplane position for this store.
         */
        constructor(waypoint, planePos) {
            this.planePos = planePos;
            this.courseInputValue = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(0));
            this.course = msfsSdk.Subject.create(undefined);
            this._matchedWaypoints = [];
            this.waypointInfoStore = new msfsGarminsdk.WaypointInfoStore(waypoint, planePos);
        }
        // eslint-disable-next-line jsdoc/require-returns
        /** A subject which provides this store's selected waypoint. */
        get waypoint() {
            return this.waypointInfoStore.waypoint;
        }
        // eslint-disable-next-line jsdoc/require-returns
        /** An array of waypoints which have matched the input. */
        get matchedWaypoints() {
            return this._matchedWaypoints;
        }
        // eslint-disable-next-line jsdoc/require-returns
        /** An array of icaos which have matched the input */
        get matchedIcaos() {
            return this.matchedWaypoints.map((it) => it.facility.get().icao);
        }
        /**
         * Set the list of matched waypoints.
         * @param waypoints An array of matched waypoints.
         */
        setMatchedWaypoints(waypoints) {
            this._matchedWaypoints = [...waypoints];
        }
    }

    /** The controller for the DTO view */
    class GnsDirectToController {
        /**
         * Creates an instance of direct to controller.
         * @param store This controller's associated direct to menu store.
         * @param fms The flight management system.
         * @param viewService The view service used by this controller.
         * @param goToActivateFunc A function which focuses the Activate button of this controller's associated view.
         */
        constructor(store, fms, viewService, goToActivateFunc) {
            this.store = store;
            this.fms = fms;
            this.viewService = viewService;
            this.goToActivateFunc = goToActivateFunc;
            this.inputIcao = msfsSdk.Subject.create('');
            this.canActivate = msfsSdk.Subject.create(false);
            this.matchedWaypointsChangedHandler = this.onMatchedWaypointsChanged.bind(this);
            this.waypointChangedHandler = this.onWaypointChanged.bind(this);
            this.inputEnterPressedHandler = this.onInputEnterPressed.bind(this);
            this.directToExistingData = null;
            this.directToExistingLegDefinition = null;
            this.obsState = msfsSdk.ConsumerValue.create(this.fms.bus.getSubscriber().on('obs_susp_mode'), msfsGarminsdk.ObsSuspModes.NONE);
            this.goToActivateOnWaypoint = false;
        }
        /**
         * Initializes the direct to target based on input data. If the input data is defined, the target will be set to that
         * defined by the input data. If the input data is undefined, an attempt will be made to set the target to the
         * following, in order:
         * * The current active direct to target.
         * * The current active flight plan leg.
         * * The next leg in the primary flight plan, following the active leg, that is a valid direct to target.
         * * The previous leg in the primary flight plan, before the active leg, that is a valid direct to target.
         * @param dtoData The input data.
         */
        initializeTarget(dtoData) {
            const primaryPlan = this.fms.hasPrimaryFlightPlan() && this.fms.getPrimaryFlightPlan();
            this.directToExistingData = null;
            let targetIcao = '';
            if (primaryPlan && (dtoData === null || dtoData === void 0 ? void 0 : dtoData.legIndex) !== undefined && (dtoData === null || dtoData === void 0 ? void 0 : dtoData.segmentIndex) !== undefined) {
                // Input defines a DTO existing target
                try {
                    if (this.fms.canDirectTo(dtoData.segmentIndex, dtoData.legIndex)) {
                        this.directToExistingData = GnsDirectToController.createDtoExistingData(primaryPlan, dtoData.segmentIndex, dtoData.legIndex);
                    }
                    else {
                        this.directToExistingData = this.searchForValidDtoExistingLeg(dtoData.segmentIndex, dtoData.legIndex);
                    }
                }
                catch (_a) {
                    // noop
                }
            }
            else if (dtoData !== undefined) {
                // Input defines a DTO random target
                targetIcao = dtoData.icao;
            }
            else {
                // No input -> initialize to current DTO target, or search for a valid DTO existing target starting with the
                // active leg
                const dtoState = this.fms.getDirectToState();
                if (dtoState === msfsGarminsdk.DirectToState.TOEXISTING && primaryPlan) {
                    this.directToExistingData = {
                        icao: primaryPlan.getLeg(primaryPlan.activeLateralLeg).leg.fixIcao,
                        segmentIndex: primaryPlan.directToData.segmentIndex,
                        segmentLegIndex: primaryPlan.directToData.segmentLegIndex
                    };
                }
                else if (dtoState === msfsGarminsdk.DirectToState.TORANDOM) {
                    const dtoPlan = this.fms.getDirectToFlightPlan();
                    targetIcao = dtoPlan.getLeg(dtoPlan.activeLateralLeg).leg.fixIcao;
                }
                else if (primaryPlan && primaryPlan.length > 0) {
                    this.directToExistingData = this.searchForValidDtoExistingLeg(Math.min(primaryPlan.activeLateralLeg, primaryPlan.length - 1));
                }
            }
            if (this.directToExistingData) {
                targetIcao = this.directToExistingData.icao;
            }
            if (this.inputIcao.get() === targetIcao) {
                this.syncCourseInput();
            }
            else {
                this.inputIcao.set(targetIcao);
            }
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        searchForValidDtoExistingLeg(arg1, arg2) {
            const plan = this.fms.getPrimaryFlightPlan();
            const legIndex = arg2 === undefined
                ? arg1
                : plan.getSegment(arg1).offset + arg2;
            let dtoExisting = null;
            // search forwards in plan
            const len = plan.length;
            for (let i = legIndex; i < len; i++) {
                const currSegmentIndex = plan.getSegmentIndex(i);
                const currSegmentLegIndex = i - plan.getSegment(currSegmentIndex).offset;
                if (this.fms.canDirectTo(currSegmentIndex, currSegmentLegIndex)) {
                    dtoExisting = GnsDirectToController.createDtoExistingData(plan, currSegmentIndex, currSegmentLegIndex);
                    break;
                }
            }
            if (!dtoExisting) {
                // search backwards in plan
                for (let i = legIndex - 1; i >= 0; i--) {
                    const currSegmentIndex = plan.getSegmentIndex(i);
                    const currSegmentLegIndex = i - plan.getSegment(currSegmentIndex).offset;
                    if (this.fms.canDirectTo(currSegmentIndex, currSegmentLegIndex)) {
                        dtoExisting = GnsDirectToController.createDtoExistingData(plan, currSegmentIndex, currSegmentLegIndex);
                        break;
                    }
                }
            }
            return dtoExisting;
        }
        /**
         * Responds to changes in the waypoint input's matched waypoints list.
         * @param waypoints The matched waypoints.
         */
        onMatchedWaypointsChanged(waypoints) {
            this.store.setMatchedWaypoints(waypoints);
        }
        /**
         * Responds to changes in the waypoint input's selected waypoint.
         * @param waypoint The selected waypoint.
         */
        async onWaypointChanged(waypoint) {
            var _a;
            const facility = waypoint !== null && msfsSdk.FacilityWaypointUtils.isFacilityWaypoint(waypoint) ? waypoint.facility.get() : null;
            if ((facility === null || facility === void 0 ? void 0 : facility.icao) !== ((_a = this.directToExistingData) === null || _a === void 0 ? void 0 : _a.icao)) {
                this.directToExistingData = null;
                const plan = this.fms.hasPrimaryFlightPlan() && this.fms.getPrimaryFlightPlan();
                if (plan && facility) {
                    if (this.directToExistingLegDefinition !== null) {
                        const indexes = msfsGarminsdk.FmsUtils.getLegIndexes(plan, this.directToExistingLegDefinition);
                        if (indexes && this.directToExistingLegDefinition.leg.fixIcao === facility.icao && this.fms.canDirectTo(indexes.segmentIndex, indexes.segmentLegIndex)) {
                            this.directToExistingData = {
                                segmentIndex: indexes.segmentIndex,
                                segmentLegIndex: indexes.segmentLegIndex,
                                icao: facility.icao
                            };
                        }
                    }
                    if (this.directToExistingData === null) {
                        for (let i = 0; i < plan.length; i++) {
                            const segmentIndex = plan.getSegmentIndex(i);
                            const segment = plan.getSegment(segmentIndex);
                            const segmentLegIndex = i - segment.offset;
                            const leg = segment.legs[segmentLegIndex];
                            if (leg.leg.fixIcao === facility.icao && this.fms.canDirectTo(segmentIndex, segmentLegIndex)) {
                                this.directToExistingData = {
                                    segmentIndex,
                                    segmentLegIndex,
                                    icao: facility.icao
                                };
                            }
                        }
                    }
                }
            }
            this.directToExistingLegDefinition = null;
            this.store.waypoint.set(waypoint);
            this.syncCourseInput();
            const canActivate = !!facility;
            this.canActivate.set(canActivate);
            if (canActivate && this.goToActivateOnWaypoint) {
                this.goToActivateFunc();
            }
            this.goToActivateOnWaypoint = false;
        }
        /**
         * Syncs the course input value with the bearing to the selected waypoint.
         */
        syncCourseInput() {
            const bearing = this.store.waypointInfoStore.bearing.get().asUnit(GnsDirectToController.BEARING_MAGNETIC);
            let input = 0;
            if (!isNaN(bearing)) {
                input = 360 - (360 - Math.round(bearing) % 360) % 360;
            }
            this.store.courseInputValue.set(input);
            this.store.course.set(undefined);
        }
        /**
         * Responds to Enter button press events from the waypoint input.
         */
        onInputEnterPressed() {
            const matchedWaypoints = this.store.matchedWaypoints;
            if (matchedWaypoints.length > 1) {
                const matchedIcaos = this.store.matchedIcaos;
                ViewService.resolveDups(msfsSdk.ICAO.getIdent(matchedIcaos[0]).trim(), matchedIcaos).then((facility) => {
                    this.onWptDupDialogAccept(facility);
                });
            }
            else {
                this.goToActivateFunc();
            }
        }
        /**
         * Responds to accept events from the waypoint duplicate dialog.
         * @param facility The facility returned by the waypoint duplicate dialog.
         */
        onWptDupDialogAccept(facility) {
            if (!facility) {
                return;
            }
            if (this.inputIcao.get() === facility.icao) {
                // If the selected waypoint is equal to the disambiguated waypoint, force notify the waypoint input control
                // (otherwise it will not think disambiguation has occurred) then manually select the activate button since
                // the onWaypointChanged callback won't be called.
                this.inputIcao.notify();
            }
            else {
                this.inputIcao.set(facility.icao);
            }
            this.goToActivateFunc();
        }
        /**
         * Activates a Direct To to the selected waypoint.
         */
        activateSelected() {
            var _a, _b;
            const selectedWaypoint = this.store.waypoint.get();
            const facility = selectedWaypoint !== null && msfsSdk.FacilityWaypointUtils.isFacilityWaypoint(selectedWaypoint) ? selectedWaypoint.facility.get() : null;
            const course = this.store.course.get();
            const segmentIndex = (_a = this.directToExistingData) === null || _a === void 0 ? void 0 : _a.segmentIndex;
            const segmentLegIndex = (_b = this.directToExistingData) === null || _b === void 0 ? void 0 : _b.segmentLegIndex;
            const activate = () => {
                if (segmentIndex !== undefined && segmentLegIndex !== undefined) {
                    this.fms.createDirectToExisting(segmentIndex, segmentLegIndex, course);
                }
                else {
                    facility !== null && this.fms.createDirectToRandom(facility, course);
                }
            };
            if (this.obsState.get() === msfsGarminsdk.ObsSuspModes.OBS) {
                this.awaitObsCancel().then(() => {
                    activate();
                });
            }
            else {
                activate();
            }
        }
        /**
         * Awaits the cancellation of OBS to activate a direct to.
         * @returns A promise when the obs has been deactivated.
         */
        async awaitObsCancel() {
            SimVar.SetSimVarValue('K:GPS_OBS_OFF', 'number', 0);
            this.fms.bus.getPublisher().pub('suspend_sequencing', false);
            return new Promise(resolve => {
                const sub = this.fms.bus.getSubscriber().on('gps_obs_active').whenChanged().handle(isActive => {
                    if (!isActive) {
                        sub.destroy();
                        resolve();
                    }
                }, true);
                sub.resume(true);
            });
        }
        /**
         * Creates a direct to existing data object for a flight plan leg.
         * @param plan A flight plan.
         * @param segmentIndex The index of the segment in which the leg resides.
         * @param segmentLegIndex The index of the leg in its segment.
         * @returns A direct to existing data object.
         */
        static createDtoExistingData(plan, segmentIndex, segmentLegIndex) {
            return {
                icao: plan.getSegment(segmentIndex).legs[segmentLegIndex].leg.fixIcao,
                segmentIndex,
                segmentLegIndex
            };
        }
    }
    GnsDirectToController.BEARING_MAGNETIC = msfsSdk.BasicNavAngleUnit.create(true);

    /**
     * Menu for {@link DirectToDialog}
     */
    class DirectToDialogMenu extends MenuDefinition {
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        constructor(directToInactive, cancelDirectTo) {
            super();
            this.directToInactive = directToInactive;
            this.cancelDirectTo = cancelDirectTo;
            this.entries = [
                {
                    label: 'Cancel Direct-To NAV?',
                    disabled: this.directToInactive,
                    action: () => {
                        this.cancelDirectTo();
                        ViewService.back();
                        ViewService.open('NAV', true, 1);
                    }
                },
            ];
        }
    }
    /**
     * DIRECT TO dialog
     */
    class DirectToDialog extends Dialog {
        constructor() {
            super(...arguments);
            this.nearestAirportInputRef = msfsSdk.FSComponent.createRef();
            this.nearestAirportDialogRef = msfsSdk.FSComponent.createRef();
            this.flightPlanWaypointsInputRef = msfsSdk.FSComponent.createRef();
            this.flightPlanWaypointsDialogRef = msfsSdk.FSComponent.createRef();
            this.directToInactive = msfsSdk.Subject.create(true);
            this.menu = new DirectToDialogMenu(this.directToInactive, () => {
                return this.cancelDirectTo();
            });
            this.pposSub = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.previewFacility = msfsSdk.Subject.create(null);
            this.previewWaypoint = this.previewFacility.map((it) => {
                if (it) {
                    return new msfsSdk.BasicFacilityWaypoint(it, this.props.bus);
                }
                else {
                    return null;
                }
            });
            this.store = new GnsDirectToStore(this.previewWaypoint, this.pposSub);
            this.controller = new GnsDirectToController(this.store, this.props.fms, ViewService, () => {
                this.input.instance.blur();
                this.root.instance.focus(msfsSdk.FocusPosition.Last);
            });
            this.angleUnit = msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE);
            this.input = msfsSdk.FSComponent.createRef();
            this.activatePromptContainer = msfsSdk.FSComponent.createRef();
            this.activatePrompt = msfsSdk.FSComponent.createRef();
            this.name = msfsSdk.Subject.create('____________________');
            this.city = msfsSdk.Subject.create('____________________');
            this.region = msfsSdk.Subject.create('__________');
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
            this.icon = msfsSdk.FSComponent.createRef();
            this.matchingIcaos = [];
            this.nearestAirports = msfsSdk.ArraySubject.create([]);
            this.nearestAirportInput = msfsSdk.Subject.create('');
            this.flightPlanWaypointChoices = msfsSdk.ArraySubject.create([]);
            this.flightPlanWaypointInput = msfsSdk.Subject.create('');
            this.cancelDirectTo = () => {
                switch (this.props.fms.getDirectToState()) {
                    case msfsGarminsdk.DirectToState.TOEXISTING:
                        {
                            const plan = this.props.fms.getPrimaryFlightPlan();
                            plan.directToData.segmentIndex > -1 && this.props.fms.activateLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                        }
                        break;
                    case msfsGarminsdk.DirectToState.TORANDOM:
                        if (!this.props.fms.activateNearestLeg()) {
                            this.props.fms.cancelDirectTo();
                        }
                }
            };
        }
        /**
         * Accepts a facility to be the new preview facility and therefore waypoint
         *
         * @param facility The facility to set.
         * @param legDefinition The leg definition.
         */
        acceptPreviewFacility(facility, legDefinition) {
            this.previewFacility.set(facility);
            this.controller.directToExistingLegDefinition = legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
            this.input.instance.set(msfsSdk.ICAO.getIdent(facility.icao));
            this.input.instance.focusSelf();
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber()
                .on('gps-position')
                .handle(pos => this.pposSub.set(pos.lat, pos.long));
            // Connect store waypoint to controller
            this.store.waypoint.sub((waypoint) => this.controller.waypointChangedHandler(waypoint));
            // Connect waypoint info
            this.controller.inputIcao.sub(async (icao) => {
                const facility = await this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao);
                if (facility) {
                    this.acceptPreviewFacility(facility);
                }
                else {
                    console.error('Facility ICAO given by DTO controller could not be found');
                }
            });
            this.store.waypointInfoStore.name.sub((name) => this.name.set(name !== null && name !== void 0 ? name : '____________________'));
            this.store.waypointInfoStore.city.sub((name) => this.city.set(name !== null && name !== void 0 ? name : '____________________'));
            this.store.waypointInfoStore.region.sub((name) => this.region.set(name !== null && name !== void 0 ? name : '__________'));
            this.store.waypoint.sub((waypoint) => {
                if (waypoint === null || waypoint === void 0 ? void 0 : waypoint.location) {
                    this.position.set(waypoint === null || waypoint === void 0 ? void 0 : waypoint.location.get());
                }
                this.updateIcon(waypoint);
            });
            // Connect `Activate?` prompt to controller state
            this.controller.canActivate.sub((canActivate) => {
                if (canActivate) {
                    this.activatePromptContainer.instance.classList.remove('hidden-element');
                    this.activatePrompt.instance.setDisabled(false);
                }
                else {
                    this.activatePromptContainer.instance.classList.add('hidden-element');
                    this.activatePrompt.instance.setDisabled(true);
                }
            });
            // Connect NearestContext airports to list
            msfsSdk.NearestContext.onInitialized((instance) => {
                instance.airports.sub((index, type, item) => {
                    switch (type) {
                        case msfsSdk.SubscribableArrayEventType.Added:
                            this.nearestAirports.insert(item, index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Removed:
                            this.nearestAirports.removeAt(index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Cleared:
                            this.nearestAirports.clear();
                            break;
                    }
                });
            });
            // Connect nearest airports list to dialog items
            this.nearestAirports.sub((_, __, ___, array) => {
                if (array.length > 0) {
                    const first = array[0];
                    this.nearestAirportInput.set(msfsSdk.ICAO.getIdent(first.icao));
                    this.nearestAirportInputRef.instance.setDisabled(false);
                    this.nearestAirportDialogRef.instance.setItems(array.map((it) => msfsSdk.ICAO.getIdent(it.icao)), false);
                }
                else {
                    this.nearestAirportInput.set('');
                    this.nearestAirportInputRef.instance.setDisabled(true);
                    this.nearestAirportDialogRef.instance.setItems([], false);
                }
            });
            // Connect flight plan waypoint choices list to dialog items
            this.flightPlanWaypointChoices.sub((_, __, ___, array) => {
                if (array.length > 0) {
                    const first = array[0];
                    this.flightPlanWaypointInput.set(first.ident);
                    this.flightPlanWaypointsInputRef.instance.setDisabled(false);
                    this.flightPlanWaypointsDialogRef.instance.setItems(array.map((it) => it.ident), false);
                }
                else {
                    this.flightPlanWaypointInput.set('');
                    this.flightPlanWaypointsInputRef.instance.setDisabled(true);
                    this.flightPlanWaypointsDialogRef.instance.setItems([], false);
                }
            });
            this.handleClosePopup(this.nearestAirportDialogRef);
            // Connect preview facility to what is currently blurred in the FPL and NRST selectors
            this.previewFacility.sub((facility) => {
                if (facility) {
                    const ident = msfsSdk.ICAO.getIdent(facility === null || facility === void 0 ? void 0 : facility.icao);
                    const currentFplnIdent = this.flightPlanWaypointInput.get();
                    this.flightPlanWaypointsInputRef.instance.setDarkened(ident !== currentFplnIdent);
                    const currentNearestAirportIdent = this.nearestAirportInput.get();
                    this.nearestAirportInputRef.instance.setDarkened(ident !== currentNearestAirportIdent);
                }
            });
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (this.nearestAirportDialogRef.instance.isFocused) {
                const handled = this.nearestAirportDialogRef.instance.onInteractionEvent(evt);
                if (handled) {
                    return true;
                }
            }
            if (this.flightPlanWaypointsDialogRef.instance.isFocused) {
                const handled = this.flightPlanWaypointsDialogRef.instance.onInteractionEvent(evt);
                if (handled) {
                    return true;
                }
            }
            if (evt === InteractionEvent.CLR) {
                if (this.isInputActive()) {
                    this.input.instance.focusSelf();
                    this.clear();
                    return true;
                }
                else {
                    return false;
                }
            }
            if (evt === InteractionEvent.DirectTo) {
                if (this.controller.directToExistingLegDefinition !== null) {
                    ViewService.activateLegDialog(this.props.fms.getPrimaryFlightPlan().getLegIndexFromLeg(this.controller.directToExistingLegDefinition));
                    return true;
                }
                else {
                    ViewService.back();
                    return true;
                }
            }
            if (evt === InteractionEvent.FPL || evt === InteractionEvent.VNAV || evt === InteractionEvent.PROC || evt === InteractionEvent.OBS) {
                ViewService.back();
            }
            if (evt === InteractionEvent.MENU) {
                switch (this.props.fms.getDirectToState()) {
                    case msfsGarminsdk.DirectToState.TOEXISTING:
                    case msfsGarminsdk.DirectToState.TORANDOM:
                        this.directToInactive.set(false);
                        break;
                    default:
                        this.directToInactive.set(true);
                }
                ViewService.menu(this.menu);
                return true;
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritDoc */
        onResume() {
            this.input.instance.enableSlots();
            // We only want to start with a region letter input if there wasn't already a preview facility set by something else, for example,
            // a FPL page action
            if (!this.previewFacility.get()) {
                this.trySetActiveLegAsPreviewTarget().then((set) => {
                    if (!set) {
                        const inputPrefix = msfsSdk.NearestContext.getInstance().getRegionIdent();
                        if (inputPrefix !== undefined) {
                            this.input.instance.set(inputPrefix);
                            this.onIdentChanged(inputPrefix);
                        }
                    }
                    this.prepareFlightPlanLegChoices();
                    super.onResume();
                });
            }
            else {
                this.prepareFlightPlanLegChoices();
                super.onResume();
            }
        }
        /** @inheritDoc */
        onSuspend() {
            super.onSuspend();
            this.clear();
        }
        /**
         * Checks to see if the input is active by checking if any character slots
         * are focused.
         * @returns True if active, false otherwise.
         */
        isInputActive() {
            var _a;
            for (let i = 0; i < this.input.instance.length; i++) {
                if ((_a = this.input.instance.getChild(i)) === null || _a === void 0 ? void 0 : _a.isFocused) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Clears the waypoint info display.
         */
        clear() {
            this.previewFacility.set(null);
            this.directToFacility = undefined;
            this.activatePromptContainer.instance.classList.add('hidden-element');
            this.activatePrompt.instance.setDisabled(true);
            this.matchingIcaos.length = 0;
            this.input.instance.set('');
            this.controller.matchedWaypointsChangedHandler([]);
        }
        /**
         * Handles when the ident is changed in the input control.
         * @param ident The new ident.
         */
        async onIdentChanged(ident) {
            this.previewFacility.set(null);
            this.controller.matchedWaypointsChangedHandler([]);
            if (this.debounceTimeout !== undefined) {
                window.clearTimeout(this.debounceTimeout);
            }
            this.debounceTimeout = window.setTimeout(() => this.loadIdent(ident), 250);
        }
        /**
         * Loads an ident into the waypoint display.
         * @param ident The ident to search for.
         */
        async loadIdent(ident) {
            const icaos = await this.props.fms.facLoader.searchByIdent(msfsSdk.FacilitySearchType.All, ident, 10);
            if (icaos.length !== 0) {
                const facilityIdent = msfsSdk.ICAO.getIdent(icaos[0]).trim();
                this.matchingIcaos = icaos.filter(icao => msfsSdk.ICAO.getIdent(icao).trim() === facilityIdent);
                const facilities = await Promise.all(this.matchingIcaos.map(icao => this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao)));
                this.previewFacility.set(facilities.sort((a, b) => this.orderByPPosDistance(a, b))[0]);
                const waypoints = facilities.map((it) => new msfsSdk.BasicFacilityWaypoint(it, this.props.bus));
                this.controller.matchedWaypointsChangedHandler(waypoints);
            }
        }
        /**
         * Updates the waypoint icon display.
         * @param waypoint The waypoint to get the icon for.
         */
        updateIcon(waypoint) {
            if (waypoint !== null && msfsSdk.FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
                this.icon.instance.src = Icons.getByFacility(waypoint.facility.get()).src;
            }
            else {
                this.icon.instance.src = '';
            }
        }
        /**
         * Orders facilities by their distance to the plane PPOS.
         * @param a The first facility.
         * @param b The second facility.
         * @returns The comparison order number.
         */
        orderByPPosDistance(a, b) {
            const aDist = this.pposSub.get().distance(a.lat, a.lon);
            const bDist = this.pposSub.get().distance(b.lat, b.lon);
            if (aDist < bDist) {
                return -1;
            }
            if (aDist > bDist) {
                return 1;
            }
            return 0;
        }
        /**
         * Handles ENT being pressed on the ident input
         *
         * @returns true
         */
        handleIdentInputEnt() {
            this.controller.inputEnterPressedHandler();
            return true;
        }
        /**
         * Handles opening a popup
         *
         * @param popup the popup to open
         *
         * @returns true
         */
        handleOpenPopup(popup) {
            this.root.instance.blur();
            popup.instance.openPopout(0);
            popup.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * Handles closing a popup
         *
         * @param popup the popup to close
         *
         * @returns true
         */
        handleClosePopup(popup) {
            popup.instance.closePopout();
            popup.instance.blur();
            this.root.instance.focus(msfsSdk.FocusPosition.MostRecent);
            return true;
        }
        /**
         * Prepares the dialog list of flight plan legs for the FPL selection
         */
        prepareFlightPlanLegChoices() {
            var _a;
            if (this.props.fms.hasPrimaryFlightPlan()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                this.flightPlanWaypointChoices.clear();
                const legs = Array.from(plan.legs());
                for (let i = 0; i < legs.length; i++) {
                    const leg = legs[i];
                    const isEligible = [msfsSdk.LegType.CF, msfsSdk.LegType.DF, msfsSdk.LegType.IF, msfsSdk.LegType.TF].includes(leg.leg.type);
                    if (!isEligible) {
                        continue;
                    }
                    this.flightPlanWaypointChoices.insert({ index: i, ident: (_a = leg === null || leg === void 0 ? void 0 : leg.name) !== null && _a !== void 0 ? _a : 'noname', icao: leg.leg.fixIcao });
                }
            }
        }
        /**
         * Trys to set the active leg as the preview facility.
         * @returns Whether the active leg was set as the preview facility.
         */
        async trySetActiveLegAsPreviewTarget() {
            if (this.props.fms.flightPlanner.hasActiveFlightPlan()) {
                const plan = this.props.fms.flightPlanner.getActiveFlightPlan();
                const leg = plan.tryGetLeg(plan.activeLateralLeg);
                if (leg) {
                    const legFacilityIcao = leg.leg.fixIcao;
                    const facility = await this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(legFacilityIcao), legFacilityIcao).catch((e) => {
                        console.error('Could not get facility from leg fixIcao for opening DIRECT TO dialog. See error below');
                        throw e;
                    });
                    this.acceptPreviewFacility(facility, leg);
                    return true;
                }
            }
            return false;
        }
        /** @inheritDoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "dto-dialog" },
                msfsSdk.FSComponent.buildComponent("h2", { class: "white" },
                    "SELECT",
                    msfsSdk.FSComponent.buildComponent("img", { class: "dto-title-icon", src: msfsSdk.ImageCache.get('LEGICON_DIRECTTO_WHITE').src }),
                    "WAYPOINT"),
                msfsSdk.FSComponent.buildComponent("hr", { class: 'hide-title' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'dto-waypoint-info' },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "cyan hide-title" }, "IDENT, FACILITY, & CITY"),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'dto-waypoint-info-identbox' },
                        msfsSdk.FSComponent.buildComponent(AlphaNumInput, { class: 'dto-waypoint-info-input', onChanged: this.onIdentChanged.bind(this), ref: this.input, onEnt: this.handleIdentInputEnt.bind(this), gnsType: this.props.gnsType, enableKeyboard: true }),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'dto-waypoint-info-icon' },
                            msfsSdk.FSComponent.buildComponent("img", { ref: this.icon })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'dto-waypoint-info-region' }, this.region),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'dto-waypoint-info-name' }, this.name),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'dto-waypoint-info-city' }, this.city))),
                msfsSdk.FSComponent.buildComponent("div", { class: "dto-separator" }),
                msfsSdk.FSComponent.buildComponent("div", { class: "dto-middle-container" },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "cyan dto-fpln-title" }, "FPL"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table dto-fpln" },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.flightPlanWaypointsInputRef, data: this.flightPlanWaypointInput, onRightInnerDec: () => {
                                this.prepareFlightPlanLegChoices();
                                this.handleOpenPopup(this.flightPlanWaypointsDialogRef);
                                return true;
                            }, onRightInnerInc: () => {
                                this.prepareFlightPlanLegChoices();
                                this.handleOpenPopup(this.flightPlanWaypointsDialogRef);
                                return true;
                            }, class: 'dto-fpln-nrst-inside', darkenedClass: "darkened-green" })),
                    msfsSdk.FSComponent.buildComponent("h2", { class: "cyan dto-nrst-title" }, "NRST"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "aux-table dto-nrst" },
                        msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.nearestAirportInputRef, data: this.nearestAirportInput, onRightInnerDec: this.handleOpenPopup.bind(this, this.nearestAirportDialogRef), onRightInnerInc: this.handleOpenPopup.bind(this, this.nearestAirportDialogRef), class: 'dto-fpln-nrst-inside', darkenedClass: "darkened-green" }))),
                msfsSdk.FSComponent.buildComponent("div", { class: "dto-separator" }),
                msfsSdk.FSComponent.buildComponent("div", { class: "dto-bottom-container" },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "cyan  hide-title" }, "POSITION"),
                    msfsSdk.FSComponent.buildComponent("h2", { class: "cyan crs-position" }, "CRS"),
                    msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { class: "aux-table dto-waypoint-info-posbox", location: this.position }),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("div", { class: "aux-table dto-course" },
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.store.courseInputValue, displayUnit: this.angleUnit, digitizer: (value, signValues, digitValues) => {
                                    digitValues[0].set(Math.floor(value / 10) * 10);
                                    digitValues[1].set(Math.floor(value % 10));
                                }, editOnActivate: false, class: '', renderInactiveValue: (value) => (msfsSdk.FSComponent.buildComponent("div", null,
                                    value.toFixed(0).padStart(3, '0'),
                                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit }))), onInputAccepted: (v) => {
                                    this.store.course.set(v);
                                } },
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 36, increment: 1, scale: 10, wrap: true, formatter: (v) => v.toString().padStart(2, '0') }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit }))),
                        msfsSdk.FSComponent.buildComponent("div", { ref: this.activatePromptContainer },
                            msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.activatePrompt, class: "dto-activate-prompt", selectedClass: "selected-white", data: msfsSdk.Subject.create('Activate?'), onEnt: () => {
                                    this.controller.activateSelected();
                                    ViewService.back();
                                    return true;
                                } })))),
                msfsSdk.FSComponent.buildComponent("div", { class: "white-box" })));
        }
        /** @inheritDoc */
        renderOuterDialog() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.nearestAirportDialogRef, class: "dto-nearest-airport-dialog", label: "NEAREST", onSelected: (index) => {
                        const airport = this.nearestAirports.get(index);
                        this.nearestAirportInput.set(msfsSdk.ICAO.getIdent(airport.icao));
                        this.acceptPreviewFacility(airport);
                        this.handleClosePopup(this.nearestAirportDialogRef);
                    } }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.flightPlanWaypointsDialogRef, class: "dto-flight-plan-waypoints-dialog", label: "FPL", onSelected: (index) => {
                        const leg = this.flightPlanWaypointChoices.get(index);
                        this.flightPlanWaypointInput.set(leg.ident);
                        this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(leg.icao), leg.icao).then((facility) => {
                            this.acceptPreviewFacility(facility);
                        });
                        this.handleClosePopup(this.flightPlanWaypointsDialogRef);
                    } })));
        }
    }

    /**
     * A dialog that allows a selection from duplicate waypoints.
     */
    class DupWaypoints extends Dialog {
        constructor() {
            super(...arguments);
            this.ppos = new msfsSdk.GeoPoint(0, 0);
            this.ident = msfsSdk.Subject.create('');
            this.facilities = msfsSdk.ArraySubject.create();
            this.duplicatesList = msfsSdk.FSComponent.createRef();
            this.resolve = () => { };
        }
        /**
         * Sets the ident to display in the dialog.
         * @param ident The ident to display.
         */
        setIdent(ident) {
            this.ident.set(ident);
        }
        /**
         * Sets the facilities to display in the dialog.
         * @param icaos The icaos of the facilities to display.
         */
        setIcaos(icaos) {
            this.facilities.clear();
            Promise.all(icaos.map(icao => this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao)))
                .then(facs => {
                this.facilities.insertRange(0, facs);
                this.duplicatesList.instance.updateOrder();
                this.duplicatesList.instance.focus(msfsSdk.FocusPosition.First);
            });
        }
        /**
         * Sets the dialog promise resolution function.
         * @param resolve The promise resolution function with which to resolve the dialog.
         */
        setResolve(resolve) {
            this.resolve = resolve;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber()
                .on('gps-position')
                .handle(pos => this.ppos.set(pos.lat, pos.long));
        }
        /**
         * Orders facilities by their distance to the plane PPOS.
         * @param a The first facility.
         * @param b The second facility.
         * @returns The comparison order number.
         */
        orderByPPosDistance(a, b) {
            const aDist = this.ppos.distance(a.lat, a.lon);
            const bDist = this.ppos.distance(b.lat, b.lon);
            if (aDist < bDist) {
                return -1;
            }
            if (aDist > bDist) {
                return 1;
            }
            return 0;
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "DUPLICATE WAYPOINTS"),
                msfsSdk.FSComponent.buildComponent("hr", null),
                msfsSdk.FSComponent.buildComponent("div", { class: 'dup-waypoints-ident' },
                    msfsSdk.FSComponent.buildComponent("span", null, "WPT"),
                    " ",
                    this.ident),
                msfsSdk.FSComponent.buildComponent(GNSUiControlList, { class: 'dup-waypoints-list', data: this.facilities, renderItem: (data) => msfsSdk.FSComponent.buildComponent(DupWaypoint, { facility: data, onSelected: this.resolve }), orderBy: this.orderByPPosDistance.bind(this), ref: this.duplicatesList })));
        }
    }
    /**
     * A duplicate waypoint item in the duplicate waypoints list.
     */
    class DupWaypoint extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.region = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onFocused() {
            this.region.instance.classList.add('selected-white');
        }
        /** @inheritdoc */
        onBlurred() {
            this.region.instance.classList.remove('selected-white');
        }
        /** @inheritdoc */
        onEnt() {
            this.props.onSelected(this.props.facility);
            return true;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'dup-waypoint' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'dup-waypoint-type' }, this.getTypeLabel()),
                msfsSdk.FSComponent.buildComponent("div", { class: 'dup-waypoint-icon' },
                    msfsSdk.FSComponent.buildComponent("img", { src: Icons.getByFacility(this.props.facility).src })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'dup-waypoint-region', ref: this.region }, this.getRegion().substr(0, 14))));
        }
        /**
         * Gets the type label for the given facility.
         * @returns The facility's type label.
         */
        getTypeLabel() {
            const type = msfsSdk.ICAO.getFacilityType(this.props.facility.icao);
            switch (type) {
                case msfsSdk.FacilityType.Airport:
                    return 'APT';
                case msfsSdk.FacilityType.NDB:
                    return 'NDB';
                case msfsSdk.FacilityType.VOR:
                    return 'VOR';
                case msfsSdk.FacilityType.USR:
                    return 'USR';
                case msfsSdk.FacilityType.Intersection:
                    return 'INT';
                default:
                    return 'UNK';
            }
        }
        /**
         * Gets a region label for the facility.
         * @returns The facility's region label.
         */
        getRegion() {
            const facilityIdent = msfsSdk.ICAO.getIdent(this.props.facility.icao).trim();
            if (msfsSdk.ICAO.getFacilityType(this.props.facility.icao) === msfsSdk.FacilityType.Airport) {
                let region = facilityIdent.length === 4 ? msfsGarminsdk.Regions.getName(facilityIdent.substr(0, 2)) : '';
                if (region === '' && this.props.facility.city !== '') {
                    region = this.props.facility.city.split(', ').map(v => Utils.Translate(v)).join(', ');
                }
                return (region === '' ? 'UNKNOWN' : region.toUpperCase().substr(0, 10));
            }
            else {
                const region = msfsGarminsdk.Regions.getName(this.props.facility.icao.substr(1, 2));
                return (region === '' ? 'UNKNOWN' : region);
            }
        }
    }

    /**
     * A dialog that displays a popup menu dialog.
     */
    class MenuDialog extends Dialog {
        constructor() {
            super(...arguments);
            this.menuItems = msfsSdk.ArraySubject.create();
            this.hrEl = msfsSdk.FSComponent.createRef();
            this.list = msfsSdk.FSComponent.createRef();
            this.title = msfsSdk.Subject.create('PAGE MENU');
        }
        /**
         * Sets the menu items that should display in this menu dialog.
         * @param items The menu items to display.
         */
        setMenuItems(items) {
            var _a;
            this.menuItems.clear();
            this.menuItems.insertRange(0, items);
            const listEl = (_a = this.hrEl.instance.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector('.menu-list');
            if (listEl !== null) {
                listEl.style.height = `${Math.min(items.length * 16, 176)}px`;
            }
        }
        /**
         * Sets the menu title.
         * @param title The title of the menu.
         */
        setTitle(title) {
            this.title.set(title);
        }
        /**
         * Sets the currently selected item in the list.
         * @param index The index of the item to select.
         */
        setSelectedItem(index) {
            var _a;
            (_a = this.list.instance.getChild(index)) === null || _a === void 0 ? void 0 : _a.focus(msfsSdk.FocusPosition.First);
        }
        /** @inheritdoc */
        onSelected(item) {
            if (typeof item.props.data.action === 'function') {
                item.props.data.action();
            }
            else {
                item.props.data.action.get()();
            }
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.MENU) {
                ViewService.back();
                return true;
            }
            let handled = false;
            if (evt === InteractionEvent.RightInnerInc) {
                handled = this.list.instance.onInteractionEvent(evt);
            }
            if (evt === InteractionEvent.RightInnerDec) {
                handled = this.list.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.title.set('PAGE MENU');
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, this.title),
                msfsSdk.FSComponent.buildComponent("hr", { ref: this.hrEl }),
                msfsSdk.FSComponent.buildComponent(GNSUiControlList, { ref: this.list, class: 'menu-list', data: this.menuItems, renderItem: (data) => msfsSdk.FSComponent.buildComponent(DialogMenuItem, { data: data, onSelected: this.onSelected.bind(this) }), innerKnobScroll: true })));
        }
    }
    /**
     * An item in the menu list dialog.
     */
    class DialogMenuItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            if (typeof this.props.data.disabled !== 'boolean') {
                this.disabledSub = this.props.data.disabled.sub(this.setDisabled.bind(this), true);
            }
            else {
                this.setDisabled(this.props.data.disabled);
            }
        }
        /** @inheritdoc */
        onDisabled() {
            this.el.instance.classList.add('disabled');
        }
        /** @inheritdoc */
        onEnabled() {
            this.el.instance.classList.remove('disabled');
        }
        /** @inheritdoc */
        onFocused() {
            this.el.instance.classList.add('selected-white');
        }
        /** @inheritdoc */
        onBlurred() {
            this.el.instance.classList.remove('selected-white');
        }
        /** @inheritdoc */
        onEnt() {
            this.props.onSelected(this);
            return true;
        }
        /** @inheritdoc */
        destroy() {
            super.destroy();
            if (this.disabledSub !== undefined) {
                this.disabledSub.destroy();
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'menu-list-item', ref: this.el }, this.props.data.label));
        }
    }

    /**
     * OBS dialog
     */
    class ObsDialog extends Dialog {
        /** @inheritDoc */
        constructor(props) {
            super(props);
            this.courseInput = msfsSdk.FSComponent.createRef();
            this.cancelObsPrompt = msfsSdk.FSComponent.createRef();
            this.controlPublisher = new msfsSdk.ControlPublisher(this.props.bus);
            this.angleUnit = msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE);
            this.course = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(0));
            this.obsMode = msfsSdk.ConsumerSubject.create(null, msfsGarminsdk.ObsSuspModes.NONE);
            this.navObsValue = msfsSdk.ConsumerSubject.create(null, 0);
            const sub = this.props.bus.getSubscriber();
            this.obsMode.setConsumer(sub.on('obs_susp_mode'));
            this.navObsValue.setConsumer(sub.on('nav_obs_1'));
            // Sync NAV OBS with GPS OBS VALUE if OBS is enabled
            msfsSdk.MappedSubject.create(this.obsMode, this.navObsValue).sub(([obsMode, navObsValue]) => {
                if (obsMode === msfsGarminsdk.ObsSuspModes.OBS) {
                    this.course.set(msfsSdk.UnitType.DEGREE.createNumber(navObsValue));
                    this.handleSetObsCourse(navObsValue);
                }
            });
            // Show "CANCEL OBS?" prompt when OBS is active
            this.obsMode.sub((mode) => {
                if (mode === msfsGarminsdk.ObsSuspModes.OBS) {
                    this.cancelObsPrompt.instance.style.visibility = 'visible';
                }
                else {
                    this.cancelObsPrompt.instance.style.visibility = 'hidden';
                }
            });
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.FPL || evt === InteractionEvent.VNAV || evt === InteractionEvent.PROC || evt === InteractionEvent.DirectTo || evt === InteractionEvent.OBS) {
                ViewService.back();
                if (evt === InteractionEvent.OBS) {
                    return true;
                }
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Handles the 'CANCEL OBS?' prompt being activated
         *
         * @returns true
         */
        handleCancelObs() {
            SimVar.SetSimVarValue('K:GPS_OBS_OFF', msfsSdk.SimVarValueType.Bool, true);
            this.controlPublisher.publishEvent('suspend_sequencing', false);
            ViewService.back();
            return true;
        }
        /**
         * Handles the OBS course value being set
         *
         * @param value the new OBS course selected
         */
        handleSetObsCourse(value) {
            SimVar.SetSimVarValue('K:GPS_OBS_SET', msfsSdk.SimVarValueType.Degree, value);
        }
        /**
         * Handles the OBS course field being changed
         *
         * @param value the new OBS course selected
         */
        handleChangeObsField(value) {
            this.handleSetObsCourse(value);
            const obsMode = this.obsMode.get();
            const isObsModeActive = obsMode === msfsGarminsdk.ObsSuspModes.OBS;
            if (!isObsModeActive) {
                SimVar.SetSimVarValue('K:GPS_OBS_ON', 'Boolean', true);
            }
        }
        /** @inheritDoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "obs-dialog" },
                msfsSdk.FSComponent.buildComponent("h2", { class: "obs-dialog-title cyan" }, "SELECT OBS COURSE"),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table obs-dialog-table" },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "obs-dialog-table-crs cyan" }, "CRS"),
                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { ref: this.courseInput, data: this.course, displayUnit: this.angleUnit, digitizer: (value, signValues, digitValues) => {
                            digitValues[0].set(Math.floor((value)));
                            digitValues[1].set(Math.floor((value % 10)));
                        }, editOnActivate: false, class: '', renderInactiveValue: (value) => (msfsSdk.FSComponent.buildComponent("div", null,
                            value.toFixed(0).padStart(3, '0'),
                            msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit }))), onInputAccepted: (v) => this.handleChangeObsField(v) },
                        msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 36, increment: 1, scale: 10, wrap: true, formatter: (v) => v.toFixed(0).padStart(2, '0') }),
                        msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true, formatter: (v) => v.toFixed(0) }),
                        msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit })),
                    msfsSdk.FSComponent.buildComponent("h2", { class: "obs-dialog-table-from" }, "FROM ABV")),
                msfsSdk.FSComponent.buildComponent("span", { ref: this.cancelObsPrompt },
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "obs-action-text", data: msfsSdk.Subject.create('CANCEL OBS?'), selectedClass: "selected-white", onEnt: this.handleCancelObs.bind(this) }))));
        }
    }

    /**
     * A component that displays a traffic map.
     */
    class TrafficDisplay extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.rangeRingOptions = {
                renderLabel: (range, unit) => msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'tfc-display-range-label', value: range, displayUnit: unit, formatter: msfsSdk.NumberFormatter.create({ precision: 0.1, forceDecimalZeroes: false }) }),
                outerStrokeWidth: 1,
                outerStrokeDash: [1, 3],
                outerMajorTickSize: 4,
                outerMinorTickSize: 4,
                outerStrokeStyle: 'cyan',
                outerLabelRadial: 135,
                innerStrokeWidth: 1,
                innerStrokeDash: [1, 3],
                innerMajorTickSize: 4,
                innerMinorTickSize: 0,
                innerLabelRadial: 135,
                innerStrokeStyle: 'cyan'
            };
            this.options = {
                trafficSystem: this.props.trafficSystem,
                dataUpdateFreq: 0.5,
                orientation: msfsGarminsdk.MapOrientation.TrackUp,
                trafficIconOptions: GNSTrafficIcons.IconOptions(this.props.gnsType),
                includeRangeRings: true,
                rangeRingOptions: this.rangeRingOptions,
                includeOperatingModeIndicator: false,
                includeAdsbModeIndicator: false,
                includeAdsbOffBanner: false,
                includeAltitudeModeIndicator: false,
                includeOrientationIndicator: false,
                includeStandbyBanner: false,
                includeFailedBanner: false,
                airplaneIconSrc: OwnshipIconPath,
                airplaneIconAnchor: new Float64Array([0.5, 0.5]),
                airplaneIconSize: this.props.gnsType === 'wt430' ? 22 : 16,
                nauticalRangeArray: [1, 2, 6, 12, 24, 40].map(v => msfsSdk.UnitType.NMILE.createNumber(v))
            };
            this.trafficMap = msfsSdk.MapSystemBuilder.create(this.props.bus)
                .withProjectedSize(this.props.size)
                .with(msfsGarminsdk.TrafficMapBuilder.build, this.options)
                .withClockUpdate(6)
                // eslint-disable-next-line jsdoc/require-jsdoc
                .build();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.trafficMap.context.getController(msfsGarminsdk.GarminMapKeys.TrafficRange).setRangeIndex(2);
            this.trafficMap.context.model.getModule(msfsGarminsdk.GarminMapKeys.Traffic).show.set(true);
            this.trafficMap.context.model.getModule(msfsGarminsdk.GarminMapKeys.Traffic).motionVectorMode.set(msfsGarminsdk.MapTrafficMotionVectorMode.Absolute);
            this.trafficMap.context.model.getModule(msfsGarminsdk.GarminMapKeys.Traffic).motionVectorLookahead.set(msfsSdk.UnitType.SECOND.createNumber(15));
        }
        /**
         * Changes the range of the traffic map.
         * @param direction The direction to change the range towards.
         */
        changeRange(direction) {
            if (direction === 'inc') {
                this.trafficMap.context.getController(msfsGarminsdk.GarminMapKeys.TrafficRange).changeRangeIndex(1);
            }
            else {
                this.trafficMap.context.getController(msfsGarminsdk.GarminMapKeys.TrafficRange).changeRangeIndex(-1);
            }
        }
        /**
         * Sets the display altitude restriction mode.
         * @param mode The display altitude restriction mode.
         */
        setAltitudeRestrictionMode(mode) {
            this.trafficMap.context.model.getModule(msfsGarminsdk.GarminMapKeys.Traffic).altitudeRestrictionMode.set(mode);
        }
        /**
         * Puts the traffic display to sleep.
         */
        sleep() {
            this.trafficMap.ref.instance.sleep();
        }
        /**
         * Wakes the traffic display.
         */
        wake() {
            this.trafficMap.ref.instance.wake();
        }
        /** @inheritdoc */
        render() {
            return this.trafficMap.map;
        }
        /** @inheritdoc */
        destroy() {
            this.trafficMap.ref.instance.destroy();
        }
    }

    /**
     * A dialog that pops up when a traffic alert is issued and
     * the user is not on the traffic map page.
     */
    class TrafficAlertDialog extends Dialog {
        constructor() {
            super(...arguments);
            this.trafficDisplay = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.ENT) {
                ViewService.back();
                ViewService.open('NAV', true, 3);
            }
            if (evt === InteractionEvent.CLR) {
                ViewService.back();
            }
            return true;
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.trafficDisplay.instance.sleep();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.trafficDisplay.instance.wake();
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'tfc-alert-dialog' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'tfc-alert-dialog-map' },
                    msfsSdk.FSComponent.buildComponent(TrafficDisplay, { bus: this.props.bus, trafficSystem: this.props.trafficSystem, gnsType: this.props.gnsType, ref: this.trafficDisplay, size: msfsSdk.Vec2Subject.create(this.props.gnsType === 'wt430' ? msfsSdk.Vec2Math.create(130, 114) : msfsSdk.Vec2Math.create(120, 120)) })),
                msfsSdk.FSComponent.buildComponent("hr", null),
                msfsSdk.FSComponent.buildComponent("div", null,
                    msfsSdk.FSComponent.buildComponent("span", { class: 'tfc-alert-dialog-button' }, "ENT"),
                    " - TRFC PAGE"),
                msfsSdk.FSComponent.buildComponent("div", null,
                    msfsSdk.FSComponent.buildComponent("span", { class: 'tfc-alert-dialog-button' }, "CLR"),
                    " - PREV PAGE")));
        }
    }

    /**
     * A page component that displays the waypoint info dialog box.
     */
    class WaypointInfo extends Dialog {
        constructor() {
            super(...arguments);
            this.input = msfsSdk.FSComponent.createRef();
            this.name = msfsSdk.Subject.create('____________________');
            this.city = msfsSdk.Subject.create('____________________');
            this.region = msfsSdk.Subject.create('__________');
            this.message = msfsSdk.Subject.create('TO ACCEPT');
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
            this.icon = msfsSdk.FSComponent.createRef();
            this.matchingIcaos = [];
            this.resolve = () => { };
            this.ppos = new msfsSdk.GeoPoint(0, 0);
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber()
                .on('gps-position')
                .handle(pos => this.ppos.set(pos.lat, pos.long));
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.CLR) {
                if (this.isInputActive()) {
                    this.input.instance.focusSelf();
                    this.clear();
                    return true;
                }
                else {
                    return false;
                }
            }
            if (evt === InteractionEvent.ENT) {
                if (this.matchingIcaos.length > 1 && this.facility !== undefined) {
                    ViewService.resolveDups(msfsSdk.ICAO.getIdent(this.facility.icao).trim(), this.matchingIcaos).then(this.resolve);
                }
                else if (this.matchingIcaos.length === 1 && this.facility !== undefined) {
                    this.resolve(this.facility);
                }
                return true;
            }
            if (evt === InteractionEvent.FPL || evt === InteractionEvent.VNAV || evt === InteractionEvent.PROC || evt === InteractionEvent.DirectTo) {
                ViewService.back();
                if (evt === InteractionEvent.FPL) {
                    return true;
                }
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Sets the promise resolution function for this dialog.
         * @param resolve The promise resolution function.
         */
        setResolve(resolve) {
            this.resolve = resolve;
        }
        /** @inheritdoc */
        onResume() {
            this.input.instance.enableSlots();
            const inputPrefix = msfsSdk.NearestContext.getInstance().getRegionIdent();
            if (inputPrefix !== undefined) {
                this.input.instance.set(inputPrefix);
                this.onIdentChanged(inputPrefix);
            }
            super.onResume();
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.clear();
        }
        /**
         * Checks to see if the input is active by checking if any character slots
         * are focused.
         * @returns True if active, false otherwise.
         */
        isInputActive() {
            var _a;
            for (let i = 0; i < this.input.instance.length; i++) {
                if ((_a = this.input.instance.getChild(i)) === null || _a === void 0 ? void 0 : _a.isFocused) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Clears the waypoint info display.
         */
        clear() {
            this.facility = undefined;
            this.matchingIcaos.length = 0;
            this.input.instance.set('');
            this.message.set('TO ACCEPT');
            this.updateName();
            this.updateCity();
            this.updateIcon();
            this.updateRegion();
            this.updatePosition();
        }
        /**
         * Handles when the ident is changed in the input control.
         * @param ident The new ident.
         */
        async onIdentChanged(ident) {
            this.facility = undefined;
            this.matchingIcaos.length = 0;
            if (this.debounceTimeout !== undefined) {
                window.clearTimeout(this.debounceTimeout);
            }
            this.debounceTimeout = window.setTimeout(() => this.loadIdent(ident), 250);
        }
        /**
         * Loads an ident into the waypoint display.
         * @param ident The ident to search for.
         */
        async loadIdent(ident) {
            const icaos = await this.props.fms.facLoader.searchByIdent(msfsSdk.FacilitySearchType.All, ident, 10);
            if (icaos.length !== 0) {
                const facilityIdent = msfsSdk.ICAO.getIdent(icaos[0]).trim();
                this.input.instance.set(facilityIdent);
                this.matchingIcaos = icaos.filter(icao => msfsSdk.ICAO.getIdent(icao).trim() === facilityIdent);
                if (this.matchingIcaos.length === 1) {
                    this.message.set('TO ACCEPT');
                }
                else {
                    this.message.set('FOR DUPS');
                }
                const facilities = await Promise.all(this.matchingIcaos.map(icao => this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao)));
                this.facility = facilities.sort((a, b) => this.orderByPPosDistance(a, b))[0];
            }
            this.updateName();
            this.updateCity();
            this.updateIcon();
            this.updateRegion();
            this.updatePosition();
        }
        /**
         * Updates the facility name display.
         */
        updateName() {
            if (this.facility !== undefined) {
                const name = Utils.Translate(this.facility.name).toUpperCase();
                this.name.set(name === '' ? msfsSdk.ICAO.getIdent(this.facility.icao) : name.substr(0, 20));
            }
            else {
                this.name.set('____________________');
            }
        }
        /**
         * Updates the facility city display.
         */
        updateCity() {
            if (this.facility !== undefined && this.facility.city !== '@') {
                const city = this.facility.city.split(', ').map(v => Utils.Translate(v)).join(', ').toUpperCase();
                this.city.set(city === '' ? ' ' : city.substr(0, 20));
            }
            else {
                this.city.set('____________________');
            }
        }
        /**
         * Updates the waypoint icon display.
         */
        updateIcon() {
            if (this.facility !== undefined) {
                this.icon.instance.src = Icons.getByFacility(this.facility).src;
            }
            else {
                this.icon.instance.src = '';
            }
        }
        /**
         * Updates the waypoint region display.
         */
        updateRegion() {
            if (this.facility !== undefined) {
                const facilityIdent = msfsSdk.ICAO.getIdent(this.facility.icao).trim();
                if (msfsSdk.ICAO.getFacilityType(this.facility.icao) === msfsSdk.FacilityType.Airport) {
                    let region = facilityIdent.length === 4 ? msfsGarminsdk.Regions.getName(facilityIdent.substr(0, 2)) : '';
                    if (region === '' && this.facility.city !== '') {
                        region = this.facility.city.split(', ').map(v => Utils.Translate(v)).join(', ');
                    }
                    this.region.set(region === '' ? ' ' : region.toUpperCase().substr(0, 10));
                }
                else {
                    const region = msfsGarminsdk.Regions.getName(this.facility.icao.substr(1, 2));
                    this.region.set(region === '' ? ' ' : region);
                }
            }
            else {
                this.region.set('__________');
            }
        }
        /**
         * Updates the waypoint lat/lon display.
         */
        updatePosition() {
            if (this.facility !== undefined) {
                this.position.set(this.facility.lat, this.facility.lon);
            }
            else {
                this.position.set(NaN, NaN);
            }
        }
        /**
         * Orders facilities by their distance to the plane PPOS.
         * @param a The first facility.
         * @param b The second facility.
         * @returns The comparison order number.
         */
        orderByPPosDistance(a, b) {
            const aDist = this.ppos.distance(a.lat, a.lon);
            const bDist = this.ppos.distance(b.lat, b.lon);
            if (aDist < bDist) {
                return -1;
            }
            if (aDist > bDist) {
                return 1;
            }
            return 0;
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "WAYPOINT INFORMATION"),
                msfsSdk.FSComponent.buildComponent("hr", null),
                msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info' },
                    msfsSdk.FSComponent.buildComponent("h2", null, "IDENT, FACILITY, & CITY"),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info-identbox' },
                        msfsSdk.FSComponent.buildComponent(AlphaNumInput, { class: 'waypoint-info-input', onChanged: this.onIdentChanged.bind(this), ref: this.input, gnsType: this.props.gnsType, enableKeyboard: true }),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info-icon' },
                            msfsSdk.FSComponent.buildComponent("img", { ref: this.icon })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info-region' }, this.region),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info-name' }, this.name),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info-city' }, this.city)),
                    msfsSdk.FSComponent.buildComponent("h2", null, "POSITION"),
                    msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { class: 'waypoint-info-posbox', location: this.position }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-info-msg' },
                        "PRESS ",
                        msfsSdk.FSComponent.buildComponent("span", { class: 'waypoint-info-ent' }, "ENT"),
                        " ",
                        this.message))));
        }
    }

    var LegArrowType;
    (function (LegArrowType) {
        LegArrowType[LegArrowType["None"] = 0] = "None";
        LegArrowType[LegArrowType["From"] = 1] = "From";
        LegArrowType[LegArrowType["Between"] = 2] = "Between";
        LegArrowType[LegArrowType["To"] = 3] = "To";
        LegArrowType[LegArrowType["Direct"] = 4] = "Direct";
    })(LegArrowType || (LegArrowType = {}));
    /**
     * Displays a flight plan leg arrow on the FPL page.
     */
    class FPLLegArrow extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /**
         * Sets the type of flight plan leg arrow to display.
         * @param type The type of leg arrow.
         */
        set(type) {
            switch (type) {
                case LegArrowType.None:
                    this.el.instance.classList.add('hidden-element');
                    this.el.instance.src = '';
                    break;
                case LegArrowType.From:
                    this.el.instance.classList.remove('hidden-element');
                    this.el.instance.src = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legarrow_from.svg';
                    break;
                case LegArrowType.Between:
                    this.el.instance.classList.remove('hidden-element');
                    this.el.instance.src = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legarrow_between.svg';
                    break;
                case LegArrowType.To:
                    this.el.instance.classList.remove('hidden-element');
                    this.el.instance.src = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legarrow_to.svg';
                    break;
                case LegArrowType.Direct:
                    this.el.instance.classList.remove('hidden-element');
                    this.el.instance.src = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/legarrow_directto.svg';
                    break;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("img", { class: 'fpl-leg-arrow', src: '', ref: this.el }));
        }
    }

    /**
     * A UI control that display a flight plan entry line within the plan table.
     */
    class FPLEntry extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.leg = msfsSdk.FSComponent.createRef();
            this.legArrow = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            if (this.props.data !== undefined) {
                this.legSub = this.props.data.legDefinition.sub(this.onLegDefinitionChanged.bind(this), true);
            }
        }
        /**
         * Sets the leg arrow to be displayed with this entry.
         * @param type The type of arrow to display.
         */
        setLegArrow(type) {
            this.legArrow.instance.set(type);
        }
        /**
         * Handles when the leg defintion changes.
         * @param legDefinition The new leg definition.
         */
        onLegDefinitionChanged(legDefinition) {
            if (msfsSdk.FlightPlanUtils.isDiscontinuityLeg(legDefinition.leg.type) ||
                msfsSdk.BitFlags.isAny(legDefinition.flags, msfsSdk.LegDefinitionFlags.DirectTo)) {
                this.el.instance.classList.add('hide-element');
                this.setDisabled(true);
            }
            else {
                this.el.instance.classList.remove('hide-element');
                this.setDisabled(false);
            }
            this.leg.instance.setLeg(legDefinition);
        }
        /** @inheritDoc */
        onDirectTo(sender) {
            var _a;
            const legDefinition = (_a = this.props.data) === null || _a === void 0 ? void 0 : _a.legDefinition.get();
            if (legDefinition) {
                ViewService.directToDialogWithLeg(legDefinition);
                return true;
            }
            return super.onDirectTo(sender);
        }
        /** @inheritDoc */
        onClr() {
            if (this.props.data !== undefined) {
                const legData = this.props.data;
                ViewService.confirm('REMOVE WAYPOINT', legData.name.get())
                    .then(confirmed => {
                    if (confirmed) {
                        const plan = this.props.fms.getPrimaryFlightPlan();
                        const segment = plan.getSegmentFromLeg(legData.legDefinition.get());
                        const legIndex = segment === null || segment === void 0 ? void 0 : segment.legs.indexOf(legData.legDefinition.get());
                        if (segment !== null && legIndex !== undefined) {
                            this.props.fms.removeWaypoint(segment.segmentIndex, legIndex);
                            if (segment.segmentType === msfsSdk.FlightPlanSegmentType.Destination) {
                                const lastLegInPlan = plan.length > 1 && plan.tryGetLeg(plan.length - 1);
                                if (lastLegInPlan && msfsSdk.ICAO.getFacilityType(lastLegInPlan.leg.fixIcao) === msfsSdk.FacilityType.Airport) {
                                    this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, lastLegInPlan.leg.fixIcao).then(airport => {
                                        this.props.fms.setDestination(airport);
                                    });
                                }
                                else {
                                    this.props.fms.setDestination(undefined);
                                }
                            }
                        }
                    }
                });
            }
            return true;
        }
        /** @inheritdoc */
        onRightInnerInc() {
            return this.handleInnerKnobScroll();
        }
        /** @inheritdoc */
        onRightInnerDec() {
            return this.handleInnerKnobScroll();
        }
        /** @inheritdoc */
        destroy() {
            var _a;
            (_a = this.legSub) === null || _a === void 0 ? void 0 : _a.destroy();
        }
        /**
         * Handles when the inner knob is turned.
         * @returns True as it will always be handled.
         */
        handleInnerKnobScroll() {
            ViewService.getWaypoint().then(facility => {
                this.insertWaypoint(facility);
            });
            return true;
        }
        /**
         * Inserts a waypoint into the flight plan.
         * @param facility The facility to insert into the plan.
         */
        insertWaypoint(facility) {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const isAirport = msfsSdk.ICAO.getFacilityType(facility.icao) === msfsSdk.FacilityType.Airport;
            if (plan.length === 0) {
                if (isAirport) {
                    this.props.fms.setDestination(facility);
                }
                else {
                    this.props.fms.insertWaypoint([...plan.segmentsOfType(msfsSdk.FlightPlanSegmentType.Enroute)][0].segmentIndex, facility);
                }
            }
            else if (plan.length === 1) {
                if (isAirport) {
                    if (this.isDestinationAirport()) {
                        this.props.fms.setOrigin(facility);
                    }
                    else {
                        this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.getLeg(0).leg.fixIcao).then(oldFac => {
                            this.props.fms.setDestination(facility);
                            this.props.fms.setOrigin(oldFac);
                        });
                    }
                }
                else {
                    if (!this.isDestinationAirport()) {
                        this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.getLeg(0).leg.fixIcao).then(oldFac => {
                            this.props.fms.setOrigin(oldFac);
                            this.props.fms.setDestination(undefined);
                        });
                    }
                    this.props.fms.insertWaypoint([...plan.segmentsOfType(msfsSdk.FlightPlanSegmentType.Enroute)][0].segmentIndex, facility);
                }
            }
            else {
                const segment = this.props.data !== undefined
                    ? plan.getSegmentFromLeg(this.props.data.legDefinition.get())
                    : plan.getSegment(plan.segmentCount - 1);
                const isDestinationSegment = (segment === null || segment === void 0 ? void 0 : segment.segmentType) === msfsSdk.FlightPlanSegmentType.Destination;
                const legIndex = this.props.data !== undefined
                    ? segment === null || segment === void 0 ? void 0 : segment.legs.indexOf(this.props.data.legDefinition.get())
                    : undefined;
                if (segment !== null) {
                    if (isDestinationSegment) {
                        if (legIndex === undefined) {
                            this.props.fms.moveCurrentDestinationLegToEnroute();
                            if (isAirport) {
                                this.props.fms.setDestination(facility);
                            }
                            else {
                                this.props.fms.insertWaypoint(segment.segmentIndex, facility);
                            }
                        }
                        else {
                            const lastEnrouteSegmentIndex = this.props.fms.findLastEnrouteSegmentIndex(plan);
                            this.props.fms.insertWaypoint(lastEnrouteSegmentIndex, facility);
                        }
                    }
                    else {
                        this.props.fms.insertWaypoint(segment.segmentIndex, facility, legIndex);
                    }
                }
            }
        }
        /**
         * Checks to see if the FPL entry is the destination airport.
         * @returns If there is a distionation airport.
         */
        isDestinationAirport() {
            if (this.props.data !== undefined) {
                const segment = this.props.fms.getPrimaryFlightPlan().getSegmentFromLeg(this.props.data.legDefinition.get());
                if (segment !== null) {
                    return segment.segmentType === msfsSdk.FlightPlanSegmentType.Destination
                        && msfsSdk.ICAO.getFacilityType(this.props.data.legDefinition.get().leg.fixIcao) === msfsSdk.FacilityType.Airport;
                }
            }
            return false;
        }
        /** @inheritdoc */
        render() {
            var _a, _b, _c, _d, _e, _f;
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-entry', ref: this.el },
                msfsSdk.FSComponent.buildComponent(FPLLegArrow, { ref: this.legArrow }),
                msfsSdk.FSComponent.buildComponent(WaypointLeg, { class: 'fpl-entry-name', ref: this.leg }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-entry-col1' },
                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ pad: 3, precision: 1, forceDecimalZeroes: false, maxDigits: 3, nanString: '___' }), value: (_b = (_a = this.props.data) === null || _a === void 0 ? void 0 : _a.dtk) !== null && _b !== void 0 ? _b : msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(NaN)), displayUnit: msfsSdk.UnitType.DEGREE })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-entry-col2' },
                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 0.1, forceDecimalZeroes: true, maxDigits: 3, nanString: '__._' }), value: (_d = (_c = this.props.data) === null || _c === void 0 ? void 0 : _c.distance) !== null && _d !== void 0 ? _d : msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN)), displayUnit: msfsSdk.UnitType.NMILE })),
                this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-entry-col3' },
                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({
                            precision: 0.1,
                            forceDecimalZeroes: true,
                            maxDigits: 3,
                            nanString: '__._'
                        }), value: (_f = (_e = this.props.data) === null || _e === void 0 ? void 0 : _e.cumulativeDistance) !== null && _f !== void 0 ? _f : msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN)), displayUnit: msfsSdk.UnitType.NMILE })))));
        }
    }

    /**
     * Utility Methods for the GNS FMS.
     */
    class GnsFmsUtils {
        /**
         * Gets the display string for the GNS from the airportPrivateType enum in the Airport Facility.
         * @param facility The Airport Facility.
         * @returns The display string.
         */
        static getAirportPrivateTypeString(facility) {
            if (facility === undefined) {
                return '';
            }
            else {
                switch (facility.airportPrivateType) {
                    case 1:
                        return 'Public';
                    case 2:
                        return 'Military';
                    case 3:
                        return 'Private';
                    default:
                        return 'Uknown';
                }
            }
        }
        /**
         * Gets the display string for the GNS from the ExtendedApproachType.
         * @param facility The Airport Facility.
         * @param threeLetter Whether to give a three letter approach type string.
         * @returns The display string.
         */
        static getBestApproachTypeString(facility, threeLetter = false) {
            if (facility === undefined) {
                return '';
            }
            switch (msfsGarminsdk.FmsUtils.getBestApproachType(facility)) {
                case ApproachType.APPROACH_TYPE_ILS:
                    return 'ILS';
                case ApproachType.APPROACH_TYPE_LDA:
                    return 'LDA';
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    return 'LOC';
                case ApproachType.APPROACH_TYPE_RNAV:
                case ApproachType.APPROACH_TYPE_GPS:
                    return threeLetter ? 'RNV' : 'RNAV';
                case ApproachType.APPROACH_TYPE_VOR:
                case ApproachType.APPROACH_TYPE_VORDME:
                    return 'VOR';
                case ApproachType.APPROACH_TYPE_NDB:
                case ApproachType.APPROACH_TYPE_NDBDME:
                    return 'NBD';
            }
            return 'VFR';
        }
        /**
         * gets the facility frequency type string
         * @param freq the facility frequency
         * @param short whether to return the abbreviated version of the string, e.g. for NEAREST pages.
         * Only applicable for MULTICOM, UNICOM and TOWER.
         * @returns a string of the frequency type
         */
        static getFacilityFrequencyType(freq, short = false) {
            switch (freq.type) {
                case 1:
                    return 'ATIS';
                case 2:
                    return short ? 'mul' : 'Multicom';
                case 3:
                    return short ? 'uni' : 'Unicom';
                case 4:
                    return 'CTAF';
                case 5:
                    return 'Ground';
                case 6:
                    return short ? 'twr' : 'Tower';
                case 7:
                    return 'Clearance';
                case 8:
                    return 'Approach';
                case 9:
                    return 'Departure';
                case 10:
                    return 'Center';
                case 11:
                    return 'FSS';
                case 12:
                    return 'AWOS';
                case 13:
                    return 'ASOS';
                case 14:
                    return 'CPT';
                case 15:
                    return 'GCO';
            }
            return freq.name;
        }
        /**
         * Orders facility frequencies per the real GNS unit.
         * @param a The first facility frequency.
         * @param b The second facility frequency.
         * @returns The comparison order number.
         */
        static orderFacilityFrequencies(a, b) {
            const priorityA = GnsFmsUtils.facilityFrequencyPriorityMap.has(a.type) ? GnsFmsUtils.facilityFrequencyPriorityMap.get(a.type) : 100;
            const priorityB = GnsFmsUtils.facilityFrequencyPriorityMap.has(b.type) ? GnsFmsUtils.facilityFrequencyPriorityMap.get(b.type) : 100;
            if (priorityA && priorityB && priorityA < priorityB) {
                return -1;
            }
            if (priorityA && priorityB && priorityA > priorityB) {
                return 1;
            }
            return 0;
        }
        /**
         * Utility method that takes an approach and returns its name as a flat
         * string suitable for use in embedded text content.
         * @param approach The approach as an ApproaceProcedure
         * @returns The formatted name as a string.
         */
        static getApproachNameAsString(approach) {
            const parts = msfsGarminsdk.FmsUtils.getApproachNameAsParts(approach);
            let name = parts.type;
            //parts.subtype && (name += `${parts.subtype}`);
            parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
            parts.runway && (name += ` ${parts.runway}`);
            //parts.flags && (name += ` ${parts.flags}`);
            return name;
        }
        /**
         * Gets the name of a arrival procedure as a string.
         * @param airport The airport to which the departure belongs.
         * @param arrival An arrival procedure definition.
         * @param transitionIndex The index of the arrival enroute transition.
         * @param runway The runway of the arrival, if any.
         * @returns The name of the arrival procedure.
         */
        static getArrivalNameAsString(airport, arrival, transitionIndex, runway) {
            let name = `- ${msfsSdk.ICAO.getIdent(airport.icao)}-`;
            const transition = arrival.enRouteTransitions[transitionIndex];
            if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
                name += `${msfsSdk.ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
            }
            else if (arrival.commonLegs.length > 0) {
                name += `${msfsSdk.ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
            }
            else {
                name += `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
            }
            if (runway) {
                name += `.RW${runway.designation}`;
            }
            return name;
        }
        /**
         * Gets the name of a departure procedure as a string.
         * @param airport The airport to which the departure belongs.
         * @param departure A departure procedure definition.
         * @param transitionIndex The index of the departure enroute transition.
         * @param runway The runway of the departure, if any.
         * @returns The name of the departure procedure.
         */
        static getDepartureNameAsString(airport, departure, transitionIndex, runway) {
            let name = `- ${msfsSdk.ICAO.getIdent(airport.icao)}-`;
            if (runway) {
                name += `RW${runway.designation}.`;
            }
            const transition = departure.enRouteTransitions[transitionIndex];
            if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
                name += `${departure.name}.${msfsSdk.ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
            }
            else if (departure.commonLegs.length > 0) {
                name += `${departure.name}.${msfsSdk.ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
            }
            else {
                name += `${departure.name}`;
            }
            return name;
        }
        /**
         * Checks the validity of a Flight Plan leg for the GNS and returns a leg to be inserted
         * into a procedure, or undefined if no leg should be inserted.
         * @param leg The FlightPlanLeg
         * @returns A leg to be inserted into a procedure, or undefined if no leg should be inserted.
         */
        static gnsProcedureLegValid(leg) {
            switch (leg.type) {
                case msfsSdk.LegType.VD:
                case msfsSdk.LegType.VR:
                case msfsSdk.LegType.VI:
                case msfsSdk.LegType.CI:
                    return msfsSdk.FlightPlan.createLeg({ type: msfsSdk.LegType.ThruDiscontinuity });
                case msfsSdk.LegType.RF:
                    return {
                        type: msfsSdk.LegType.TF,
                        fixIcao: leg.fixIcao,
                        flyOver: leg.flyOver,
                        distanceMinutes: leg.distanceMinutes,
                        trueDegrees: leg.trueDegrees,
                        turnDirection: leg.turnDirection,
                        originIcao: leg.originIcao,
                        arcCenterFixIcao: leg.arcCenterFixIcao,
                        theta: leg.theta,
                        rho: leg.rho,
                        course: leg.course,
                        distance: leg.distance,
                        speedRestriction: leg.speedRestriction,
                        altDesc: leg.altDesc,
                        altitude1: leg.altitude1,
                        altitude2: leg.altitude2,
                        lat: leg.lat,
                        lon: leg.lon,
                        fixTypeFlags: leg.fixTypeFlags,
                        verticalAngle: leg.verticalAngle,
                    };
                default:
                    return leg;
            }
        }
        /**
         * Gets the valid approaches for the GNS.
         * @param facility The Facility to get approaches from.
         * @returns an array of GNS-valid approaches.
         */
        static getValidApproaches(facility) {
            const procedures = [];
            if (facility.approaches.length > 0) {
                for (let i = 0; i < facility.approaches.length; i++) {
                    const approach = facility.approaches[i];
                    if (!(approach.approachType === ApproachType.APPROACH_TYPE_RNAV && approach.rnavTypeFlags === 0 && approach.runwayNumber !== 0)) {
                        procedures.push({ index: i, approachProcedure: approach });
                    }
                }
            }
            return procedures;
        }
    }
    GnsFmsUtils.vec3Cache = [new Float64Array(3)];
    GnsFmsUtils.geoPointCache = [new msfsSdk.GeoPoint(0, 0)];
    GnsFmsUtils.geoCircleCache = [new msfsSdk.GeoCircle(new Float64Array(3), 0)];
    GnsFmsUtils.facilityFrequencyPriorityMap = new Map([
        [msfsSdk.FacilityFrequencyType.ATIS, 1],
        [msfsSdk.FacilityFrequencyType.AWOS, 2],
        [msfsSdk.FacilityFrequencyType.ASOS, 3],
        [msfsSdk.FacilityFrequencyType.Clearance, 4],
        [msfsSdk.FacilityFrequencyType.Ground, 5],
        [msfsSdk.FacilityFrequencyType.GCO, 6],
        [msfsSdk.FacilityFrequencyType.Tower, 7],
        [msfsSdk.FacilityFrequencyType.CTAF, 8],
        [msfsSdk.FacilityFrequencyType.CPT, 9],
        [msfsSdk.FacilityFrequencyType.Unicom, 10],
        [msfsSdk.FacilityFrequencyType.Multicom, 11],
        [msfsSdk.FacilityFrequencyType.Departure, 12],
        [msfsSdk.FacilityFrequencyType.Approach, 13],
        [msfsSdk.FacilityFrequencyType.Center, 14],
        [msfsSdk.FacilityFrequencyType.FSS, 15],
        [msfsSdk.FacilityFrequencyType.None, 16],
    ]);
    /**
     * Tower/CTAF frequency types, ordered by priority
     */
    GnsFmsUtils.towerOrCtafFrequencyTypes = [
        msfsSdk.FacilityFrequencyType.Tower,
        msfsSdk.FacilityFrequencyType.Unicom,
        msfsSdk.FacilityFrequencyType.Multicom,
    ];
    /**
     * Tower/CTAF frequency type short names
     */
    GnsFmsUtils.towerOrCtafFrequencyShortName = new Map([
        [msfsSdk.FacilityFrequencyType.Tower, 'twr'],
        [msfsSdk.FacilityFrequencyType.Unicom, 'uni'],
        [msfsSdk.FacilityFrequencyType.Multicom, 'mul'],
    ]);

    /**
     * Utilities for the FPL page components.
     */
    class FPLPageUtils {
        /**
         * Gets the departure names for GNS display.
         * @param fms The FMS to get the departure names from.
         * @returns The departure names, or undefined if none.
         */
        static async getDepartureNames(fms) {
            const plan = fms.getPrimaryFlightPlan();
            if (plan.originAirport !== undefined) {
                const originFacility = await fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.originAirport);
                const departure = originFacility === null || originFacility === void 0 ? void 0 : originFacility.departures[plan.procedureDetails.departureIndex];
                const transition = plan.procedureDetails.departureTransitionIndex;
                const runway = plan.procedureDetails.originRunway;
                if (originFacility !== undefined && departure !== undefined) {
                    return { short: departure.name, long: msfsGarminsdk.FmsUtils.getDepartureNameAsString(originFacility, departure, transition, runway) };
                }
            }
            return undefined;
        }
        /**
         * Gets the arrival names for GNS display.
         * @param fms The FMS to get the arrival names from.
         * @returns The arrival names, or undefined if none.
         */
        static async getArrivalNames(fms) {
            const plan = fms.getPrimaryFlightPlan();
            if (plan.destinationAirport !== undefined) {
                const destinationFacility = await fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.destinationAirport);
                const arrival = destinationFacility === null || destinationFacility === void 0 ? void 0 : destinationFacility.arrivals[plan.procedureDetails.arrivalIndex];
                const transition = plan.procedureDetails.arrivalTransitionIndex;
                const runway = plan.procedureDetails.destinationRunway;
                if (destinationFacility !== undefined && arrival !== undefined) {
                    return { short: arrival.name, long: msfsGarminsdk.FmsUtils.getArrivalNameAsString(destinationFacility, arrival, transition, runway) };
                }
            }
            return undefined;
        }
        /**
         * Gets the approach names for GNS display.
         * @param fms The FMS to get the approach names from.
         * @returns The approach names, or undefined if none.
         */
        static async getApproachNames(fms) {
            const plan = fms.getPrimaryFlightPlan();
            if (plan.destinationAirport !== undefined) {
                const destinationFacility = await fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.destinationAirport);
                const approach = destinationFacility === null || destinationFacility === void 0 ? void 0 : destinationFacility.approaches[plan.procedureDetails.approachIndex];
                if (destinationFacility !== undefined && approach !== undefined) {
                    return { short: GnsFmsUtils.getApproachNameAsString(approach), long: GnsFmsUtils.getApproachNameAsString(approach) };
                }
            }
            return undefined;
        }
    }

    /**
     * A control that displays the flight plan segment header, if one exists.
     */
    class FPLSegmentHeader extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.textEl = msfsSdk.FSComponent.createRef();
            this.legArrow = msfsSdk.FSComponent.createRef();
            this.name = msfsSdk.Subject.create('');
            this.longName = msfsSdk.Subject.create('');
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.setDisabled(true);
        }
        /**
         * Sets the name to be displayed in the header.
         * @param name The short name to be displayed in the header.
         * @param longName The long name to be displayed in any confirmation dialogs.
         */
        setName(name, longName) {
            this.name.set(name);
            if (longName !== undefined) {
                this.longName.set(longName);
            }
            else {
                this.longName.set(name);
            }
        }
        /**
         * Sets the leg arrow to be displayed with this entry.
         * @param type The type of arrow to display.
         */
        setLegArrow(type) {
            this.legArrow.instance.set(type);
        }
        /** @inheritdoc */
        onDisabled() {
            this.el.instance.classList.add('hide-element');
        }
        /** @inheritdoc */
        onEnabled() {
            this.el.instance.classList.remove('hide-element');
        }
        /** @inheritdoc */
        onFocused() {
            this.textEl.instance.classList.add('selected-cyan');
            if (this.props.scrollContainer !== undefined) {
                msfsSdk.ScrollUtils.ensureInView(this.el.instance, this.props.scrollContainer.instance);
            }
            this.props.onSelected();
        }
        /** @inheritdoc */
        onBlurred() {
            this.textEl.instance.classList.remove('selected-cyan');
        }
        /** @inheritdoc */
        onClr() {
            if (![msfsSdk.FlightPlanSegmentType.Departure, msfsSdk.FlightPlanSegmentType.Arrival, msfsSdk.FlightPlanSegmentType.Approach].includes(this.props.type)) {
                return true;
            }
            ViewService.confirm(`Remove ${this.props.type}`.toUpperCase(), `Remove ${this.longName.get().toUpperCase()} from flight plan.`)
                .then((confirmed) => {
                if (confirmed) {
                    switch (this.props.type) {
                        case msfsSdk.FlightPlanSegmentType.Approach:
                            this.props.fms.removeApproach();
                            break;
                        case msfsSdk.FlightPlanSegmentType.Departure:
                            this.props.fms.removeDeparture();
                            break;
                        case msfsSdk.FlightPlanSegmentType.Arrival:
                            this.props.fms.removeArrival();
                            break;
                    }
                }
            });
            return true;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-segment-header', ref: this.el },
                msfsSdk.FSComponent.buildComponent(FPLLegArrow, { ref: this.legArrow }),
                msfsSdk.FSComponent.buildComponent("span", { ref: this.textEl },
                    this.props.type,
                    " ",
                    this.name)));
        }
    }

    /** Leg data to store on each FPL line. */
    class GnsLegDataItem {
        /**
         * A GNS Leg Data Item
         * @param legDefinition Leg Global Leg Index
         */
        constructor(legDefinition) {
            /** The name of the waypoint. */
            this.name = msfsSdk.ComputedSubject.create(undefined, (v) => {
                switch (v) {
                    case undefined:
                        return 'noname';
                    case 'HOLD':
                        return 'hold';
                    case 'MANSEQ':
                        return 'man seq';
                    default:
                        return v;
                }
            });
            /** The initial DTK to the waypoint. */
            this.dtk = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(NaN));
            /** The distance to the waypoint. */
            this.distance = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            /** The cumulative distance in the plan at the waypoint. */
            this.cumulativeDistance = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            this.updateLegData = (legDefiniton) => {
                var _a, _b, _c, _d, _e, _f;
                this.name.set(legDefiniton.name);
                this.dtk.set((_b = (_a = legDefiniton.calculated) === null || _a === void 0 ? void 0 : _a.initialDtk) !== null && _b !== void 0 ? _b : NaN, msfsSdk.UnitType.DEGREE);
                this.distance.set((_d = (_c = legDefiniton.calculated) === null || _c === void 0 ? void 0 : _c.distance) !== null && _d !== void 0 ? _d : NaN, msfsSdk.UnitType.METER);
                this.cumulativeDistance.set((_f = (_e = legDefiniton.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistance) !== null && _f !== void 0 ? _f : NaN, msfsSdk.UnitType.METER);
            };
            this.legDefinition = msfsSdk.Subject.create(legDefinition);
            this.legDefinition.sub(this.updateLegData, true);
        }
    }

    /**
     * A control component that displays a flight plan segment.
     */
    class FPLSegment extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.legs = msfsSdk.ArraySubject.create();
            this.header = msfsSdk.FSComponent.createRef();
            this.el = msfsSdk.FSComponent.createRef();
            this.scrollContainer = msfsSdk.FSComponent.createRef();
            this.legList = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.props.segment.legs.forEach((leg, i) => this.insertLeg(i, leg));
            this.legSubscription = this.props.bus.getSubscriber()
                .on('fplLegChange')
                .handle(this.onLegChanged.bind(this));
            this.calcSubscription = this.props.bus.getSubscriber()
                .on('fplCalculated')
                .handle(this.onCalculated.bind(this));
            this.activeLegSubscription = this.props.bus.getSubscriber()
                .on('fplActiveLegChange')
                .handle(this.onActiveLegChanged.bind(this));
            this.setHeader();
            if (this.el.instance.parentElement !== null) {
                this.scrollContainer.instance = this.el.instance.parentElement;
            }
            this.disableOnEmpty();
        }
        /**
         * Gets the number of displayed lines in the segment.
         * @returns The number of FPL page lines in the segment.
         */
        getLineCount() {
            if (this.header.instance.isDisabled) {
                return this.props.segment.legs.length;
            }
            else {
                return this.props.segment.legs.length + 1;
            }
        }
        /**
         * Scrolls to a leg in the segment.
         * @param index The index of the leg in the segment to scroll to.
         */
        scrollToLeg(index) {
            const fplEntry = this.legList.instance.getChildInstance(index);
            if (fplEntry !== null) {
                fplEntry.focus(msfsSdk.FocusPosition.First);
                fplEntry.blur();
                this.legList.instance.ensureIndexInView(index, 'top');
            }
        }
        /**
         * Focuses a leg in the segment.
         * @param index The index of the leg in the segment to focus.
         */
        focusLeg(index) {
            const fplEntry = this.legList.instance.getChildInstance(index);
            if (fplEntry) {
                fplEntry.focus(msfsSdk.FocusPosition.First);
            }
        }
        /**
         * Reconciles the active leg arrows when a flight plan change doesn't trigger the active leg changed event.
         * @param legIndexes The leg indexes for the active leg.
         */
        reconcileActiveLeg(legIndexes) {
            this.onActiveLegChanged({
                planIndex: msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX,
                index: legIndexes.globalLegIndex,
                segmentIndex: legIndexes.segmentIndex,
                legIndex: legIndexes.segmentLegIndex,
                previousSegmentIndex: legIndexes.segmentIndex,
                previousLegIndex: legIndexes.segmentLegIndex,
                type: msfsSdk.ActiveLegType.Lateral
            });
        }
        /**
         * Sets the segment header, if applicable.
         */
        async setHeader() {
            switch (this.props.segment.segmentType) {
                case msfsSdk.FlightPlanSegmentType.Departure:
                    await this.setDepartureHeader();
                    break;
                case msfsSdk.FlightPlanSegmentType.Enroute:
                    this.header.instance.setDisabled(false);
                    break;
                case msfsSdk.FlightPlanSegmentType.Arrival:
                    await this.setArrivalHeader();
                    break;
                case msfsSdk.FlightPlanSegmentType.Approach:
                    await this.setApproachHeader();
                    break;
            }
        }
        /**
         * Sets a departure header on the header component.
         */
        async setDepartureHeader() {
            const departureNames = await FPLPageUtils.getDepartureNames(this.props.fms);
            if (departureNames !== undefined) {
                this.header.instance.setName(departureNames.short, departureNames.long);
                this.header.instance.setDisabled(false);
            }
            else {
                this.header.instance.setName('');
                this.header.instance.setDisabled(true);
            }
        }
        /**
         * Sets an arrival header on the header component.
         */
        async setArrivalHeader() {
            const arrivalNames = await FPLPageUtils.getArrivalNames(this.props.fms);
            if (arrivalNames !== undefined) {
                this.header.instance.setName(arrivalNames.short, arrivalNames.long);
                this.header.instance.setDisabled(false);
            }
            else {
                this.header.instance.setName('');
                this.header.instance.setDisabled(true);
            }
        }
        /**
         * Sets an approach header on the header component.
         */
        async setApproachHeader() {
            const approachNames = await FPLPageUtils.getApproachNames(this.props.fms);
            if (approachNames !== undefined) {
                this.header.instance.setName(approachNames.short, approachNames.long);
                this.header.instance.setDisabled(false);
            }
            else {
                this.header.instance.setName('');
                this.header.instance.setDisabled(true);
            }
        }
        /**
         * Handles when a leg is changed in the segment.
         * @param evt The event describing the change.
         */
        onLegChanged(evt) {
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX && evt.segmentIndex === this.props.segment.segmentIndex) {
                switch (evt.type) {
                    case msfsSdk.LegEventType.Added:
                        this.insertLeg(evt.legIndex, evt.leg);
                        break;
                    case msfsSdk.LegEventType.Removed:
                        this.removeLeg(evt.legIndex);
                        break;
                    case msfsSdk.LegEventType.Changed:
                        this.removeLeg(evt.legIndex);
                        this.insertLeg(evt.legIndex, evt.leg);
                        break;
                }
            }
            const plan = this.props.fms.getFlightPlan(evt.planIndex);
            const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            const segmentLegIndex = plan.getSegmentLegIndex(plan.activeLateralLeg);
            const globalLegIndex = plan.activeLateralLeg;
            this.reconcileActiveLeg({ segmentIndex, segmentLegIndex, globalLegIndex });
            this.disableOnEmpty();
        }
        /**
         * Handles when the active leg changes.
         * @param evt The active leg event to process.
         */
        onActiveLegChanged(evt) {
            var _a;
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX && evt.type === msfsSdk.ActiveLegType.Lateral) {
                this.clearLegArrows();
                const inSegment = evt.segmentIndex === this.props.segment.segmentIndex;
                const directToState = this.props.fms.getDirectToState();
                if (inSegment) {
                    if (evt.legIndex === 0 && directToState !== msfsGarminsdk.DirectToState.TOEXISTING) {
                        this.header.instance.setLegArrow(LegArrowType.Between);
                    }
                    if (directToState !== msfsGarminsdk.DirectToState.TOEXISTING) {
                        const fplEntry = this.legList.instance.getChildInstance(evt.legIndex);
                        if (fplEntry !== null) {
                            const plan = this.props.fms.getFlightPlan(evt.planIndex);
                            const globalLegIndex = this.props.segment.offset + evt.legIndex;
                            if (globalLegIndex === 0 && globalLegIndex === plan.activeLateralLeg) {
                                fplEntry.setLegArrow(LegArrowType.None);
                            }
                            else {
                                const legDefinition = (_a = fplEntry.props.data) === null || _a === void 0 ? void 0 : _a.legDefinition.get();
                                const prevLeg = plan.tryGetLeg(evt.index - 1);
                                if (legDefinition &&
                                    (msfsSdk.BitFlags.isAny(legDefinition.flags, msfsSdk.LegDefinitionFlags.VectorsToFinalFaf)
                                        || (prevLeg && legDefinition.leg.type === msfsSdk.LegType.CF && prevLeg.leg.type === msfsSdk.LegType.ThruDiscontinuity))) {
                                    fplEntry.setLegArrow(LegArrowType.Direct);
                                    return;
                                }
                                else {
                                    fplEntry.setLegArrow(LegArrowType.To);
                                }
                            }
                        }
                        const prevFplEntry = this.legList.instance.getChildInstance(evt.legIndex - 1);
                        if (prevFplEntry !== null) {
                            prevFplEntry.setLegArrow(LegArrowType.From);
                        }
                    }
                    else if (directToState === msfsGarminsdk.DirectToState.TOEXISTING) {
                        const fplEntry = this.legList.instance.getChildInstance(evt.legIndex - 3);
                        if (fplEntry !== null) {
                            fplEntry.setLegArrow(LegArrowType.Direct);
                        }
                    }
                }
                else {
                    const plan = this.props.fms.getPrimaryFlightPlan();
                    const prevLeg = plan.tryGetLeg(evt.index - 1);
                    if (prevLeg !== null) {
                        const segment = plan.getSegmentFromLeg(prevLeg);
                        if (segment === this.props.segment && directToState !== msfsGarminsdk.DirectToState.TOEXISTING) {
                            const fplEntry = this.legList.instance.getChildInstance(this.legList.instance.length - 1);
                            if (fplEntry !== null) {
                                fplEntry.setLegArrow(LegArrowType.From);
                            }
                        }
                    }
                }
            }
        }
        /**
         * Clears all leg arrows in the FPL segment.
         */
        clearLegArrows() {
            for (let i = 0; i < this.legList.instance.length; i++) {
                const legEntry = this.legList.instance.getChildInstance(i);
                if (legEntry !== null) {
                    legEntry.setLegArrow(LegArrowType.None);
                }
            }
            this.header.instance.setLegArrow(LegArrowType.None);
        }
        /**
         * Disables the control when the segment contains no legs.
         */
        disableOnEmpty() {
            if (this.props.segment.legs.length === 0) {
                this.setDisabled(true);
                this.header.instance.setName('');
                this.header.instance.setDisabled(true);
            }
            else {
                if (this.isDisabled) {
                    this.setDisabled(false);
                    this.setHeader();
                }
            }
        }
        /**
         * Handles when the flight plan is calculated.
         * @param evt The event describing the calculation.
         */
        onCalculated(evt) {
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                for (let i = 0; i < this.props.segment.legs.length; i++) {
                    const leg = this.props.segment.legs[i];
                    const legItem = this.legs.tryGet(i);
                    legItem === null || legItem === void 0 ? void 0 : legItem.legDefinition.set(leg);
                }
            }
        }
        /**
         * Inserts a leg into the segment's legs.
         * @param index The index to insert at.
         * @param leg The leg to insert.
         */
        insertLeg(index, leg) {
            if (leg !== undefined) {
                const data = new GnsLegDataItem(leg);
                this.legs.insert(data, index);
            }
        }
        /**
         * Removes a leg from the segment's legs.
         * @param index The index to remove at.
         */
        removeLeg(index) {
            this.legs.removeAt(index);
            this.props.onFocusLegIndex(index);
        }
        /**
         * A callback called when the header is selected.
         */
        onHeaderSelected() {
            this.props.onSelected && this.props.onSelected(-1);
        }
        /**
         * A callback called when a leg is selected in the leg list.
         * @param item The data item that was selected.
         * @param control The control associated with the data item.
         * @param index The index of the item that was selected.
         */
        onLegSelected(item, control, index) {
            this.props.onSelected && this.props.onSelected(index);
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            super.destroy();
            (_a = this.legSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.calcSubscription) === null || _b === void 0 ? void 0 : _b.destroy();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el },
                msfsSdk.FSComponent.buildComponent(FPLSegmentHeader, { ref: this.header, scrollContainer: this.props.scrollContainer, type: this.props.segment.segmentType, fms: this.props.fms, onSelected: this.onHeaderSelected.bind(this) }),
                msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.legs, renderItem: (data) => msfsSdk.FSComponent.buildComponent(FPLEntry, { data: data, fms: this.props.fms, gnsType: this.props.gnsType }), ref: this.legList, scrollContainer: this.props.scrollContainer, hideScrollbar: true, onItemSelected: this.onLegSelected.bind(this) })));
        }
    }

    /**
     * The GNS FPL page.
     */
    class FPLPage extends Page {
        constructor() {
            super(...arguments);
            this.segments = msfsSdk.ArraySubject.create();
            this.fplnNameRegular = msfsSdk.FSComponent.createRef();
            this.fplnNameDto = msfsSdk.FSComponent.createRef();
            this.fplnNameDtoIcon = msfsSdk.FSComponent.createRef();
            this.fplnNameDtoIdent = msfsSdk.FSComponent.createRef();
            this.segmentList = msfsSdk.FSComponent.createRef();
            this.rootControl = msfsSdk.FSComponent.createRef();
            this.scrollContainer = msfsSdk.FSComponent.createRef();
            this.flightPlanName = msfsSdk.Subject.create('_____ / _____');
            this.blankLines = msfsSdk.ArraySubject.create();
            this.blankLinesList = msfsSdk.FSComponent.createRef();
            this.menu = new FPLPageMenu(this.props.fms);
            this.ppos = new msfsSdk.GeoPoint(0, 0);
            this.gpsIsValid = false;
        }
        /** @inheritDoc */
        onAfterRender() {
            const fpl = this.props.bus.getSubscriber();
            fpl.on('fplIndexChanged').handle(this.onPlanIndexChanged.bind(this));
            fpl.on('fplSegmentChange').handle(this.onSegmentChanged.bind(this));
            fpl.on('fplLegChange').handle(e => this.onPlanChanged(e.planIndex, e));
            fpl.on('fplActiveLegChange').handle(this.onActiveLegChanged.bind(this));
            fpl.on('fplDeleted').handle(e => this.onPlanChanged(e.planIndex));
            fpl.on('fplOriginDestChanged').handle(e => this.onPlanChanged(e.planIndex));
            fpl.on('fplCopied').handle(this.onPlanLoadedOrCopied.bind(this));
            fpl.on('fplLoaded').handle(this.onPlanLoadedOrCopied.bind(this));
            fpl.on('fplCalculated').handle(this.onCalculated.bind(this));
            this.props.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => {
                this.ppos.set(pos.lat, pos.long);
                if (this.props.fms.hasPrimaryFlightPlan()) {
                    this.updateLegCalculations(this.props.fms.getPrimaryFlightPlan());
                }
            });
            this.props.bus.getSubscriber().on('gps_system_state_changed_1').handle(state => {
                this.gpsIsValid = state === msfsSdk.GPSSystemState.SolutionAcquired || state === msfsSdk.GPSSystemState.DiffSolutionAcquired;
                if (this.props.fms.hasPrimaryFlightPlan()) {
                    this.updateLegCalculations(this.props.fms.getPrimaryFlightPlan());
                }
            });
            this.reconcileBlankLines();
        }
        /**
         * Handles the active plan index changes in Flight Planner.
         * @param evt The event describing the active plan index change.
         */
        onPlanIndexChanged(evt) {
            var _a;
            if (evt.planIndex === msfsGarminsdk.Fms.DTO_RANDOM_PLAN_INDEX) {
                this.fplnNameRegular.instance.classList.add('hidden');
                this.fplnNameDto.instance.classList.remove('hidden');
                const directToIdent = msfsSdk.ICAO.getIdent((_a = this.props.fms.getDirectToTargetIcao()) !== null && _a !== void 0 ? _a : msfsSdk.ICAO.emptyIcao);
                this.fplnNameDtoIdent.instance.textContent = directToIdent;
            }
            else {
                this.fplnNameRegular.instance.classList.remove('hidden');
                this.fplnNameDto.instance.classList.add('hidden');
            }
        }
        /**
         * Handles when a segment is changed.
         * @param evt The event describing the segment change.
         */
        onSegmentChanged(evt) {
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                switch (evt.type) {
                    case msfsSdk.SegmentEventType.Added:
                    case msfsSdk.SegmentEventType.Inserted:
                        evt.segment && this.segments.insert(evt.segment, evt.segmentIndex);
                        break;
                    case msfsSdk.SegmentEventType.Changed:
                        this.segments.removeAt(evt.segmentIndex);
                        evt.segment && this.segments.insert(evt.segment, evt.segmentIndex);
                        break;
                    case msfsSdk.SegmentEventType.Removed:
                        this.segments.removeAt(evt.segmentIndex);
                        break;
                }
                this.reconcileBlankLines();
            }
            this.onPlanChanged(evt.planIndex);
        }
        /**
         * Handles when the active leg changes.
         * @param evt The active leg change event to process.
         */
        onActiveLegChanged(evt) {
            var _a, _b, _c, _d, _e, _f;
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX && evt.type === msfsSdk.ActiveLegType.Lateral) {
                (_b = (_a = this.segmentList.instance.getChildInstance(evt.previousSegmentIndex)) === null || _a === void 0 ? void 0 : _a.legs.get(evt.previousLegIndex)) === null || _b === void 0 ? void 0 : _b.legDefinition.notify();
                (_d = (_c = this.segmentList.instance.getChildInstance(evt.segmentIndex)) === null || _c === void 0 ? void 0 : _c.legs.get(evt.legIndex)) === null || _d === void 0 ? void 0 : _d.legDefinition.notify();
                if (this.props.fms.getDirectToState() === msfsGarminsdk.DirectToState.TOEXISTING) {
                    const plan = this.props.fms.getPrimaryFlightPlan();
                    (_f = (_e = this.segmentList.instance.getChildInstance(plan.directToData.segmentIndex)) === null || _e === void 0 ? void 0 : _e.legs.get(plan.directToData.segmentLegIndex)) === null || _f === void 0 ? void 0 : _f.legDefinition.notify();
                }
                else {
                    this.checkIfVtfLegIsActive();
                }
                if (!this.rootControl.instance.isFocused) {
                    this.scrollToActive();
                    this.rootControl.instance.blur();
                }
            }
        }
        /**
         * Handles when a plan change event is received.
         * @param planIndex The index of the plan change.
         * @param evt A FlightPlanLegEvent, if any.
         */
        onPlanChanged(planIndex, evt) {
            var _a, _b, _c, _d;
            if (planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                this.reconcileBlankLines();
                const plan = this.props.fms.getPrimaryFlightPlan();
                let originName = '_____';
                if (plan.originAirport !== undefined) {
                    originName = msfsSdk.ICAO.getIdent(plan.originAirport).trim();
                }
                else {
                    originName = (_b = (_a = plan.tryGetLeg(0)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '_____';
                }
                let destinationName = '_____';
                if (plan.length > 1) {
                    if (plan.destinationAirport !== undefined) {
                        destinationName = msfsSdk.ICAO.getIdent(plan.destinationAirport).trim();
                    }
                    else {
                        destinationName = (_d = (_c = plan.tryGetLeg(plan.length - 1)) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '_____';
                    }
                }
                this.flightPlanName.set(`${originName} / ${destinationName}`);
                if (evt && evt.type === msfsSdk.LegEventType.Removed) {
                    if (evt.segmentIndex !== -1) {
                        const segment = plan.getSegment(evt.segmentIndex);
                        if (evt.legIndex < segment.legs.length) {
                            this.onFocusLegIndex(segment, evt.legIndex);
                        }
                        else {
                            this.onFocusLegIndex(segment, Math.max(0, evt.legIndex - 1));
                        }
                    }
                }
            }
        }
        /**
         * Handles updating leg calculations when the plan is calculated.
         * @param evt The flight plan calculated event to process.
         */
        onCalculated(evt) {
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                this.updateLegCalculations(this.props.fms.getPrimaryFlightPlan());
            }
        }
        /**
         * Reconciles the active leg index when a plan change occurs that does not fire the active leg changed event.
         * @param evt FlightPlanLegEvent.
         */
        reconcileActiveLeg(evt) {
            var _a, _b;
            const prevSegmentIndex = evt.legIndex === 0 ? evt.segmentIndex - 1 : evt.segmentIndex;
            const plan = this.props.fms.getPrimaryFlightPlan();
            const legIndexes = {
                segmentIndex: evt.segmentIndex,
                segmentLegIndex: evt.legIndex,
                globalLegIndex: msfsGarminsdk.FmsUtils.getGlobalLegIndex(plan, evt.segmentIndex, evt.legIndex)
            };
            prevSegmentIndex !== evt.segmentIndex && ((_a = this.segmentList.instance.getChildInstance(prevSegmentIndex)) === null || _a === void 0 ? void 0 : _a.reconcileActiveLeg(legIndexes));
            (_b = this.segmentList.instance.getChildInstance(evt.segmentIndex)) === null || _b === void 0 ? void 0 : _b.reconcileActiveLeg(legIndexes);
        }
        /**
         * Checks if the VTF leg is active and, if so, sets the active leg arrow.
         */
        checkIfVtfLegIsActive() {
            var _a, _b;
            if (this.props.fms.isApproachVtf()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
                const activeSegment = plan.tryGetSegment(activeSegmentIndex);
                if ((activeSegment === null || activeSegment === void 0 ? void 0 : activeSegment.segmentType) === msfsSdk.FlightPlanSegmentType.Approach) {
                    const activeLeg = plan.tryGetLeg(plan.activeLateralLeg);
                    if (activeLeg && msfsSdk.BitFlags.isAny(activeLeg.flags, msfsSdk.LegDefinitionFlags.VectorsToFinalFaf)) {
                        (_b = (_a = this.segmentList.instance.getChildInstance(activeSegmentIndex)) === null || _a === void 0 ? void 0 : _a.legs.get(plan.activeLateralLeg - activeSegment.offset)) === null || _b === void 0 ? void 0 : _b.legDefinition.notify();
                    }
                }
            }
        }
        /**
         * Updates the leg calculations in the segment leg entries.
         * @param plan The plan to source from.
         */
        updateLegCalculations(plan) {
            var _a;
            const activeLegIndex = plan.activeLateralLeg;
            const inDirectTo = this.props.fms.getDirectToState() === msfsGarminsdk.DirectToState.TOEXISTING;
            let currentLegIndex = 0;
            let cumulativeDistance = 0;
            for (let i = 0; i < this.segmentList.instance.length; i++) {
                const fplSegment = this.segmentList.instance.getChildInstance(i);
                if (fplSegment !== null) {
                    const segmentIndex = fplSegment.props.segment.segmentIndex;
                    for (let l = 0; l < fplSegment.legs.length; l++) {
                        const leg = plan.getLeg(segmentIndex, l);
                        const legDataItem = fplSegment.legs.get(l);
                        if (leg.calculated !== undefined) {
                            let legDistance = 0;
                            if (currentLegIndex === activeLegIndex && leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                                legDistance = msfsSdk.UnitType.GA_RADIAN.convertTo(this.ppos.distance(leg.calculated.endLat, leg.calculated.endLon), msfsSdk.UnitType.METER);
                            }
                            else if (currentLegIndex > activeLegIndex && !msfsSdk.BitFlags.isAny(leg.flags, msfsSdk.LegDefinitionFlags.DirectTo)) {
                                legDistance = leg.calculated.distance;
                            }
                            if (currentLegIndex < activeLegIndex) {
                                legDataItem.cumulativeDistance.set(NaN);
                                legDataItem.distance.set(NaN);
                                legDataItem.dtk.set(NaN);
                            }
                            else {
                                cumulativeDistance += legDistance;
                                if (this.gpsIsValid) {
                                    legDataItem.cumulativeDistance.set(cumulativeDistance, msfsSdk.UnitType.METER);
                                    legDataItem.distance.set(legDistance, msfsSdk.UnitType.METER);
                                }
                                else {
                                    legDataItem.cumulativeDistance.set(NaN);
                                    legDataItem.distance.set(NaN);
                                }
                                legDataItem.dtk.set((_a = leg.calculated.initialDtk) !== null && _a !== void 0 ? _a : NaN);
                            }
                            if (inDirectTo && currentLegIndex === activeLegIndex) {
                                const directToTarget = fplSegment.legs.get(l - 3);
                                const finalVector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
                                let dtk = finalVector !== undefined
                                    ? msfsSdk.GeoPoint.initialBearing(finalVector.startLat, finalVector.startLon, finalVector.endLat, finalVector.endLon)
                                    : NaN;
                                if (isFinite(dtk)) {
                                    dtk = msfsSdk.MagVar.trueToMagnetic(dtk, finalVector.startLat, finalVector.startLon);
                                }
                                if (this.gpsIsValid) {
                                    directToTarget.cumulativeDistance.set(cumulativeDistance, msfsSdk.UnitType.METER);
                                    directToTarget.distance.set(legDistance, msfsSdk.UnitType.METER);
                                }
                                else {
                                    directToTarget.cumulativeDistance.set(NaN);
                                    directToTarget.distance.set(NaN);
                                }
                                directToTarget.dtk.set(dtk);
                            }
                        }
                        currentLegIndex++;
                    }
                }
            }
        }
        /**
         * Scrolls the FPL page to the active leg.
         */
        scrollToActive() {
            if (!this.props.fms.hasPrimaryFlightPlan()) {
                return;
            }
            const plan = this.props.fms.getPrimaryFlightPlan();
            const directToState = this.props.fms.getDirectToState();
            const index = directToState === msfsGarminsdk.DirectToState.TOEXISTING ? plan.activeLateralLeg - 3 : plan.activeLateralLeg - 1;
            const prevLeg = plan.tryGetLeg(index);
            if (prevLeg !== null) {
                const segment = plan.getSegmentFromLeg(prevLeg);
                for (let i = 0; i < this.segments.length; i++) {
                    if (segment === this.segments.get(i)) {
                        const fplSegment = this.segmentList.instance.getChildInstance(i);
                        if (fplSegment !== null) {
                            fplSegment.scrollToLeg(index - segment.offset);
                        }
                    }
                }
            }
        }
        /**
         * Handles when a plan is loaded or copied.
         * @param evt The event describing the change.
         */
        onPlanLoadedOrCopied(evt) {
            if (evt.planIndex === msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) {
                this.segments.clear();
                const plan = this.props.fms.getPrimaryFlightPlan();
                for (const segment of plan.segments()) {
                    this.segments.insert(segment, segment.segmentIndex);
                }
                this.reconcileBlankLines();
            }
            this.onPlanChanged(evt.planIndex);
        }
        /** @inheritDoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RightKnobPush) {
                const root = this.rootControl.instance;
                if (!root.isFocused) {
                    root.focus(msfsSdk.FocusPosition.MostRecent);
                }
                else {
                    this.scrollToActive();
                    root.blur();
                }
                return true;
            }
            if (evt === InteractionEvent.FPL) {
                ViewService.back();
                return true;
            }
            let handled = false;
            if (this.rootControl.instance.isFocused) {
                handled = this.rootControl.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (evt === InteractionEvent.RightOuterInc || evt === InteractionEvent.RightOuterDec) {
                return true;
            }
            else if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.menu);
                return true;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritdoc */
        onSuspend() {
            this.rootControl.instance.blur();
            super.onSuspend();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.scrollToActive();
            this.rootControl.instance.blur();
        }
        /**
         * A callback called when a segment in the plan is selected.
         * @param segment The segment that was selected.
         * @param control The segment control that was selected.
         */
        onSegmentSelected(segment, control) {
            if (segment === null) {
                this.menu.segmentIndex = -1;
                this.menu.legIndex = -1;
                if (this.currentSelectedControl !== undefined) {
                    this.currentSelectedControl.props.onSelected = undefined;
                }
            }
            else if (control !== null) {
                this.menu.segmentIndex = segment.segmentIndex;
                control.props.onSelected = (legIndex) => this.menu.legIndex = legIndex;
            }
        }
        /**
         * Handles an event requesting a leg originally at an index in a segment be focused
         *
         * @param segment  the segment
         * @param legIndex the local index
         */
        onFocusLegIndex(segment, legIndex) {
            var _a;
            const globalIndex = ((_a = segment === null || segment === void 0 ? void 0 : segment.offset) !== null && _a !== void 0 ? _a : 0) + legIndex;
            const plan = this.props.fms.getPrimaryFlightPlan();
            if (plan.length <= 0) {
                this.blankLinesList.instance.focus(msfsSdk.FocusPosition.First);
                return;
            }
            const targetSegment = plan.getSegment(plan.getSegmentIndex(Math.min(globalIndex, plan.length - 1)));
            const targetSegmentElementIndex = this.segments.getArray().findIndex((it) => it === targetSegment);
            const targetSegmentElement = this.segmentList.instance.getChildInstance(targetSegmentElementIndex);
            const targetSegmentLocalLegIndex = legIndex - targetSegment.segmentIndex;
            targetSegmentElement === null || targetSegmentElement === void 0 ? void 0 : targetSegmentElement.focusLeg(targetSegmentLocalLegIndex);
        }
        /**
         * Reconciles the number of blank lines that should appear in the FPL page list.
         */
        reconcileBlankLines() {
            var _a, _b, _c;
            let totalLines = 0;
            for (let i = 0; i < this.segmentList.instance.length; i++) {
                totalLines += (_b = (_a = this.segmentList.instance.getChildInstance(i)) === null || _a === void 0 ? void 0 : _a.getLineCount()) !== null && _b !== void 0 ? _b : 0;
            }
            const shouldRefocus = this.blankLinesList.instance.isFocused;
            const numBlankLines = Math.max(6 - totalLines, 1);
            while (this.blankLines.length !== numBlankLines) {
                if (this.blankLines.length < numBlankLines) {
                    this.blankLines.insert({ i: this.blankLines.length });
                }
                else if (this.blankLines.length > numBlankLines) {
                    this.blankLines.removeAt(0);
                }
            }
            for (let i = 0; i < this.blankLinesList.instance.length; i++) {
                (_c = this.blankLinesList.instance.getChild(i)) === null || _c === void 0 ? void 0 : _c.setDisabled(i !== 0);
            }
            this.segmentList.instance.setDisabled(totalLines === 0);
            if (shouldRefocus) {
                this.blankLinesList.instance.focus(msfsSdk.FocusPosition.First);
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page fpl-page hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-page-header' },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "page-header" }, "ACTIVE FLIGHT PLAN"),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-storage-id' }, "00"),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-name' },
                        msfsSdk.FSComponent.buildComponent("span", { ref: this.fplnNameRegular, class: "fpln-name-text" }, this.flightPlanName),
                        msfsSdk.FSComponent.buildComponent("span", { ref: this.fplnNameDto, class: "fpln-name-dto hidden" },
                            msfsSdk.FSComponent.buildComponent("img", { ref: this.fplnNameDtoIcon, class: "fpl-name-dto-icon", src: msfsSdk.ImageCache.get('LEGICON_DIRECTTO').src }),
                            msfsSdk.FSComponent.buildComponent("span", { ref: this.fplnNameDtoIdent, class: "fpln-name-dto-ident" }, "B")))),
                msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-page-body' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-page-table-header' },
                        msfsSdk.FSComponent.buildComponent("span", { class: 'fpl-table-header-wpt' }, "WAYPOINT"),
                        msfsSdk.FSComponent.buildComponent("span", { class: 'fpl-table-header-dtk' }, "DTK"),
                        msfsSdk.FSComponent.buildComponent("span", { class: 'fpl-table-header-dis' }, "DIS"),
                        this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent("span", { class: 'fpl-table-header-cum' }, "CUM"))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'fpl-page-table', ref: this.scrollContainer },
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.rootControl, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent("div", null,
                                msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.segments, renderItem: (data) => (msfsSdk.FSComponent.buildComponent(FPLSegment, { segment: data, bus: this.props.bus, fms: this.props.fms, gnsType: this.props.gnsType, scrollContainer: this.scrollContainer, onFocusLegIndex: this.onFocusLegIndex.bind(this, data) })), ref: this.segmentList, onItemSelected: this.onSegmentSelected.bind(this), disableContainerScroll: true, scrollContainer: this.scrollContainer, hideScrollbar: true })),
                            msfsSdk.FSComponent.buildComponent("div", null,
                                msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.blankLines, renderItem: () => msfsSdk.FSComponent.buildComponent(FPLEntry, { fms: this.props.fms, gnsType: this.props.gnsType }), ref: this.blankLinesList, scrollContainer: this.scrollContainer, hideScrollbar: true })))),
                    msfsSdk.FSComponent.buildComponent(GNSScrollBar, null))));
        }
    }
    /**
     * The page menu for the FPL page.
     */
    class FPLPageMenu extends MenuDefinition {
        /**
         * Creates an instance of the FPLPageMenu.
         * @param fms An instance of the flight plan management system.
         */
        constructor(fms) {
            super();
            this.fms = fms;
            this.segmentIndex = 0;
            this.legIndex = 0;
            this.entries = [
                {
                    label: 'Activate Leg?', disabled: msfsSdk.Subject.create(true), action: () => {
                        const plan = this.fms.getPrimaryFlightPlan();
                        const leg = plan.tryGetLeg(this.segmentIndex, this.legIndex);
                        if (leg === null) {
                            console.warn(`Trying to activate invalid leg from flight plan: segment ${this.segmentIndex} leg ${this.legIndex}`);
                            ViewService.back();
                        }
                        else {
                            ViewService.activateLegDialog(plan.getLegIndexFromLeg(leg));
                        }
                    }
                },
                { label: 'Crossfill?', disabled: msfsSdk.Subject.create(true), action: () => { } },
                { label: 'Copy Flight Plan?', disabled: msfsSdk.Subject.create(true), action: () => { } },
                { label: 'Invert Flight Plan?', disabled: msfsSdk.Subject.create(true), action: () => this.fms.invertFlightplan() },
                {
                    label: 'Delete Flight Plan?',
                    disabled: msfsSdk.Subject.create(true),
                    action: () => ViewService.confirm('DELETE FLIGHT PLAN', 'Delete all waypoints in flight plan.').then(confirm => {
                        confirm && this.fms.emptyPrimaryFlightPlan().then(() => {
                            ViewService.back();
                        });
                    })
                },
                {
                    label: 'Select Approach?', disabled: false, action: () => {
                        var _a;
                        ViewService.back();
                        (_a = ViewService.open('WPT', true, 3)) === null || _a === void 0 ? void 0 : _a.openFromProcMenu();
                    }
                },
                {
                    label: 'Select Arrival?', disabled: false, action: () => {
                        var _a;
                        ViewService.back();
                        (_a = ViewService.open('WPT', true, 4)) === null || _a === void 0 ? void 0 : _a.openFromProcMenu();
                    }
                },
                {
                    label: 'Select Departure?', disabled: false, action: () => {
                        var _a;
                        ViewService.back();
                        (_a = ViewService.open('WPT', true, 5)) === null || _a === void 0 ? void 0 : _a.openFromProcMenu();
                    }
                },
                { label: 'Remove Approach?', disabled: msfsSdk.Subject.create(true), action: () => this.confirmApproachRemoval() },
                { label: 'Remove Arrival?', disabled: msfsSdk.Subject.create(true), action: () => this.confirmArrivalRemoval() },
                { label: 'Remove Departure?', disabled: msfsSdk.Subject.create(true), action: () => this.confirmDepartureRemoval() },
                { label: 'Closest Point of FPL?', disabled: msfsSdk.Subject.create(true), action: () => { } },
                { label: 'Parallel Track?', disabled: msfsSdk.Subject.create(true), action: () => { } },
                { label: 'Change Fields?', disabled: msfsSdk.Subject.create(true), action: () => { } },
                { label: 'Restore Defaults?', disabled: msfsSdk.Subject.create(true), action: () => { } },
            ];
        }
        /**
         * Confirms removal of the flight plan approach.
         */
        async confirmApproachRemoval() {
            const names = await FPLPageUtils.getApproachNames(this.fms);
            if (names !== undefined) {
                const confirmed = await ViewService.confirm('REMOVE APPROACH', `Remove ${names.long} from flight plan.`);
                if (confirmed) {
                    await this.fms.removeApproach();
                    ViewService.back();
                }
            }
        }
        /**
         * Confirms removal of the flight plan arrival.
         */
        async confirmArrivalRemoval() {
            const names = await FPLPageUtils.getArrivalNames(this.fms);
            if (names !== undefined) {
                const confirmed = await ViewService.confirm('REMOVE ARRIVAL', `Remove ${names.long} from flight plan.`);
                if (confirmed) {
                    await this.fms.removeArrival();
                    ViewService.back();
                }
            }
        }
        /**
         * Confirms removal of the flight plan departure.
         */
        async confirmDepartureRemoval() {
            const names = await FPLPageUtils.getDepartureNames(this.fms);
            if (names !== undefined) {
                const confirmed = await ViewService.confirm('REMOVE DEPARTURE', `Remove ${names.long} from flight plan.`);
                if (confirmed) {
                    await this.fms.removeDeparture();
                    ViewService.back();
                }
            }
        }
        /** @inheritdoc */
        updateEntries() {
            const hasPlan = this.fms.hasPrimaryFlightPlan() && this.fms.getPrimaryFlightPlan().length !== 0;
            this.setEntryDisabled(0, !this.fms.canActivateLeg(this.segmentIndex, this.legIndex));
            this.setEntryDisabled(3, !hasPlan);
            this.setEntryDisabled(4, !hasPlan);
            this.setEntryDisabled(8, hasPlan && this.fms.getPrimaryFlightPlan().procedureDetails.approachIndex === -1);
            this.setEntryDisabled(9, hasPlan && this.fms.getPrimaryFlightPlan().procedureDetails.arrivalIndex === -1);
            this.setEntryDisabled(10, hasPlan && this.fms.getPrimaryFlightPlan().procedureDetails.departureIndex === -1);
        }
    }

    /**
     * The GNS GPS status page.
     */
    class GPSStatus extends Page {
        constructor() {
            super(...arguments);
            this.canvasEl = msfsSdk.FSComponent.createRef();
            this.nullProjection = new msfsSdk.MapProjection(8, 8);
            this.label = new GPSSatelliteTextLabel();
            this.statusText = msfsSdk.Subject.create('SEARCHING');
            this.hfom = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FOOT.createNumber(NaN));
            this.vfom = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FOOT.createNumber(NaN));
            this.epu = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            this.activeSatellites = msfsSdk.ArraySubject.create();
            this.satelliteBars = msfsSdk.FSComponent.createRef();
            this.ppos = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
            this.altitude = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.METER.createNumber(NaN));
            this.simTime = msfsSdk.Subject.create(NaN);
            this.shouldGoToMapOn3DNav = false;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.clockSub = this.props.bus.getSubscriber().on('realTime').atFrequency(1).handle(this.drawSatellites.bind(this));
            this.props.bus.getSubscriber().on('simTime').atFrequency(1).handle(this.onSimTimeChanged.bind(this));
            this.props.bus.getSubscriber().on('gps_sat_state_changed_1').handle(this.onGpsSatStateChanged.bind(this));
            this.props.bus.getSubscriber().on('gps_system_state_changed_1').handle(this.onGpsSystemStateChanged.bind(this));
            this.props.bus.getSubscriber().on('gps-position').handle(this.onGpsPositionChanged.bind(this));
            this.props.bus.getSubscriber().on('instrument_powered').handle(this.onPowerStateChanged.bind(this));
        }
        /**
         * Handles when the GNS power state changes.
         * @param state The new power state.
         */
        onPowerStateChanged(state) {
            if (state === PowerState.On) {
                this.shouldGoToMapOn3DNav = true;
            }
        }
        /**
         * Handles when the GPS position has changed.
         * @param pos The new GPS position.
         */
        onGpsPositionChanged(pos) {
            if (this.props.sats.state !== msfsSdk.GPSSystemState.SolutionAcquired && this.props.sats.state !== msfsSdk.GPSSystemState.DiffSolutionAcquired) {
                this.ppos.set(NaN, NaN);
                this.altitude.set(NaN);
            }
            else {
                this.ppos.set(pos.lat, pos.long);
                this.altitude.set(pos.alt);
            }
        }
        /**
         * Handles when the GPS system state has changed.
         * @param state The new GPS system state.
         */
        onGpsSystemStateChanged(state) {
            switch (state) {
                case msfsSdk.GPSSystemState.Searching:
                    this.statusText.set('SEARCHING');
                    break;
                case msfsSdk.GPSSystemState.Acquiring:
                    this.statusText.set('ACQUIRING');
                    break;
                case msfsSdk.GPSSystemState.SolutionAcquired:
                    this.statusText.set('3D NAV');
                    if (this.shouldGoToMapOn3DNav) {
                        ViewService.open('NAV', true, 1);
                        this.shouldGoToMapOn3DNav = false;
                    }
                    break;
                case msfsSdk.GPSSystemState.DiffSolutionAcquired:
                    this.statusText.set('3D DIFF NAV');
                    if (this.shouldGoToMapOn3DNav) {
                        ViewService.open('NAV', true, 1);
                        this.shouldGoToMapOn3DNav = false;
                    }
                    break;
            }
        }
        /**
         * Handles when a GPS satellite state changes.
         * @param sat The satellite whose state has changed.
         */
        onGpsSatStateChanged(sat) {
            const satState = sat.state.get();
            if (satState === msfsSdk.GPSSatelliteState.None || satState === msfsSdk.GPSSatelliteState.Unreachable) {
                this.activeSatellites.removeItem(sat);
            }
            else {
                const index = this.activeSatellites.getArray().indexOf(sat);
                if (index === -1) {
                    this.activeSatellites.insert(sat);
                }
                let inUseSatellites = 0;
                this.activeSatellites.getArray().forEach(s => (s.state.get() === msfsSdk.GPSSatelliteState.InUse || s.state.get() === msfsSdk.GPSSatelliteState.InUseDiffApplied) && inUseSatellites++);
                this.updateStatusValues(inUseSatellites);
            }
        }
        /**
         * Handles when the sim time changes.
         * @param t The new sim time.
         */
        onSimTimeChanged(t) {
            if (this.props.sats.state !== msfsSdk.GPSSystemState.SolutionAcquired && this.props.sats.state !== msfsSdk.GPSSystemState.DiffSolutionAcquired) {
                this.simTime.set(NaN);
            }
            else {
                this.simTime.set(t);
            }
        }
        /** @inheritdoc */
        onSuspend() {
            var _a;
            super.onSuspend();
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        /** @inheritdoc */
        onResume() {
            var _a;
            super.onResume();
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.resume();
        }
        /**
         * Updates the GPS status computed values based on the number of available
         * satellites in use.
         * @param inUse The number of satellites in use.
         */
        updateStatusValues(inUse) {
            if (inUse >= 6) {
                this.hfom.set(16);
                this.vfom.set(24);
                this.epu.set(0.03);
            }
            else if (inUse === 5) {
                this.hfom.set(22);
                this.vfom.set(28);
                this.epu.set(0.05);
            }
            else if (inUse === 4) {
                this.hfom.set(30);
                this.vfom.set(36);
                this.epu.set(0.08);
            }
            else {
                this.hfom.set(NaN);
                this.vfom.set(NaN);
                this.epu.set(NaN);
            }
        }
        /**
         * Draws the satellite sky display.
         */
        drawSatellites() {
            const context = this.canvasEl.instance.getContext('2d');
            this.label.displaySize.set(this.canvasEl.instance.width, this.canvasEl.instance.height);
            if (context !== null) {
                context.clearRect(0, 0, this.canvasEl.instance.width, this.canvasEl.instance.height);
                const cx = this.canvasEl.instance.width / 2;
                const cy = this.canvasEl.instance.height / 2;
                const radius = cy - 3;
                context.strokeStyle = '#0f0';
                context.lineWidth = 1;
                context.beginPath();
                context.ellipse(cx, cy, radius, radius, 0, 0, 2 * Math.PI);
                context.ellipse(cx, cy, radius / 2, radius / 2, 0, 0, 2 * Math.PI);
                context.ellipse(cx, cy, 2, 2, 0, 0, 2 * Math.PI);
                context.stroke();
                const maxZenithAngle = (Math.PI / 2) + this.props.sats.calcHorizonAngle();
                this.label.maxZenithAngle.set(maxZenithAngle);
                let numVisible = 0;
                for (const sat of this.props.sats.sats) {
                    const satState = sat.state.get();
                    const pos = sat.position.get();
                    if (satState !== msfsSdk.GPSSatelliteState.None && satState !== msfsSdk.GPSSatelliteState.Unreachable && numVisible < 15) {
                        numVisible++;
                        const displayPrn = sat.prn < 100 ? sat.prn : (sat.prn - 100) + 20;
                        this.label.text.set(displayPrn.toFixed(0).padStart(2, '0'));
                        this.label.state.set(sat.state.get());
                        this.label.location.set(pos);
                        this.label.draw(context, this.nullProjection);
                    }
                }
            }
        }
        /**
         * Renders the bottom position status.
         * @returns The 530 status or nothing on the 430
         */
        renderBottomPositionStatus() {
            if (this.props.gnsType === 'wt430') {
                return (msfsSdk.FSComponent.buildComponent("div", null));
            }
            else {
                return (msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-postimealt' },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("h3", null, "POSITION"),
                        msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { class: 'gps-status-positionbox', location: this.ppos })),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("h3", null, "TIME"),
                        msfsSdk.FSComponent.buildComponent(GNSTimeDisplay, { class: 'gps-status-timebox', time: this.simTime, format: this.props.settingsProvider.time.getSetting('dateTimeFormat').map(s => GNSFieldTimeRenderer.FORMAT_SETTING_MAP[s]), localOffset: this.props.settingsProvider.time.getSetting('dateTimeLocalOffset') })),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("h3", null, "ALT"),
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'gps-status-altbox', formatter: msfsSdk.NumberFormatter.create({ precision: 1, nanString: '_____' }), value: this.altitude, displayUnit: this.props.settingsProvider.units.altitudeUnits }))));
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page gps-status hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("canvas", { class: 'gps-status-map', ref: this.canvasEl, width: '112px', height: '92px' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-statuscontainer' },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("h3", null, "STATUS"),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-status' }, this.statusText)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-values' },
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent("label", null, "HFOM"),
                            msfsSdk.FSComponent.buildComponent("label", null, "VFOM"),
                            msfsSdk.FSComponent.buildComponent("label", null, "EPU")),
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 1, nanString: '_____' }), value: this.hfom, displayUnit: this.props.settingsProvider.units.distanceUnitsSmall }),
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 1, nanString: '_____' }), value: this.vfom, displayUnit: this.props.settingsProvider.units.distanceUnitsSmall }),
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 0.01, maxDigits: 3, nanString: '__.__' }), value: this.epu, displayUnit: this.props.settingsProvider.units.distanceUnitsLarge })))),
                msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-bargraph' },
                    msfsSdk.FSComponent.buildComponent("hr", null),
                    msfsSdk.FSComponent.buildComponent("hr", null),
                    msfsSdk.FSComponent.buildComponent("hr", null),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-bargraph-items' },
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.activeSatellites, renderItem: (v) => msfsSdk.FSComponent.buildComponent(SatelliteBar, { data: v }), orderBy: (a, b) => a.prn - b.prn }))),
                this.renderBottomPositionStatus()));
        }
    }
    /**
     * A component that displays a signal bar for a satellite.
     */
    class SatelliteBar extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.barEl = msfsSdk.FSComponent.createRef();
            this.diffEl = msfsSdk.FSComponent.createRef();
            this.diffInverseEl = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.stateSub = this.props.data.state.sub(v => {
                if (v === msfsSdk.GPSSatelliteState.InUse) {
                    this.barEl.instance.classList.add('in-use');
                    this.barEl.instance.classList.remove('acquired');
                    this.barEl.instance.classList.remove('data-collected');
                    this.diffEl.instance.classList.add('hide-element');
                    this.diffInverseEl.instance.classList.add('hide-element');
                }
                else if (v === msfsSdk.GPSSatelliteState.DataCollected) {
                    this.barEl.instance.classList.remove('in-use');
                    this.barEl.instance.classList.remove('acquired');
                    this.barEl.instance.classList.add('data-collected');
                    this.diffEl.instance.classList.add('hide-element');
                    this.diffInverseEl.instance.classList.add('hide-element');
                }
                else if (v === msfsSdk.GPSSatelliteState.Acquired) {
                    this.barEl.instance.classList.remove('in-use');
                    this.barEl.instance.classList.add('acquired');
                    this.barEl.instance.classList.remove('data-collected');
                    this.diffEl.instance.classList.add('hide-element');
                    this.diffInverseEl.instance.classList.add('hide-element');
                }
                else if (v === msfsSdk.GPSSatelliteState.InUseDiffApplied) {
                    this.barEl.instance.classList.add('in-use');
                    this.barEl.instance.classList.remove('acquired');
                    this.barEl.instance.classList.remove('data-collected');
                    this.diffEl.instance.classList.remove('hide-element');
                    this.diffInverseEl.instance.classList.remove('hide-element');
                }
                else {
                    this.barEl.instance.classList.remove('in-use');
                    this.barEl.instance.classList.remove('acquired');
                    this.barEl.instance.classList.remove('data-collected');
                    this.diffEl.instance.classList.add('hide-element');
                    this.diffInverseEl.instance.classList.add('hide-element');
                }
            }, true);
            const signalConsumer = new msfsSdk.BasicConsumer((h, p) => this.props.data.signalStrength.sub(h, true, p));
            this.signalSub = signalConsumer.withPrecision(2).handle(s => this.barEl.instance.style.height = `${s * 44}px`);
        }
        /**
         * A callback called to pause the item when the page is paused.
         */
        onPause() {
            var _a, _b;
            (_a = this.stateSub) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.signalSub) === null || _b === void 0 ? void 0 : _b.pause();
        }
        /**
         * A callback called to resume the item when the page is resumed.
         */
        onResume() {
            var _a, _b;
            (_a = this.stateSub) === null || _a === void 0 ? void 0 : _a.resume();
            (_b = this.signalSub) === null || _b === void 0 ? void 0 : _b.resume();
        }
        /** @inheritdoc */
        destroy() {
            var _a, _b;
            (_a = this.stateSub) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this.signalSub) === null || _b === void 0 ? void 0 : _b.destroy();
        }
        /**
         * Formats the satellite PRN, converting +100 PRNs into unused higher than 32 numbers.
         * @returns The formatted PRN as a string to display.
         */
        formatPrn() {
            const displayPrn = this.props.data.prn < 100 ? this.props.data.prn : (this.props.data.prn - 100) + 20;
            return displayPrn.toFixed(0).padStart(2, '0');
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-bargraph-item' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-bargraph-bar inverse' },
                    msfsSdk.FSComponent.buildComponent("span", { ref: this.diffInverseEl }, "D")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-bargraph-bar', ref: this.barEl },
                    msfsSdk.FSComponent.buildComponent("span", { ref: this.diffEl }, "D")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'gps-status-bargraph-prn' }, this.formatPrn())));
        }
    }
    /**
     * A text label for a GPS satellite.
     */
    class GPSSatelliteTextLabel extends msfsSdk.AbstractMapTextLabel {
        /**
         * Constructor.
         */
        constructor() {
            const text = msfsSdk.Subject.create('');
            const state = msfsSdk.Subject.create(msfsSdk.GPSSatelliteState.Unreachable);
            const fontColor = msfsSdk.ComputedSubject.create(msfsSdk.GPSSatelliteState.None, s => {
                switch (s) {
                    case msfsSdk.GPSSatelliteState.Acquired:
                        return '#0ff';
                    default:
                        return 'black';
                }
            });
            const bgColor = msfsSdk.ComputedSubject.create(msfsSdk.GPSSatelliteState.None, s => {
                switch (s) {
                    case msfsSdk.GPSSatelliteState.DataCollected:
                        return 'cyan';
                    case msfsSdk.GPSSatelliteState.InUseDiffApplied:
                    case msfsSdk.GPSSatelliteState.InUse:
                        return '#0f0';
                    default:
                        return 'black';
                }
            });
            state.sub(s => {
                fontColor.set(s);
                bgColor.set(s);
            });
            super(text, 0, {
                font: 'GreatNiftySymbol-Regular',
                fontSize: 10,
                fontColor: fontColor,
                bgColor: bgColor,
                bgBorderRadius: 2,
                bgPadding: new Float64Array([1, 1, 0, 1]),
                anchor: new Float64Array([0.5, 0.5]),
                showBg: true
            });
            this.text = text;
            this.state = state;
            this.location = msfsSdk.Vec2Subject.create(new Float64Array(2));
            this.displaySize = msfsSdk.Vec2Subject.create(new Float64Array(2));
            this.maxZenithAngle = msfsSdk.Subject.create(90);
        }
        /** @inheritdoc */
        getPosition(mapProjection, out) {
            const pos = this.location.get();
            const cx = this.displaySize.get()[0] / 2;
            const cy = this.displaySize.get()[1] / 2;
            const radius = (pos[0] / this.maxZenithAngle.get()) * Math.min(cx, cy) - 3;
            const theta = pos[1] - (Math.PI / 2);
            const x = (radius * Math.cos(theta)) + (cx);
            const y = (radius * Math.sin(theta)) + (cy);
            msfsSdk.Vec2Math.set(x, y, out);
            return out;
        }
    }

    /**
     * A control that contains the map setup menu.
     */
    class MapSetup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.groups = new Map([
                [MapSetupGroups530.Map, msfsSdk.FSComponent.createRef()],
                [MapSetupGroups530.Waypoint, msfsSdk.FSComponent.createRef()],
                [MapSetupGroups530.Traffic, msfsSdk.FSComponent.createRef()],
                [MapSetupGroups430.Airport, msfsSdk.FSComponent.createRef()],
                [MapSetupGroups430.NAVAID, msfsSdk.FSComponent.createRef()]
            ]);
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.onGroupSelected(MapSetupGroups530.Map);
        }
        /**
         * Sets whether or not the map setup pane is open.
         * @param isOpen True if open, false otherwise.
         */
        setOpen(isOpen) {
            if (isOpen) {
                this.el.instance.classList.remove('hide-element');
                this.focus(msfsSdk.FocusPosition.First);
            }
            else {
                this.el.instance.classList.add('hide-element');
                this.blur();
            }
        }
        /**
         * Selects a map settings group to display.
         * @param group The group to display.
         */
        onGroupSelected(group) {
            var _a;
            this.groups.forEach(g => { var _a; return (_a = g.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(false); });
            (_a = this.groups.get(group)) === null || _a === void 0 ? void 0 : _a.instance.setVisible(true);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'std-map-setup hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("h3", { class: 'map-setup-title' }, "MAP SETUP"),
                msfsSdk.FSComponent.buildComponent(MapSetupGroup, { onGroupSelected: g => this.onGroupSelected(g), gnsType: this.props.gnsType }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings' },
                    msfsSdk.FSComponent.buildComponent(MapGroup, { settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, ref: this.groups.get(MapSetupGroups530.Map) }),
                    msfsSdk.FSComponent.buildComponent(TrafficGroup, { settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, ref: this.groups.get(MapSetupGroups530.Traffic) }),
                    msfsSdk.FSComponent.buildComponent(WaypointGroup, { settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, ref: this.groups.get(MapSetupGroups530.Waypoint) }),
                    msfsSdk.FSComponent.buildComponent(AirportGroup, { settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, ref: this.groups.get(MapSetupGroups430.Airport) }),
                    msfsSdk.FSComponent.buildComponent(NAVAIDGroup, { settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, ref: this.groups.get(MapSetupGroups430.NAVAID) }))));
        }
    }
    var MapSetupGroups530;
    (function (MapSetupGroups530) {
        MapSetupGroups530["Map"] = "Map";
        MapSetupGroups530["Weather"] = "Weather";
        MapSetupGroups530["Traffic"] = "Traffic";
        MapSetupGroups530["LineRoad"] = "Line/Road";
        MapSetupGroups530["Waypoint"] = "Waypoint";
        MapSetupGroups530["Airspace"] = "Airspace";
        MapSetupGroups530["CityOther"] = "City/Other";
    })(MapSetupGroups530 || (MapSetupGroups530 = {}));
    var MapSetupGroups430;
    (function (MapSetupGroups430) {
        MapSetupGroups430["Map"] = "Map";
        MapSetupGroups430["Weather"] = "Weather";
        MapSetupGroups430["Traffic"] = "Traffic";
        MapSetupGroups430["Airport"] = "Airport";
        MapSetupGroups430["NAVAID"] = "NAVAID";
        MapSetupGroups430["Waypoint"] = "Waypoint";
        MapSetupGroups430["Line"] = "Line";
        MapSetupGroups430["Control"] = "Control";
        MapSetupGroups430["Airspace"] = "Airspace";
        MapSetupGroups430["City"] = "City";
        MapSetupGroups430["Road"] = "Road";
        MapSetupGroups430["Other"] = "Other";
    })(MapSetupGroups430 || (MapSetupGroups430 = {}));
    /**
     * A control that changes the map setup group.
     */
    class MapSetupGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.selected = msfsSdk.Subject.create('Map');
            this.selectedEl = msfsSdk.FSComponent.createRef();
            this.menu530 = [
                { label: MapSetupGroups530.Map, disabled: false, action: () => this.selectGroup(MapSetupGroups530.Map) },
                { label: MapSetupGroups530.Weather, disabled: false, action: () => this.selectGroup(MapSetupGroups530.Weather) },
                { label: MapSetupGroups530.Traffic, disabled: false, action: () => this.selectGroup(MapSetupGroups530.Traffic) },
                { label: MapSetupGroups530.LineRoad, disabled: true, action: () => this.selectGroup(MapSetupGroups530.LineRoad) },
                { label: MapSetupGroups530.Waypoint, disabled: false, action: () => this.selectGroup(MapSetupGroups530.Waypoint) },
                { label: MapSetupGroups530.Airspace, disabled: false, action: () => this.selectGroup(MapSetupGroups530.Airspace) },
                { label: MapSetupGroups530.CityOther, disabled: true, action: () => this.selectGroup(MapSetupGroups530.CityOther) }
            ];
            this.menu430 = [
                { label: MapSetupGroups430.Map, disabled: false, action: () => this.selectGroup(MapSetupGroups430.Map) },
                { label: MapSetupGroups430.Weather, disabled: false, action: () => this.selectGroup(MapSetupGroups430.Weather) },
                { label: MapSetupGroups430.Traffic, disabled: false, action: () => this.selectGroup(MapSetupGroups430.Traffic) },
                { label: MapSetupGroups430.Airport, disabled: false, action: () => this.selectGroup(MapSetupGroups430.Airport) },
                { label: MapSetupGroups430.NAVAID, disabled: false, action: () => this.selectGroup(MapSetupGroups430.NAVAID) },
                { label: MapSetupGroups430.Waypoint, disabled: false, action: () => this.selectGroup(MapSetupGroups430.Waypoint) },
                { label: MapSetupGroups430.Line, disabled: true, action: () => this.selectGroup(MapSetupGroups430.Line) },
                { label: MapSetupGroups430.Control, disabled: true, action: () => this.selectGroup(MapSetupGroups430.Control) },
                { label: MapSetupGroups430.Airspace, disabled: true, action: () => this.selectGroup(MapSetupGroups430.Airspace) },
                { label: MapSetupGroups430.City, disabled: true, action: () => this.selectGroup(MapSetupGroups430.City) },
                { label: MapSetupGroups430.Road, disabled: true, action: () => this.selectGroup(MapSetupGroups430.Road) },
                { label: MapSetupGroups430.Other, disabled: true, action: () => this.selectGroup(MapSetupGroups430.Other) },
            ];
        }
        /** @inheritdoc */
        onFocused() {
            this.selectedEl.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.selectedEl.instance.classList.remove('selected');
        }
        /** @inheritdoc */
        onRightInnerInc() {
            this.openMenu();
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            this.openMenu();
            return true;
        }
        /**
         * Opens the map group menu.
         */
        openMenu() {
            if (this.props.gnsType === 'wt530') {
                ViewService.menu(this.menu530, 'MAP SETUP');
            }
            else {
                ViewService.menu(this.menu430, 'MAP SETUP');
            }
        }
        /**
         * Selects a group.
         * @param group The group that was selected.
         */
        selectGroup(group) {
            this.selected.set(group);
            this.props.onGroupSelected(group);
            ViewService.back();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-group' },
                msfsSdk.FSComponent.buildComponent("label", null, "GROUP"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-group-select' },
                    msfsSdk.FSComponent.buildComponent("div", { ref: this.selectedEl }, this.selected))));
        }
    }
    /**
     * The Map map setup group.
     */
    class MapGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.mapSettings = this.props.settingsProvider.map;
        }
        /** @inheritdoc */
        setVisible(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
                (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.forEach(c => c.setDisabled(false));
                this.setDisabled(false);
            }
            else {
                this.el.instance.classList.add('hide-element');
                (_b = this.registeredControls) === null || _b === void 0 ? void 0 : _b.forEach(c => c.setDisabled(true));
                this.setDisabled(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-labels' },
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'ORIENT-', line2: 'ATION' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'AUTO', line2: 'ZOOM' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'LAND', line2: 'DATA' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'AVIATN', line2: 'DATA' })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_orientation'), menuTitle: 'ORIENTATION', options: [['North up', msfsSdk.MapRotation.NorthUp], ['Track up', msfsSdk.MapRotation.TrackUp]] })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_autozoom'), menuTitle: 'AUTO ZOOM', options: [['Off', false], ['On', true]] })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_land_data'), menuTitle: 'LAND DATA', options: [['Off', false], ['On', true]] })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_aviation_data'), menuTitle: 'AVIATION DATA', options: [['Off', false], ['On', true]] })))));
        }
    }
    /**
     * The Map map setup group.
     */
    class TrafficGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.mapSettings = this.props.settingsProvider.map;
            this.rangeOptions = msfsSdk.ArraySubject.create([]);
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.settingsProvider.units.distanceUnitsLarge.sub(this.onUnitsChanged.bind(this), true);
        }
        /** @inheritdoc */
        setVisible(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
                (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.forEach(c => c.setDisabled(false));
                this.setDisabled(false);
            }
            else {
                this.el.instance.classList.add('hide-element');
                (_b = this.registeredControls) === null || _b === void 0 ? void 0 : _b.forEach(c => c.setDisabled(true));
                this.setDisabled(true);
            }
        }
        /**
         * Handles when the system units settings are changed.
         * @param type The type of units that the setting was changed to.
         */
        onUnitsChanged(type) {
            const ranges = type === msfsSdk.UnitType.KILOMETER ? MapSettingsRangeArrayKM : MapSettingsRangeArrayNM;
            this.rangeOptions.clear();
            this.rangeOptions.set(ranges.map((kv, i) => i === 0 ? ['Off', i] : [`${kv[1].number}${GNSNumberUnitDisplay.getUnitChar(kv[1].unit)}`, i]));
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-labels' },
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'TRAFC', line2: 'MODE' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'TRAFC', line2: 'SMBL' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'TRAFC', line2: 'LBL' })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_traffic_mode'), menuTitle: 'TRAFFIC MODE', options: [['All Trfc', MapTrafficMode.All], ['TA/Prox', MapTrafficMode.TAAndProximity], ['TA Only', MapTrafficMode.TAOnly]] })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_traffic_symbol_range'), menuTitle: 'TRAFFIC SYMBOLS', options: this.rangeOptions })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('map_traffic_label_range'), menuTitle: 'TRAFFIC LABELS', options: this.rangeOptions })))));
        }
    }
    /**
     * The Waypoint map setup group.
     */
    class WaypointGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.mapSettings = this.props.settingsProvider.map;
            this.rangeOptions = msfsSdk.ArraySubject.create([]);
            this.sizeOptions = [
                ['Off', MapSettingsWaypointSizes.Off],
                ['Sml', MapSettingsWaypointSizes.Small],
                ['Med', MapSettingsWaypointSizes.Med],
                ['Lrg', MapSettingsWaypointSizes.Large]
            ];
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.settingsProvider.units.distanceUnitsLarge.sub(this.onUnitsChanged.bind(this), true);
        }
        /**
         * Handles when the system units settings are changed.
         * @param type The type of units that the setting was changed to.
         */
        onUnitsChanged(type) {
            const ranges = type === msfsSdk.UnitType.KILOMETER ? MapSettingsRangeArrayKM : MapSettingsRangeArrayNM;
            this.rangeOptions.clear();
            this.rangeOptions.set(ranges.map((kv, i) => i === 0 ? ['Off', i] : [`${kv[1].number}${GNSNumberUnitDisplay.getUnitChar(kv[1].unit)}`, i]));
        }
        /** @inheritdoc */
        setVisible(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
                (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.forEach(c => c.setDisabled(false));
                this.setDisabled(false);
            }
            else {
                this.el.instance.classList.add('hide-element');
                (_b = this.registeredControls) === null || _b === void 0 ? void 0 : _b.forEach(c => c.setDisabled(true));
                this.setDisabled(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-header' },
                    msfsSdk.FSComponent.buildComponent("span", null, "TEXT"),
                    msfsSdk.FSComponent.buildComponent("span", null, "RNG")),
                this.props.gnsType === 'wt530' ? msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-labels' },
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'ACTIVE', line2: 'FPL' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'LARGE', line2: 'APT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'MEDIUM', line2: 'APT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'SMALL', line2: 'APT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'INT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'NDB' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'VOR' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'USER' })) :
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-labels' },
                        msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'USER', line2: 'WPT' }),
                        msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'ACTY', line2: 'FPL' })),
                this.props.gnsType === 'wt530' ?
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_fpl_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_fpl_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_large_apt_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_large_apt_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_medium_apt_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_medium_apt_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_small_apt_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_small_apt_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_int_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_int_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_ndb_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_ndb_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_vor_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_vor_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_user_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_user_range'), menuTitle: 'RANGE', options: this.rangeOptions }))) :
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_user_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_user_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_fpl_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                            msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_fpl_range'), menuTitle: 'RANGE', options: this.rangeOptions })))));
        }
    }
    /**
     * Renders map setup settings labels.
     */
    class MapSettingLabel extends msfsSdk.DisplayComponent {
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-label' },
                msfsSdk.FSComponent.buildComponent("label", null, this.props.line1),
                this.props.line2 && msfsSdk.FSComponent.buildComponent("label", { class: 'right' }, this.props.line2)));
        }
    }
    /**
     * A control that changes a map setup setting.
     */
    class MapSettingControl extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.valueText = msfsSdk.Subject.create('');
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.settingSub = this.props.setting.sub(this.onSettingChanged.bind(this), true);
            if (!Array.isArray(this.props.options)) {
                this.optionsSub = this.props.options.sub(this.onOptionsChanged.bind(this));
            }
        }
        /**
         * Handles when the setting is changed.
         * @param value The value that the setting was changed to.
         */
        onSettingChanged(value) {
            const options = Array.isArray(this.props.options) ? this.props.options : this.props.options.getArray();
            const index = options.findIndex(option => option[1] === value);
            if (options[index] !== undefined) {
                this.valueText.set(options[index][0]);
            }
            else {
                this.valueText.set('');
            }
        }
        /**
         * Handles when the list of options has changed.
         */
        onOptionsChanged() {
            if (!Array.isArray(this.props.options)) {
                const option = this.props.options.getArray().find(v => v[1] === this.props.setting.get());
                if (option !== undefined) {
                    this.valueText.set(option[0]);
                }
                else {
                    this.valueText.set('');
                }
            }
        }
        /** @inheritdoc */
        onFocused() {
            this.el.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.el.instance.classList.remove('selected');
        }
        /** @inheritdoc */
        onRightInnerInc() {
            this.openMenu();
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            this.openMenu();
            return true;
        }
        /**
         * Opens the map group menu.
         */
        openMenu() {
            const options = Array.isArray(this.props.options) ? this.props.options : this.props.options.getArray();
            const menu = ViewService.menu(options.map(option => ({
                label: option[0],
                disabled: false,
                action: () => {
                    this.props.setting.set(option[1]);
                    ViewService.back();
                }
            })), this.props.menuTitle);
            if (menu !== undefined) {
                menu.setSelectedItem(options.findIndex(v => v[1] === this.props.setting.get()));
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { ref: this.el }, this.valueText));
        }
    }
    /**
     * The Waypoint map setup group.
     */
    class AirportGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.mapSettings = this.props.settingsProvider.map;
            this.rangeOptions = msfsSdk.ArraySubject.create([]);
            this.sizeOptions = [
                ['Off', MapSettingsWaypointSizes.Off],
                ['Sml', MapSettingsWaypointSizes.Small],
                ['Med', MapSettingsWaypointSizes.Med],
                ['Lrg', MapSettingsWaypointSizes.Large]
            ];
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.settingsProvider.units.distanceUnitsLarge.sub(this.onUnitsChanged.bind(this), true);
        }
        /**
         * Handles when the system units settings are changed.
         * @param type The type of units that the setting was changed to.
         */
        onUnitsChanged(type) {
            const ranges = type === msfsSdk.UnitType.KILOMETER ? MapSettingsRangeArrayKM : MapSettingsRangeArrayNM;
            this.rangeOptions.clear();
            this.rangeOptions.set(ranges.map((kv, i) => i === 0 ? ['Off', i] : [`${kv[1].number}${GNSNumberUnitDisplay.getUnitChar(kv[1].unit)}`, i]));
        }
        /** @inheritdoc */
        setVisible(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
                (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.forEach(c => c.setDisabled(false));
                this.setDisabled(false);
            }
            else {
                this.el.instance.classList.add('hide-element');
                (_b = this.registeredControls) === null || _b === void 0 ? void 0 : _b.forEach(c => c.setDisabled(true));
                this.setDisabled(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-header' },
                    msfsSdk.FSComponent.buildComponent("span", null, "TEXT"),
                    msfsSdk.FSComponent.buildComponent("span", null, "RNG")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-labels' },
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'LARGE', line2: 'APT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'MEDIUM', line2: 'APT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'SMALL', line2: 'APT' })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_large_apt_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_large_apt_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_medium_apt_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_medium_apt_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_small_apt_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_small_apt_range'), menuTitle: 'RANGE', options: this.rangeOptions }))),
                " :",
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_user_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_user_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_fpl_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_fpl_range'), menuTitle: 'RANGE', options: this.rangeOptions })))));
        }
    }
    /**
     * The Waypoint map setup group.
     */
    class NAVAIDGroup extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.mapSettings = this.props.settingsProvider.map;
            this.rangeOptions = msfsSdk.ArraySubject.create([]);
            this.sizeOptions = [
                ['Off', MapSettingsWaypointSizes.Off],
                ['Sml', MapSettingsWaypointSizes.Small],
                ['Med', MapSettingsWaypointSizes.Med],
                ['Lrg', MapSettingsWaypointSizes.Large]
            ];
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.settingsProvider.units.distanceUnitsLarge.sub(this.onUnitsChanged.bind(this), true);
        }
        /**
         * Handles when the system units settings are changed.
         * @param type The type of units that the setting was changed to.
         */
        onUnitsChanged(type) {
            const ranges = type === msfsSdk.UnitType.KILOMETER ? MapSettingsRangeArrayKM : MapSettingsRangeArrayNM;
            this.rangeOptions.clear();
            this.rangeOptions.set(ranges.map((kv, i) => i === 0 ? ['Off', i] : [`${kv[1].number}${GNSNumberUnitDisplay.getUnitChar(kv[1].unit)}`, i]));
        }
        /** @inheritdoc */
        setVisible(isVisible) {
            var _a, _b;
            if (isVisible) {
                this.el.instance.classList.remove('hide-element');
                (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.forEach(c => c.setDisabled(false));
                this.setDisabled(false);
            }
            else {
                this.el.instance.classList.add('hide-element');
                (_b = this.registeredControls) === null || _b === void 0 ? void 0 : _b.forEach(c => c.setDisabled(true));
                this.setDisabled(true);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-header' },
                    msfsSdk.FSComponent.buildComponent("span", null, "TEXT"),
                    msfsSdk.FSComponent.buildComponent("span", null, "RNG")),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-labels' },
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'INT' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'NDB' }),
                    msfsSdk.FSComponent.buildComponent(MapSettingLabel, { line1: 'VOR' })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'map-setup-settings-controls' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_int_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_int_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_ndb_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_ndb_range'), menuTitle: 'RANGE', options: this.rangeOptions })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'map-setting-control dual' },
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_vor_size'), menuTitle: 'TEXT', options: this.sizeOptions }),
                        msfsSdk.FSComponent.buildComponent(MapSettingControl, { setting: this.mapSettings.getSetting('wpt_vor_range'), menuTitle: 'RANGE', options: this.rangeOptions })))));
        }
    }

    /**
     * A control that contains the data field setup menu for the standard nav map
     */
    class StandardNavMapFields extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.gpsValidity = msfsSdk.Subject.create(msfsGarminsdk.NavDataFieldGpsValidity.Invalid);
            this.settingsProvider = new GNSSettingsProvider(this.props.bus);
            this.fieldContext = {
                modelFactory: new msfsGarminsdk.DefaultNavDataBarFieldModelFactory(this.props.bus, this.props.fms, this.gpsValidity),
                renderer: new GNSDataFieldRenderer(this.settingsProvider.units, this.settingsProvider.time),
                fieldTypeMenuEntries: [
                    { label: 'BRG - Bearing', disabled: false, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'DIS - Distance', disabled: false, type: msfsGarminsdk.NavDataFieldType.DistanceToWaypoint },
                    { label: 'DTK - Desired Track', disabled: false, type: msfsGarminsdk.NavDataFieldType.DesiredTrack },
                    { label: 'ESA - Enrte Safe Alt', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'ETA - Est Time Arvl', disabled: false, type: msfsGarminsdk.NavDataFieldType.TimeOfWaypointArrival },
                    { label: 'ETE - Est Time Enrte', disabled: false, type: msfsGarminsdk.NavDataFieldType.TimeToWaypoint },
                    { label: 'FLOW - Total Fuel Flow', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'GS - Ground Speed', disabled: false, type: msfsGarminsdk.NavDataFieldType.GroundSpeed },
                    { label: 'MSA - Min Safe Alt', disabled: true, type: msfsGarminsdk.NavDataFieldType.BearingToWaypoint },
                    { label: 'TKE - Track Ang Err', disabled: false, type: msfsGarminsdk.NavDataFieldType.TrackAngleError },
                    { label: 'TRK - Track', disabled: false, type: msfsGarminsdk.NavDataFieldType.GroundTrack },
                    { label: 'VSR - Vert Spd Reqd', disabled: false, type: msfsGarminsdk.NavDataFieldType.VerticalSpeedRequired },
                    { label: 'WPT - Active Wpt', disabled: false, type: msfsGarminsdk.NavDataFieldType.Waypoint },
                    { label: 'XTK - Cross Track Err', disabled: false, type: msfsGarminsdk.NavDataFieldType.CrossTrack },
                ],
            };
            this.fields = [
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef(),
                msfsSdk.FSComponent.createRef()
            ];
            this.clockSub = this.props.bus.getSubscriber().on('realTime')
                .atFrequency(4).handle(() => {
                var _a;
                for (let i = 0; i < this.fields.length; i++) {
                    (_a = this.fields[i].getOrDefault()) === null || _a === void 0 ? void 0 : _a.update();
                }
            });
        }
        /** @inheritdoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.props.bus.getSubscriber().on('gps_system_state_changed_1').handle(state => {
                const valid = state === msfsSdk.GPSSystemState.SolutionAcquired || state === msfsSdk.GPSSystemState.DiffSolutionAcquired;
                this.gpsValidity.set(valid ? msfsGarminsdk.NavDataFieldGpsValidity.Valid : msfsGarminsdk.NavDataFieldGpsValidity.Invalid);
            });
        }
        /**
         * Sets whether the map setup pane is open.
         * @param isOpen True if open, false otherwise.
         */
        setOpen(isOpen) {
            if (isOpen) {
                this.el.instance.classList.remove('hide-element');
            }
            else {
                this.el.instance.classList.add('hide-element');
                this.blur();
            }
        }
        /**
         * Focuses the data field pane itself
         */
        focusSelf() {
            this.focus(msfsSdk.FocusPosition.First);
        }
        /** @inheritdoc */
        onRightKnobPush() {
            this.blur();
            return true;
        }
        /** @inheritDoc */
        render() {
            const fieldSettings = this.settingsProvider.standardNavMapFields;
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, class: "std-map-data-fields hide-element" },
                msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('stdmap_field_1_type'), bus: this.props.bus, ref: this.fields[0] }),
                msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('stdmap_field_2_type'), bus: this.props.bus, ref: this.fields[1] }),
                msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('stdmap_field_3_type'), bus: this.props.bus, ref: this.fields[2] }),
                msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('stdmap_field_4_type'), bus: this.props.bus, ref: this.fields[3] }),
                this.props.gnsType === 'wt530' &&
                    msfsSdk.FSComponent.buildComponent(MapPageDataField, { context: this.fieldContext, type: fieldSettings.getSetting('stdmap_field_5_type'), bus: this.props.bus, ref: this.fields[4] })));
        }
    }

    /**
     * A component that displays the GNS arc/nav main map.
     */
    class StandardNavMap extends Page {
        constructor() {
            super(...arguments);
            this.mapSetup = msfsSdk.FSComponent.createRef();
            this.dataFields = msfsSdk.FSComponent.createRef();
            this.leftPane = msfsSdk.FSComponent.createRef();
            this.mapSize = msfsSdk.Vec2Subject.create(this.props.gnsType === 'wt430' ? msfsSdk.Vec2Math.create(272, 174) : msfsSdk.Vec2Math.create(255, 217));
            this.dataFieldsOn = msfsSdk.Subject.create(false);
            this.pageMenu = new StandardNavMapMenu(this.dataFieldsOn, this.props.settingsProvider);
            this.StandardMap = GNSMapBuilder
                .withStandardMap(this.props.bus, this.props.flightPlanner, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex, true, this.props.trafficSystem, this.props.tcasDataProvider)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.flightPlanner))
                .withProjectedSize(this.mapSize)
                .build('standard-map-container');
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.StandardMap.ref.instance.sleep();
            // Setup page events
            this.pageMenu.setupPressed.on(() => this.openSetup());
            this.pageMenu.dataFieldsOnOffPressed.on(() => this.toggleDataFields());
            this.pageMenu.changeFieldsPressed.on(() => this.startEditingDataFields());
            // Show/hide data fields with state
            this.dataFieldsOn.sub((on) => {
                if (on) {
                    this.showDataFields();
                }
                else {
                    this.hideDataFields();
                }
            }, true);
            this.props.settingsProvider.map.getSetting('map_std_nexrad_enabled').sub(v => {
                this.StandardMap.context.getController(GNSMapKeys.Controller).setNexradVisible(v);
            }, true);
            this.props.settingsProvider.map.getSetting('map_std_declutter_level').sub(v => {
                var _a;
                (_a = this.StandardMap.context.model.getModule(GNSMapKeys.Declutter)) === null || _a === void 0 ? void 0 : _a.declutterLevel.set(v);
            }, true);
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            switch (evt) {
                case InteractionEvent.RangeIncrease:
                    this.StandardMap.context.getController(GNSMapKeys.Controller).increaseRange();
                    return true;
                case InteractionEvent.RangeDecrease:
                    this.StandardMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                    return true;
                case InteractionEvent.MENU:
                    ViewService.menu(this.pageMenu);
                    return true;
                case InteractionEvent.CLR:
                    if (this.mapSetup.instance.isFocused) {
                        this.closeSetup();
                    }
                    else {
                        this.StandardMap.context.getController(GNSMapKeys.Controller).changeDeclutter(this.props.settingsProvider.map.getSetting('map_std_declutter_level'));
                    }
                    return true;
            }
            let handled = false;
            if (this.mapSetup.instance.isFocused) {
                handled = this.mapSetup.instance.onInteractionEvent(evt);
            }
            else if (this.dataFields.instance.isFocused) {
                handled = this.dataFields.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /**
         * Opens the map setup menu.
         */
        openSetup() {
            this.hideDataFields();
            this.mapSetup.instance.setOpen(true);
            if (this.props.gnsType === 'wt430') {
                this.mapSize.set(133, 174);
            }
            else {
                this.mapSize.set(116, 217);
            }
            this.leftPane.instance.classList.add('with-setup');
        }
        /**
         * Closes the map setup menu.
         */
        closeSetup() {
            this.mapSetup.instance.setOpen(false);
            if (this.props.gnsType === 'wt430') {
                this.mapSize.set(272, 174);
            }
            else {
                this.mapSize.set(255, 217);
            }
            this.leftPane.instance.classList.remove('with-setup');
            if (this.dataFieldsOn.get()) {
                this.showDataFields();
            }
        }
        /**
         * Shows the data fields.
         */
        showDataFields() {
            this.dataFields.instance.setOpen(true);
            if (this.props.gnsType === 'wt430') {
                this.mapSize.set(203, 174);
            }
            else {
                this.mapSize.set(186, 217);
            }
            this.leftPane.instance.classList.add('with-fields');
        }
        /**
         * Hides the data fields.
         */
        hideDataFields() {
            this.dataFields.instance.setOpen(false);
            if (this.props.gnsType === 'wt430') {
                this.mapSize.set(272, 174);
            }
            else {
                this.mapSize.set(255, 217);
            }
            this.leftPane.instance.classList.remove('with-fields');
        }
        /**
         * Toggles data fields being on or off
         */
        toggleDataFields() {
            const currently = this.dataFieldsOn.get();
            this.dataFieldsOn.set(!currently);
        }
        /**
         * Sets data fields shown and focuses the data fields pane
         */
        startEditingDataFields() {
            this.dataFieldsOn.set(true);
            this.dataFields.instance.focusSelf();
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.StandardMap.ref.instance.sleep();
            this.dataFields.instance.clockSub.pause();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.StandardMap.ref.instance.wake();
            this.dataFields.instance.clockSub.resume();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page page-no-padding std-map hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("div", { class: 'std-map-left', ref: this.leftPane }, this.StandardMap.map),
                msfsSdk.FSComponent.buildComponent(MapSetup, { ref: this.mapSetup, settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, isolateScroll: true }),
                msfsSdk.FSComponent.buildComponent(StandardNavMapFields, { ref: this.dataFields, bus: this.props.bus, fms: this.props.fms, gnsType: this.props.gnsType, isolateScroll: true })));
        }
    }
    /**
     * A page menu for the standard nav map page.
     */
    class StandardNavMapMenu extends MenuDefinition {
        /** @inheritDoc */
        constructor(dataFieldsOn, settingsProvider) {
            super();
            this.dataFieldsOn = dataFieldsOn;
            this.settingsProvider = settingsProvider;
            this.setupPressed = new msfsSdk.SubEvent();
            this.dataFieldsOnOffPressed = new msfsSdk.SubEvent();
            this.changeFieldsPressed = new msfsSdk.SubEvent();
            this.dataFieldsOnLabel = msfsSdk.Subject.create('');
            /** @inheritDoc */
            this.entries = [
                { label: 'Setup Map?', disabled: false, action: this.handleSetupMap.bind(this) },
                { label: 'Measure Dist?', disabled: true, action: () => { } },
                { label: this.dataFieldsOnLabel, disabled: false, action: this.handleDataFieldsOnOff.bind(this) },
                { label: 'Display NEXRAD?', disabled: false, action: this.toggleNexrad.bind(this) },
                { label: 'Change Fields?', disabled: false, action: this.handleChangeFields.bind(this) },
                { label: 'Restore Defaults?', disabled: false, action: this.restoreDefaults.bind(this) }
            ];
            this.dataFieldsOn.sub((on) => this.dataFieldsOnLabel.set(`Data Fields ${on ? 'Off' : 'On'}?`), true);
            const nexradSetting = this.settingsProvider.map.getSetting('map_std_nexrad_enabled');
            nexradSetting.sub(v => this.setEntryLabel(3, v ? 'Hide NEXRAD?' : 'Display NEXRAD?'), true);
        }
        /**
         * Handles 'Setup Map?' being pressed
         */
        handleSetupMap() {
            this.setupPressed.notify(this);
            ViewService.back();
        }
        /**
         * Handles 'Data Fields On/Off?' being pressed
         */
        handleDataFieldsOnOff() {
            this.dataFieldsOnOffPressed.notify(this);
            ViewService.back();
        }
        /**
         * Handles 'Change Fields?' being pressed
         */
        handleChangeFields() {
            this.changeFieldsPressed.notify(this);
            ViewService.back();
        }
        /**
         * Resets all the data fields to defaults.
         */
        restoreDefaults() {
            this.settingsProvider.standardNavMapFields.getAllSettings().forEach(v => v.resetToDefault());
            ViewService.back();
        }
        /**
         * Toggles NEXRAD for the arc nav map.
         */
        toggleNexrad() {
            const nexradSetting = this.settingsProvider.map.getSetting('map_std_nexrad_enabled');
            nexradSetting.set(!nexradSetting.get());
            ViewService.back();
        }
    }

    /**
     * A page that display a terrain map.
     */
    class TerrainMap extends Page {
        constructor() {
            super(...arguments);
            this.mapSize = msfsSdk.Vec2Subject.create(this.props.gnsType === 'wt430' ? msfsSdk.Vec2Math.create(272, 174) : msfsSdk.Vec2Math.create(255, 217));
            this.gsl = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.METER.createNumber(NaN));
            this.gslFormatter = msfsSdk.NumberFormatter.create({ precision: 60 });
            this.pageMenu = new TerrainMapMenu(this.props.settingsProvider);
            this.compassEl = msfsSdk.FSComponent.createRef();
            this.StandardMap = GNSMapBuilder
                .withStandardMap(this.props.bus, this.props.flightPlanner, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex, true)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.flightPlanner, true))
                .withProjectedSize(this.mapSize)
                .build('terrain-map-container');
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.gsl.set(pos.alt));
            this.props.settingsProvider.map.getSetting('map_terr_arc_view_enabled').sub(this.onArcViewEnabledChanged.bind(this), true);
            this.props.settingsProvider.map.getSetting('map_terr_aviation_data').sub(this.onAviationDataChanged.bind(this), true);
            this.StandardMap.ref.instance.sleep();
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.StandardMap.ref.instance.sleep();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.StandardMap.ref.instance.wake();
            this.StandardMap.context.getController(GNSMapKeys.Controller).setTerrainEnabled(true);
        }
        /**
         * Handles when the 120 degree arc view setting has changed.
         * @param enabled Whether the arc view is enabled.
         */
        onArcViewEnabledChanged(enabled) {
            const context = this.compassEl.instance.getContext('2d');
            const centerVec = new Float64Array([this.compassEl.instance.width / 2, this.compassEl.instance.height / 2]);
            const arcOffset = this.props.gnsType === 'wt430' ? 60 : 84;
            if (context !== null) {
                if (enabled) {
                    this.StandardMap.context.projection.set({ targetProjectedOffset: msfsSdk.Vec2Math.create(0, arcOffset) });
                    centerVec[1] += (arcOffset - 4);
                    context.clearRect(0, 0, this.compassEl.instance.width, this.compassEl.instance.height);
                    context.beginPath();
                    const startAngle = (-60 - 90) * Avionics.Utils.DEG2RAD;
                    const endAngle = (60 - 90) * Avionics.Utils.DEG2RAD;
                    context.lineWidth = 1;
                    context.strokeStyle = 'cyan';
                    const arcRadius = this.props.gnsType === 'wt430' ? 110 : 160;
                    context.arc(centerVec[0], centerVec[1], arcRadius, startAngle, endAngle);
                    context.moveTo(centerVec[0], centerVec[1]);
                    const tempVec = new Float64Array(2);
                    msfsSdk.Vec2Math.setFromPolar(arcRadius, startAngle, tempVec);
                    msfsSdk.Vec2Math.add(centerVec, tempVec, tempVec);
                    context.lineTo(tempVec[0], tempVec[1]);
                    context.moveTo(centerVec[0], centerVec[1]);
                    msfsSdk.Vec2Math.setFromPolar(arcRadius, endAngle, tempVec);
                    msfsSdk.Vec2Math.add(centerVec, tempVec, tempVec);
                    context.lineTo(tempVec[0], tempVec[1]);
                    context.stroke();
                }
                else {
                    this.StandardMap.context.projection.set({ targetProjectedOffset: msfsSdk.Vec2Math.create(0, 0) });
                    context.clearRect(0, 0, this.compassEl.instance.width, this.compassEl.instance.height);
                    context.beginPath();
                    context.setLineDash([1, 3]);
                    context.lineWidth = 1;
                    context.strokeStyle = 'cyan';
                    context.arc(centerVec[0], centerVec[1], centerVec[1], 0, Math.PI * 2);
                    context.stroke();
                    context.beginPath();
                    context.setLineDash([]);
                    context.fillStyle = 'cyan';
                    const tempVec = new Float64Array(2);
                    for (let i = 0; i < 360; i += 30) {
                        msfsSdk.Vec2Math.setFromPolar(this.compassEl.instance.height / 2, Avionics.Utils.DEG2RAD * i, tempVec);
                        msfsSdk.Vec2Math.add(centerVec, tempVec, tempVec);
                        context.fillRect(tempVec[0] - 2, tempVec[1] - 2, 4, 4);
                    }
                }
            }
        }
        /**
         * Handles when the setting for showing aviation data changes.
         * @param enabled Whether or not showing aviation data is enabled.
         */
        onAviationDataChanged(enabled) {
            const mapContext = this.StandardMap.context;
            if (enabled) {
                mapContext.getLayer(msfsSdk.MapSystemKeys.Airspace).setVisible(true);
                mapContext.getLayer(msfsSdk.MapSystemKeys.NearestWaypoints).setVisible(true);
                mapContext.getLayer(GNSMapKeys.Runways).setVisible(true);
                mapContext.getLayer(`${msfsSdk.MapSystemKeys.FlightPlan}0`).setVisible(true);
                mapContext.getLayer(msfsSdk.MapSystemKeys.TextLayer).setVisible(true);
            }
            else {
                mapContext.getLayer(msfsSdk.MapSystemKeys.Airspace).setVisible(false);
                mapContext.getLayer(msfsSdk.MapSystemKeys.NearestWaypoints).setVisible(false);
                mapContext.getLayer(GNSMapKeys.Runways).setVisible(false);
                mapContext.getLayer(`${msfsSdk.MapSystemKeys.FlightPlan}0`).setVisible(false);
                mapContext.getLayer(msfsSdk.MapSystemKeys.TextLayer).setVisible(false);
            }
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            switch (evt) {
                case InteractionEvent.RangeIncrease:
                    this.StandardMap.context.getController(GNSMapKeys.Controller).increaseRange();
                    return true;
                case InteractionEvent.RangeDecrease:
                    this.StandardMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                    return true;
                case InteractionEvent.MENU:
                    ViewService.menu(this.pageMenu);
                    return true;
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page page-no-padding terrain-map-page hide-element', ref: this.el },
                this.StandardMap.map,
                msfsSdk.FSComponent.buildComponent("canvas", { class: 'terrain-map-compass', ref: this.compassEl, width: this.props.gnsType === 'wt430' ? '272px' : '255px', height: this.props.gnsType === 'wt430' ? '174px' : '215px' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'terrain-map-name' }, "TERRAIN"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'terrain-map-trk' }, "TRK"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'terrain-map-gsl' },
                    msfsSdk.FSComponent.buildComponent("label", null, "GSL"),
                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: this.gslFormatter, value: this.gsl, displayUnit: this.props.settingsProvider.units.altitudeUnits }))));
        }
    }
    /**
     * A page menu for the standard nav map page.
     */
    class TerrainMapMenu extends MenuDefinition {
        /** @inheritDoc */
        constructor(settingsProvider) {
            super();
            this.settingsProvider = settingsProvider;
            /** @inheritDoc */
            this.entries = [
                { label: 'Inhibit Terrain?', disabled: true, action: () => { } },
                { label: 'View 120°?', disabled: false, action: this.toggleArcView.bind(this) },
                { label: 'Hide Aviation Data?', disabled: false, action: this.toggleAviationData.bind(this) },
            ];
            this.settingsProvider.map.getSetting('map_terr_arc_view_enabled').sub(v => {
                this.setEntryLabel(1, v ? 'View 360°?' : 'View 120°?');
            }, true);
            this.settingsProvider.map.getSetting('map_terr_aviation_data').sub(v => {
                this.setEntryLabel(2, v ? 'Hide Aviation Data?' : 'Show Aviation Data?');
            }, true);
        }
        /**
         * Toggles between arc 120 deg view and 360 deg view.
         */
        toggleArcView() {
            const arcSetting = this.settingsProvider.map.getSetting('map_terr_arc_view_enabled');
            arcSetting.set(!arcSetting.get());
            ViewService.back();
        }
        /**
         * Toggles map aviation data on and off.
         */
        toggleAviationData() {
            const arcSetting = this.settingsProvider.map.getSetting('map_terr_aviation_data');
            arcSetting.set(!arcSetting.get());
            ViewService.back();
        }
    }

    /**
     * A page that displays the traffic map.
     */
    class TrafficMap extends Page {
        constructor() {
            super(...arguments);
            this.trafficDisplay = msfsSdk.FSComponent.createRef();
            this.rootControl = msfsSdk.FSComponent.createRef();
            this.standbyEl = msfsSdk.FSComponent.createRef();
            this.adsbEl = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.onTrafficSettingChanged('NRM');
            this.props.bus.getSubscriber().on('gns_adsb_oper').whenChanged().handle(this.handleAdsbModeChanged.bind(this));
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RangeIncrease) {
                this.trafficDisplay.instance.changeRange('inc');
                return true;
            }
            if (evt === InteractionEvent.RangeDecrease) {
                this.trafficDisplay.instance.changeRange('dec');
                return true;
            }
            if (evt === InteractionEvent.RightKnobPush) {
                if (this.rootControl.instance.isFocused) {
                    this.rootControl.instance.blur();
                }
                else {
                    this.rootControl.instance.focus(msfsSdk.FocusPosition.Last);
                }
                return true;
            }
            let handled = false;
            if (this.rootControl.instance.isFocused) {
                if (evt === InteractionEvent.CLR) {
                    this.rootControl.instance.blur();
                    return true;
                }
                handled = this.rootControl.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.trafficDisplay.instance.sleep();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.trafficDisplay.instance.wake();
        }
        /**
         * Handles when the traffic altitude restriction setting changes.
         * @param value The new value.
         */
        onTrafficSettingChanged(value) {
            switch (value) {
                case 'NRM':
                    this.trafficDisplay.instance.setAltitudeRestrictionMode(msfsGarminsdk.MapTrafficAltitudeRestrictionMode.Normal);
                    break;
                case 'ABV':
                    this.trafficDisplay.instance.setAltitudeRestrictionMode(msfsGarminsdk.MapTrafficAltitudeRestrictionMode.Above);
                    break;
                case 'BLW':
                    this.trafficDisplay.instance.setAltitudeRestrictionMode(msfsGarminsdk.MapTrafficAltitudeRestrictionMode.Below);
                    break;
                case 'UNR':
                    this.trafficDisplay.instance.setAltitudeRestrictionMode(msfsGarminsdk.MapTrafficAltitudeRestrictionMode.Unrestricted);
                    break;
            }
        }
        /**
         * Handles when the ADS-B mode control is toggled.
         * @param value The value that it was toggled to.
         */
        onAdsbModeToggled(value) {
            if (value === 'ADS ON') {
                SimVar.SetSimVarValue(GNSAdsbSimVars.WTGNS_ADSB_OPER, msfsSdk.SimVarValueType.Bool, true);
            }
            else {
                SimVar.SetSimVarValue(GNSAdsbSimVars.WTGNS_ADSB_OPER, msfsSdk.SimVarValueType.Bool, false);
            }
        }
        /**
         * Handles when the ADS-B mode is changed.
         * @param oper The new mode setting.
         */
        handleAdsbModeChanged(oper) {
            var _a, _b;
            if (oper) {
                (_a = this.props.trafficSystem.adsb) === null || _a === void 0 ? void 0 : _a.setOperatingMode(msfsSdk.AdsbOperatingMode.Airborne);
                this.props.trafficSystem.setOperatingMode(msfsSdk.TcasOperatingMode.TAOnly);
                this.standbyEl.instance.classList.add('hide-element');
                this.adsbEl.instance.set(1);
            }
            else {
                (_b = this.props.trafficSystem.adsb) === null || _b === void 0 ? void 0 : _b.setOperatingMode(msfsSdk.AdsbOperatingMode.Standby);
                this.props.trafficSystem.setOperatingMode(msfsSdk.TcasOperatingMode.Standby);
                this.standbyEl.instance.classList.remove('hide-element');
                this.adsbEl.instance.set(0);
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page tfc-map hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent(TrafficDisplay, { bus: this.props.bus, gnsType: this.props.gnsType, trafficSystem: this.props.trafficSystem, ref: this.trafficDisplay, size: msfsSdk.Vec2Subject.create(this.props.gnsType === 'wt430' ? msfsSdk.Vec2Math.create(272, 174) : msfsSdk.Vec2Math.create(255, 217)) }),
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.rootControl, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(TrafficMapToggle, { class: 'tfc-map-toggle-traffic', label: 'TRAFFIC', options: ['NRM', 'ABV', 'BLW', 'UNR'], onOptionSelected: this.onTrafficSettingChanged.bind(this) }),
                    msfsSdk.FSComponent.buildComponent(TrafficMapToggle, { class: 'tfc-map-toggle-mode', options: ['ADS OFF', 'ADS ON'], requireConfirmation: true, onOptionSelected: this.onAdsbModeToggled.bind(this), ref: this.adsbEl })),
                msfsSdk.FSComponent.buildComponent("div", { class: 'tfc-map-standby', ref: this.standbyEl }, "STANDBY")));
        }
    }
    /**
     * A control that selects between traffic map options.
     */
    class TrafficMapToggle extends GNSUiControl {
        constructor() {
            var _a;
            super(...arguments);
            this.selectionEl = msfsSdk.FSComponent.createRef();
            this.selection = msfsSdk.Subject.create((_a = this.props.options[0]) !== null && _a !== void 0 ? _a : '');
            this.currentSelectedIndex = 0;
            this.currentConfirmedIndex = 0;
        }
        /** @inheritdoc */
        onEnt() {
            this.currentConfirmedIndex = this.currentSelectedIndex;
            const selection = this.props.options[this.currentSelectedIndex];
            this.props.onOptionSelected(selection);
            this.selection.set(selection);
            return true;
        }
        /** @inheritdoc */
        onRightInnerInc() {
            this.changeSelection(1);
            return true;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            this.changeSelection(-1);
            return true;
        }
        /**
         * Sets the selection.
         * @param index The index to se.
         */
        set(index) {
            index = msfsSdk.NavMath.clamp(index, 0, this.props.options.length - 1);
            this.currentSelectedIndex = index;
            this.currentConfirmedIndex = index;
            this.selection.set(this.props.options[index]);
        }
        /** @inheritdoc */
        onFocused() {
            this.selectionEl.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.selectionEl.instance.classList.remove('selected');
        }
        /**
         * Changes the toggle selection.
         * @param offset The amount to change the selection index by.
         */
        changeSelection(offset) {
            this.currentSelectedIndex = Math.max(0, Math.min(this.currentSelectedIndex + offset, this.props.options.length - 1));
            let selection = this.props.options[this.currentSelectedIndex];
            if (this.props.requireConfirmation && this.currentConfirmedIndex !== this.currentSelectedIndex) {
                selection += '?';
            }
            this.selection.set(selection);
            if (!this.props.requireConfirmation) {
                this.currentConfirmedIndex = this.currentSelectedIndex;
                this.props.onOptionSelected(selection);
            }
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `tfc-map-toggle ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                this.props.label && msfsSdk.FSComponent.buildComponent("label", null, this.props.label),
                msfsSdk.FSComponent.buildComponent("div", { class: 'tfc-map-toggle-selection', ref: this.selectionEl }, this.selection)));
        }
    }

    /**
     * Base page for a simple NEAREST <FACILITY> page
     */
    class NearestFacilityPage extends Page {
        constructor() {
            super(...arguments);
            this.facilities = msfsSdk.ArraySubject.create([]);
            this.list = msfsSdk.FSComponent.createRef();
            this.ppos = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
        }
        /** @inheritDoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RightKnobPush) {
                if (this.list.instance.isFocused) {
                    this.list.instance.blur();
                }
                else {
                    this.list.instance.focus(msfsSdk.FocusPosition.First);
                }
            }
            if (this.list.instance.isFocused) {
                return this.list.instance.onInteractionEvent(evt);
            }
            return false;
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber().on('gps-position').handle(({ lat, long }) => {
                this.ppos.set(lat, long);
            });
        }
    }

    /**
     * NEAREST AIRPORT page
     */
    class NearestAirport extends NearestFacilityPage {
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            msfsSdk.NearestContext.onInitialized((instance) => {
                instance.airports.sub((index, type, item) => {
                    switch (type) {
                        case msfsSdk.SubscribableArrayEventType.Added:
                            this.facilities.insert(item, index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Removed:
                            this.facilities.removeAt(index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Cleared:
                            this.facilities.clear();
                            break;
                    }
                });
            });
        }
        /**
         * Handles an airport being selected
         *
         * @param icao the airport FS ICAO
         *
         * @returns true
         */
        handleAirportSelected(icao) {
            this.props.bus.getPublisher().pub('gns_nearest_pages_select_wpt_apt', icao);
            this.props.onAirportSelected();
            return true;
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if ((evt === InteractionEvent.RightInnerInc || evt === InteractionEvent.RightInnerDec) && this.list.instance.isFocused) {
                return true;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /**
         * Sets the standby com radio frequency.
         * @param facilityFrequency The facility frequency to set to the standby radio frequency.
         */
        handleSetStandbyFrequency(facilityFrequency) {
            if (facilityFrequency.freqMHz < 118) {
                SimVar.SetSimVarValue(`K:${this.props.navIndex === 1 ? 'NAV1' : 'NAV2'}_STBY_SET`, 'number', facilityFrequency.freqBCD16);
            }
            else {
                SimVar.SetSimVarValue(`K:${this.props.comIndex === 1 ? 'COM' : 'COM2'}_STBY_RADIO_SET`, 'number', facilityFrequency.freqBCD16);
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, class: "aux-page hide-element" },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "NEAREST AIRPORT"),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels-nearest-airport" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "APT")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "BRG")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DIS")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "APR"))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table nearest-airport-table" },
                    msfsSdk.FSComponent.buildComponent(GNSUiControlList, { ref: this.list, orderBy: (a, b) => {
                            const aPos = new msfsSdk.GeoPoint(a.lat, a.lon);
                            const aDistanceGARadians = this.ppos.get().distance(aPos);
                            const aDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(aDistanceGARadians, msfsSdk.UnitType.NMILE);
                            const bPos = new msfsSdk.GeoPoint(b.lat, b.lon);
                            const bDistanceGARadians = this.ppos.get().distance(bPos);
                            const bDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(bDistanceGARadians, msfsSdk.UnitType.NMILE);
                            return aDistanceNM - bDistanceNM;
                        }, data: this.facilities, renderItem: (data) => (msfsSdk.FSComponent.buildComponent(NearestAirportItem, { facility: data, ppos: this.ppos, onSelected: () => this.handleAirportSelected(data.icao), onFrequencySelected: (freq) => this.handleSetStandbyFrequency(freq) })), isolateScroll: true }))));
        }
    }
    /**
     * Item for the NEAREST AIRPORT page
     */
    class NearestAirportItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.icon = msfsSdk.FSComponent.createRef();
            this.runway = msfsSdk.Subject.create(null);
            this.airportLla = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.mainFrequency = msfsSdk.Subject.create(null);
            this.bearing = msfsSdk.CombinedSubject.create(this.props.ppos, this.airportLla).map(([ppos, airportLla]) => {
                const magBearing = msfsSdk.MagVar.trueToMagnetic(ppos.bearingTo(airportLla), ppos);
                return magBearing.toFixed(0).padStart(3, '0');
            });
            this.distance = msfsSdk.CombinedSubject.create(this.props.ppos, this.airportLla).map(([ppos, airportLla]) => {
                const distanceGARadians = airportLla.distance(ppos);
                const distanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(distanceGARadians, msfsSdk.UnitType.NMILE);
                return distanceNM.toFixed(1);
            });
            this.mainFrequencyType = this.mainFrequency.map((it) => {
                if (it) {
                    return GnsFmsUtils.towerOrCtafFrequencyShortName.get(it.type);
                }
                else {
                    return '___';
                }
            });
            this.mainFrequencyString = this.mainFrequency.map((it) => {
                if (it) {
                    return it.freqMHz.toFixed(3);
                }
                else {
                    return '___.___';
                }
            });
            this.runwayLength = this.runway.map((it) => {
                if (!it) {
                    return '';
                }
                const lengthFeet = msfsSdk.UnitType.METER.convertTo(it.length, msfsSdk.UnitType.FOOT);
                return lengthFeet.toFixed(0);
            });
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.airportLla.set(this.props.facility.lat, this.props.facility.lon);
            this.runway.set(this.findBestRunway());
            this.mainFrequency.set(this.findMainFrequency());
            this.icon.instance.src = Icons.getByFacility(this.props.facility).src;
        }
        /**
         * Finds the longest one way runway in an airport facility
         *
         * @returns the one way runway
         */
        findBestRunway() {
            var _a, _b;
            let longest = null;
            for (let i = 0; i < this.props.facility.runways.length; i++) {
                const runway = this.props.facility.runways[i];
                const onrWayRunways = msfsSdk.RunwayUtils.getOneWayRunways(runway, i);
                if (onrWayRunways[0].length > ((_a = longest === null || longest === void 0 ? void 0 : longest.length) !== null && _a !== void 0 ? _a : -1)) {
                    longest = onrWayRunways[0];
                }
                if (onrWayRunways[1].length > ((_b = longest === null || longest === void 0 ? void 0 : longest.length) !== null && _b !== void 0 ? _b : -1)) {
                    longest = onrWayRunways[1];
                }
            }
            return longest;
        }
        /**
         * Finds the main airport facility frequency to display
         *
         * @returns a facility frequency
         */
        findMainFrequency() {
            const types = GnsFmsUtils.towerOrCtafFrequencyTypes;
            return (this.props.facility.frequencies
                .filter((it) => types.includes(it.type))
                .sort((a, b) => types.indexOf(a.type) - types.indexOf(b.type)))[0];
        }
        /**
         * Handles the Tower/CTAF frequency being pressed ENTon
         *
         * @returns if the event was handled
         */
        handleFrequencyEnt() {
            const freq = this.mainFrequency.get();
            if (freq) {
                this.props.onFrequencySelected(freq);
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        onDirectTo() {
            if (this.props.facility !== undefined) {
                ViewService.directToDialogWithIcao(this.props.facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: "aux-entry nearest-airport-item" },
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-info-container" },
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "nearest-airport-icao", data: msfsSdk.Subject.create((msfsSdk.ICAO.getIdent(this.props.facility.icao))), onEnt: () => {
                            this.props.onSelected();
                            return true;
                        } }),
                    msfsSdk.FSComponent.buildComponent("div", { class: "nearest-airport-icon" },
                        msfsSdk.FSComponent.buildComponent("img", { ref: this.icon }))),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-brg" },
                    this.bearing,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-dis" },
                    this.distance,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.NMILE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-apr" }, GnsFmsUtils.getBestApproachTypeString(this.props.facility)),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-frequency-container" },
                    msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-freqtype" }, this.mainFrequencyType),
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "nearest-airport-frequency", data: this.mainFrequencyString, onEnt: this.handleFrequencyEnt.bind(this) })),
                msfsSdk.FSComponent.buildComponent("span", { className: "nearest-airport-runway-length-label" }, "rwy"),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-airport-runway-length" },
                    this.runwayLength,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.FOOT) }))));
        }
    }

    /**
     * NEAREST INTERSECTION page
     */
    class NearestIntersection extends NearestFacilityPage {
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            msfsSdk.NearestContext.onInitialized((instance) => {
                instance.intersections.sub((index, type, item) => {
                    switch (type) {
                        case msfsSdk.SubscribableArrayEventType.Added:
                            this.facilities.insert(item, index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Removed:
                            this.facilities.removeAt(index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Cleared:
                            this.facilities.clear();
                            break;
                    }
                });
            });
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if ((evt === InteractionEvent.RightInnerInc || evt === InteractionEvent.RightInnerDec) && this.list.instance.isFocused) {
                return true;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /**
         * Handles an intersection being selected
         *
         * @param icao the intersection FS ICAO
         *
         * @returns true
         */
        handleIntersectionSelected(icao) {
            this.props.bus.getPublisher().pub('gns_nearest_pages_select_wpt_int', icao);
            this.props.onIntersectionSelected();
            return true;
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, class: "aux-page hide-element" },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "NEAREST INTERSECTION"),
                msfsSdk.FSComponent.buildComponent("div", { class: "nearest-intersection-labels" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "INT")),
                    msfsSdk.FSComponent.buildComponent("div", null),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "BRG")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DIS"))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table nearest-intersection-table" },
                    msfsSdk.FSComponent.buildComponent(GNSUiControlList, { ref: this.list, orderBy: (a, b) => {
                            const aPos = new msfsSdk.GeoPoint(a.lat, a.lon);
                            const aDistanceGARadians = this.ppos.get().distance(aPos);
                            const aDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(aDistanceGARadians, msfsSdk.UnitType.NMILE);
                            const bPos = new msfsSdk.GeoPoint(b.lat, b.lon);
                            const bDistanceGARadians = this.ppos.get().distance(bPos);
                            const bDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(bDistanceGARadians, msfsSdk.UnitType.NMILE);
                            return aDistanceNM - bDistanceNM;
                        }, data: this.facilities, renderItem: (data) => (msfsSdk.FSComponent.buildComponent(NearestIntersectionItem, { facility: data, ppos: this.ppos, onSelected: () => this.handleIntersectionSelected(data.icao) })), isolateScroll: true }))));
        }
    }
    /**
     * Nearest intersection list item
     */
    class NearestIntersectionItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.icon = msfsSdk.FSComponent.createRef();
            this.airportLla = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.ident = msfsSdk.Subject.create(msfsSdk.ICAO.getIdent(this.props.facility.icao));
            this.bearing = msfsSdk.CombinedSubject.create(this.props.ppos, this.airportLla).map(([ppos, airportLla]) => {
                const magBearing = msfsSdk.MagVar.trueToMagnetic(ppos.bearingTo(airportLla), ppos);
                return magBearing.toFixed(0).padStart(3, '0');
            });
            this.distance = msfsSdk.CombinedSubject.create(this.props.ppos, this.airportLla).map(([ppos, airportLla]) => {
                const distanceGARadians = airportLla.distance(ppos);
                const distanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(distanceGARadians, msfsSdk.UnitType.NMILE);
                return distanceNM.toFixed(1);
            });
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.airportLla.set(this.props.facility.lat, this.props.facility.lon);
            this.icon.instance.src = Icons.getByFacility(this.props.facility).src;
        }
        /** @inheritDoc */
        onDirectTo() {
            if (this.props.facility !== undefined) {
                ViewService.directToDialogWithIcao(this.props.facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: "aux-entry nearest-intersection-item" },
                msfsSdk.FSComponent.buildComponent("span", null,
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "nearest-intersection-item-icao", data: this.ident, onEnt: this.props.onSelected })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-intersection-item-icon" },
                    msfsSdk.FSComponent.buildComponent("img", { class: "nearest-intersection-item-icon-img", ref: this.icon })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-intersection-item-brg" },
                    this.bearing,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-intersection-item-dis" },
                    this.distance,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.NMILE) }))));
        }
    }

    /**
     * NEAREST NDB page
     */
    class NearestNdb extends NearestFacilityPage {
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            msfsSdk.NearestContext.onInitialized((instance) => {
                instance.ndbs.sub((index, type, item) => {
                    switch (type) {
                        case msfsSdk.SubscribableArrayEventType.Added:
                            this.facilities.insert(item, index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Removed:
                            this.facilities.removeAt(index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Cleared:
                            this.facilities.clear();
                            break;
                    }
                });
            });
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if ((evt === InteractionEvent.RightInnerInc || evt === InteractionEvent.RightInnerDec) && this.list.instance.isFocused) {
                return true;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /**
         * Handles an NDB being selected
         *
         * @param icao the NDB FS ICAO
         *
         * @returns true
         */
        handeNdbSelected(icao) {
            this.props.bus.getPublisher().pub('gns_nearest_pages_select_wpt_ndb', icao);
            this.props.onNdbSelected();
            return true;
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, class: "aux-page hide-element" },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "NEAREST NDB"),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels-nearest-ndb" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "NDB")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "BRG")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DIS")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "FREQ"))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table nearest-intersection-table" },
                    msfsSdk.FSComponent.buildComponent(GNSUiControlList, { ref: this.list, orderBy: (a, b) => {
                            const aPos = new msfsSdk.GeoPoint(a.lat, a.lon);
                            const aDistanceGARadians = this.ppos.get().distance(aPos);
                            const aDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(aDistanceGARadians, msfsSdk.UnitType.NMILE);
                            const bPos = new msfsSdk.GeoPoint(b.lat, b.lon);
                            const bDistanceGARadians = this.ppos.get().distance(bPos);
                            const bDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(bDistanceGARadians, msfsSdk.UnitType.NMILE);
                            return aDistanceNM - bDistanceNM;
                        }, data: this.facilities, renderItem: (data) => (msfsSdk.FSComponent.buildComponent(NearestNdbItem, { facility: data, ppos: this.ppos, onSelected: () => this.handeNdbSelected(data.icao) })), isolateScroll: true }))));
        }
    }
    /**
     * Nearest NDB list item
     */
    class NearestNdbItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.icon = msfsSdk.FSComponent.createRef();
            this.ndbLla = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.ident = msfsSdk.Subject.create(msfsSdk.ICAO.getIdent(this.props.facility.icao));
            this.mainFrequency = msfsSdk.Subject.create(null);
            this.bearing = msfsSdk.CombinedSubject.create(this.props.ppos, this.ndbLla).map(([ppos, airportLla]) => {
                const magBearing = msfsSdk.MagVar.trueToMagnetic(ppos.bearingTo(airportLla), ppos);
                return magBearing.toFixed(0).padStart(3, '0');
            });
            this.distance = msfsSdk.CombinedSubject.create(this.props.ppos, this.ndbLla).map(([ppos, airportLla]) => {
                const distanceGARadians = airportLla.distance(ppos);
                const distanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(distanceGARadians, msfsSdk.UnitType.NMILE);
                return distanceNM.toFixed(1);
            });
            this.mainFrequencyString = this.mainFrequency.map((it) => {
                if (it) {
                    return it.toFixed(1);
                }
                else {
                    return '___._';
                }
            });
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.ndbLla.set(this.props.facility.lat, this.props.facility.lon);
            this.mainFrequency.set(this.props.facility.freqMHz);
            this.icon.instance.src = Icons.getByFacility(this.props.facility).src;
        }
        /** @inheritDoc */
        onDirectTo() {
            if (this.props.facility !== undefined) {
                ViewService.directToDialogWithIcao(this.props.facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: "aux-entry nearest-ndb-item" },
                msfsSdk.FSComponent.buildComponent("span", null,
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "nearest-ndb-item-icao", data: this.ident, onEnt: this.props.onSelected }),
                    msfsSdk.FSComponent.buildComponent("img", { class: "nearest-ndb-item-icon-img", ref: this.icon })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-ndb-item-brg" },
                    this.bearing,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-ndb-item-dis" },
                    this.distance,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.NMILE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-ndb-item-freq" }, this.mainFrequencyString)));
        }
    }

    /**
     * NEAREST VOR page.
     */
    class NearestVor extends NearestFacilityPage {
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            msfsSdk.NearestContext.onInitialized((instance) => {
                instance.vors.sub((index, type, item) => {
                    switch (type) {
                        case msfsSdk.SubscribableArrayEventType.Added:
                            this.facilities.insert(item, index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Removed:
                            this.facilities.removeAt(index);
                            break;
                        case msfsSdk.SubscribableArrayEventType.Cleared:
                            this.facilities.clear();
                            break;
                    }
                });
            });
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if ((evt === InteractionEvent.RightInnerInc || evt === InteractionEvent.RightInnerDec) && this.list.instance.isFocused) {
                return true;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /**
         * Handles a VOR being selected
         *
         * @param icao the VOR FS ICAO
         *
         * @returns true
         */
        handleVorSelected(icao) {
            this.props.bus.getPublisher().pub('gns_nearest_pages_select_wpt_vor', icao);
            this.props.onVorSelected();
            return true;
        }
        /**
         * Sets the standby vor radio frequency.
         * @param facility The facility frequency to set to the standby radio frequency.
         * @returns If the method finishes.
         */
        setStandbyFrequency(facility) {
            if (facility !== null) {
                if (facility.freqMHz < 118) {
                    SimVar.SetSimVarValue(`K:${this.props.navIndex === 1 ? 'NAV1' : 'NAV2'}_STBY_SET`, 'number', facility.freqBCD16);
                }
                else {
                    SimVar.SetSimVarValue(`K:${this.props.comIndex === 1 ? 'COM' : 'COM2'}_STBY_RADIO_SET`, 'number', facility.freqBCD16);
                }
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, class: "aux-page hide-element" },
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-page-header' }),
                msfsSdk.FSComponent.buildComponent("div", { class: 'aux-table-header' }, "NEAREST VOR"),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table-labels-nearest-vor" },
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "VOR")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "BRG")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "DIS")),
                    msfsSdk.FSComponent.buildComponent("div", null,
                        msfsSdk.FSComponent.buildComponent("span", null, "FREQ"))),
                msfsSdk.FSComponent.buildComponent("div", { class: "aux-table nearest-vor-table" },
                    msfsSdk.FSComponent.buildComponent(GNSUiControlList, { ref: this.list, orderBy: (a, b) => {
                            const aPos = new msfsSdk.GeoPoint(a.lat, a.lon);
                            const aDistanceGARadians = this.ppos.get().distance(aPos);
                            const aDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(aDistanceGARadians, msfsSdk.UnitType.NMILE);
                            const bPos = new msfsSdk.GeoPoint(b.lat, b.lon);
                            const bDistanceGARadians = this.ppos.get().distance(bPos);
                            const bDistanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(bDistanceGARadians, msfsSdk.UnitType.NMILE);
                            return aDistanceNM - bDistanceNM;
                        }, data: this.facilities, renderItem: (data) => (msfsSdk.FSComponent.buildComponent(NearestVorItem, { facility: data, ppos: this.ppos, onSelected: () => this.handleVorSelected(data.icao), onFrequencySelected: () => this.setStandbyFrequency(data) })), isolateScroll: true }))));
        }
    }
    /**
     * Nearest NDB list item
     */
    class NearestVorItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.icon = msfsSdk.FSComponent.createRef();
            this.vorLla = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            this.ident = msfsSdk.Subject.create(msfsSdk.ICAO.getIdent(this.props.facility.icao));
            this.mainFrequency = msfsSdk.Subject.create(null);
            this.bearing = msfsSdk.CombinedSubject.create(this.props.ppos, this.vorLla).map(([ppos, airportLla]) => {
                const magBearing = msfsSdk.MagVar.trueToMagnetic(ppos.bearingTo(airportLla), ppos);
                return magBearing.toFixed(0).padStart(3, '0');
            });
            this.distance = msfsSdk.CombinedSubject.create(this.props.ppos, this.vorLla).map(([ppos, airportLla]) => {
                const distanceGARadians = airportLla.distance(ppos);
                const distanceNM = msfsSdk.UnitType.GA_RADIAN.convertTo(distanceGARadians, msfsSdk.UnitType.NMILE);
                return distanceNM.toFixed(1);
            });
            this.mainFrequencyString = this.mainFrequency.map((it) => {
                if (it) {
                    return it.toFixed(2);
                }
                else {
                    return '___.__';
                }
            });
        }
        /** @inheritDoc */
        onAfterRender(thisNode) {
            super.onAfterRender(thisNode);
            this.vorLla.set(this.props.facility.lat, this.props.facility.lon);
            this.mainFrequency.set(this.props.facility.freqMHz);
            this.icon.instance.src = Icons.getByFacility(this.props.facility).src;
        }
        /** @inheritDoc */
        onDirectTo() {
            if (this.props.facility !== undefined) {
                ViewService.directToDialogWithIcao(this.props.facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("span", { class: "aux-entry nearest-vor-item" },
                msfsSdk.FSComponent.buildComponent("span", null,
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "nearest-vor-item-icao", data: this.ident, onEnt: this.props.onSelected }),
                    msfsSdk.FSComponent.buildComponent("img", { class: "nearest-vor-item-icon-img", ref: this.icon })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-vor-item-brg" },
                    this.bearing,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-vor-item-dis" },
                    this.distance,
                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: msfsSdk.Subject.create(msfsSdk.UnitType.NMILE) })),
                msfsSdk.FSComponent.buildComponent("span", { class: "nearest-vor-item-freq" },
                    msfsSdk.FSComponent.buildComponent(SelectableText, { class: "nearest-vor-item-freq-num", data: this.mainFrequencyString, onEnt: this.props.onFrequencySelected }))));
        }
    }

    /**
     * menu button popups barebones since no options are selectable in proc menus
     */
    class ProcedurePageMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: ' (No Options) ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * Procedure Page.
     */
    class ProcedurePage extends Page {
        constructor() {
            super(...arguments);
            this.hasNoApproachLoaded = msfsSdk.Subject.create(true);
            this.procDetailsConsumer = this.props.bus.getSubscriber().on('fplProcDetailsChanged').handle(this.onPlanChanged.bind(this));
            this.menu = new ProcedurePageMenu();
            this.procPageMenuItems = msfsSdk.FSComponent.createRef();
            this.flightPhaseConsumer = msfsSdk.ConsumerSubject.create(null, { isApproachActive: false, isInMissedApproach: false, isPastFaf: false });
            this.approachAiportIdent = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '____';
                }
                return v;
            });
            this.arrivalAiportIdent = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '____';
                }
                return v;
            });
            this.departureAiportIdent = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '____';
                }
                return v;
            });
            this.approach = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '-';
                }
                return '- ' + GnsFmsUtils.getApproachNameAsString(v);
            });
            this.arrival = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '-';
                }
                return v;
            });
            this.departure = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v === undefined) {
                    return '-';
                }
                return v;
            });
            this.procPageList = [
                {
                    label: 'Activate Vectors-To-Final?', disabled: this.hasNoApproachLoaded, action: () => {
                        this.props.fms.activateVtf();
                        ViewService.back();
                    }
                },
                {
                    label: 'Activate Approach?', disabled: this.hasNoApproachLoaded, action: async () => {
                        const isApproachActive = this.flightPhaseConsumer.get().isApproachActive;
                        if (isApproachActive) {
                            const doIt = await ViewService.confirm('RESTART APPROACH', 'Are you sure you want to discontinue the current approach?');
                            if (!doIt) {
                                return;
                            }
                        }
                        this.props.fms.activateApproach();
                        // Opens standard nav map
                        ViewService.open('NAV', true, 1);
                    }
                },
                {
                    label: 'Select Approach?', disabled: false, action: () => {
                        var _a;
                        (_a = this.props.onPageSelected(3)) === null || _a === void 0 ? void 0 : _a.openFromProcMenu();
                    }
                },
                {
                    label: 'Select Arrival?', disabled: false, action: () => {
                        var _a;
                        (_a = this.props.onPageSelected(4)) === null || _a === void 0 ? void 0 : _a.openFromProcMenu();
                    }
                },
                {
                    label: 'Select Departure?', disabled: false, action: () => {
                        var _a;
                        (_a = this.props.onPageSelected(5)) === null || _a === void 0 ? void 0 : _a.openFromProcMenu();
                    }
                },
            ];
            this.procOptions = msfsSdk.ArraySubject.create(this.procPageList);
            /**
             * Picks the next page to be loaded
             * @param listMenuItem the menuEntry
             * @returns if the page has been loaded
             */
            this.onListItemSelected = (listMenuItem) => {
                const menuEntry = listMenuItem.props.data;
                if (menuEntry !== null) {
                    if (menuEntry.action instanceof msfsSdk.Subject) {
                        const action = menuEntry.action.get();
                        action();
                    }
                    else {
                        menuEntry.action();
                    }
                }
                return true;
            };
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            const list = this.procPageMenuItems.instance;
            list.focus(msfsSdk.FocusPosition.First);
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            const list = this.procPageMenuItems.instance;
            if (evt === InteractionEvent.RightKnobPush) {
                if (!list.isFocused) {
                    list.focus(msfsSdk.FocusPosition.MostRecent);
                }
                else {
                    list.blur();
                }
                return true;
            }
            else if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.menu);
                return true;
            }
            else if (evt === InteractionEvent.PROC) {
                ViewService.back();
                return true;
            }
            let handled = false;
            if (this.procPageMenuItems.instance.isFocused) {
                handled = this.procPageMenuItems.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (evt === InteractionEvent.RightOuterInc || evt === InteractionEvent.RightOuterDec) {
                return this.procPageMenuItems.instance.isFocused;
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /**
         * Will return whether an approach is returned or not.
         * @returns a boolean if there is an approach loaded
         */
        isApproachLoaded() {
            if (this.props.fms.hasPrimaryFlightPlan()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                return plan.procedureDetails.approachIndex > -1;
            }
            return false;
        }
        /**
         * Sets the hasNoApproachLoaded to true or false.
         */
        async onPlanChanged() {
            this.hasNoApproachLoaded.set(!this.isApproachLoaded());
            if (this.props.fms.hasPrimaryFlightPlan()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                const facloader = this.props.fms.facLoader;
                if (plan.procedureDetails.approachFacilityIcao !== undefined) {
                    const approachFacility = await facloader.getFacility(msfsSdk.FacilityType.Airport, plan.procedureDetails.approachFacilityIcao);
                    this.approach.set(approachFacility.approaches[plan.procedureDetails.approachIndex]);
                    this.approachAiportIdent.set(msfsSdk.ICAO.getIdent(plan.procedureDetails.approachFacilityIcao));
                }
                else {
                    this.approach.set(undefined);
                    this.approachAiportIdent.set(undefined);
                }
                if (plan.procedureDetails.arrivalFacilityIcao !== undefined) {
                    const arrivalFacility = await facloader.getFacility(msfsSdk.FacilityType.Airport, plan.procedureDetails.arrivalFacilityIcao);
                    this.arrival.set(GnsFmsUtils.getArrivalNameAsString(arrivalFacility, arrivalFacility.arrivals[plan.procedureDetails.arrivalIndex], plan.procedureDetails.arrivalTransitionIndex, undefined));
                    this.arrivalAiportIdent.set(msfsSdk.ICAO.getIdent(plan.procedureDetails.arrivalFacilityIcao));
                }
                else {
                    this.arrival.set(undefined);
                    this.arrivalAiportIdent.set(undefined);
                }
                if (plan.procedureDetails.departureFacilityIcao !== undefined) {
                    const departureFacility = await facloader.getFacility(msfsSdk.FacilityType.Airport, plan.procedureDetails.departureFacilityIcao);
                    this.departure.set(GnsFmsUtils.getDepartureNameAsString(departureFacility, departureFacility.departures[plan.procedureDetails.departureIndex], plan.procedureDetails.departureTransitionIndex, plan.procedureDetails.originRunway));
                    this.departureAiportIdent.set(msfsSdk.ICAO.getIdent(plan.procedureDetails.departureFacilityIcao));
                }
                else {
                    this.departure.set(undefined);
                    this.departureAiportIdent.set(undefined);
                }
            }
            else {
                this.approach.set(undefined);
                this.arrival.set(undefined);
                this.departure.set(undefined);
                this.approachAiportIdent.set(undefined);
                this.arrivalAiportIdent.set(undefined);
                this.departureAiportIdent.set(undefined);
            }
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            const sub = this.props.bus.getSubscriber();
            this.flightPhaseConsumer.setConsumer(sub.on('fms_flight_phase'));
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                msfsSdk.FSComponent.buildComponent("div", { class: 'page proc-page hide-element', ref: this.el },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "page-header" }, "PROCEDURES"),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'proc-table proc-table-full-height' },
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.procOptions, renderItem: (data) => msfsSdk.FSComponent.buildComponent(PageMenuItem, { data: data, onSelected: this.onListItemSelected }), ref: this.procPageMenuItems, hideScrollbar: true })),
                    this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent("div", { class: 'proc-loaded-procedures-header' },
                        "LOADED PROCEDURES",
                        msfsSdk.FSComponent.buildComponent("div", { class: 'proc-table proc-loaded-procedures' },
                            msfsSdk.FSComponent.buildComponent("div", { class: 'proc-loaded-procedures-labels' }, "APR"),
                            msfsSdk.FSComponent.buildComponent("div", null, this.approachAiportIdent),
                            msfsSdk.FSComponent.buildComponent("div", null, this.approach),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'proc-loaded-procedures-labels' }, "ARVL"),
                            msfsSdk.FSComponent.buildComponent("div", null, this.arrivalAiportIdent),
                            msfsSdk.FSComponent.buildComponent("div", null, this.arrival),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'proc-loaded-procedures-labels' }, "DEP"),
                            msfsSdk.FSComponent.buildComponent("div", null, this.departureAiportIdent),
                            msfsSdk.FSComponent.buildComponent("div", null, this.departure)))))));
        }
    }

    /**
     * A control that displays a Load Or Activate button.
     */
    class LoadActivateButton extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
            this.loadEl = msfsSdk.FSComponent.createRef();
            this.loadSpan = msfsSdk.FSComponent.createRef();
            this.orEl = msfsSdk.FSComponent.createRef();
            this.activateEl = msfsSdk.FSComponent.createRef();
            this.activateSpan = msfsSdk.FSComponent.createRef();
            this.loadControl = msfsSdk.FSComponent.createRef();
            this.activateControl = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onDisabled() {
            this.el.instance.classList.add('hide-element');
        }
        /** @inheritdoc */
        onEnabled() {
            this.el.instance.classList.remove('hide-element');
        }
        /**
         * A callback called when an element is focused.
         * @param ref The element to focus.
         */
        onElementFocused(ref) {
            ref.instance.classList.add('selected-white');
        }
        /**
         * A callback called when an element is blurred.
         * @param ref The element to blur.
         */
        onElementBlurred(ref) {
            ref.instance.classList.remove('selected-white');
        }
        /**
         * Sets the active state of the control.
         * @param state Whether load, both load and active, or just activate should be enabled.
         */
        setState(state) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            switch (state) {
                case 'load':
                    this.loadEl.instance.classList.remove('hide-element');
                    this.props.gnsType === 'wt530' && this.orEl.instance.classList.add('hide-element');
                    (_a = this.activateEl.getOrDefault()) === null || _a === void 0 ? void 0 : _a.classList.add('hide-element');
                    (_b = this.loadControl.getOrDefault()) === null || _b === void 0 ? void 0 : _b.setDisabled(false);
                    (_c = this.activateControl.getOrDefault()) === null || _c === void 0 ? void 0 : _c.setDisabled(true);
                    break;
                case 'loadAndActivate':
                    this.loadEl.instance.classList.remove('hide-element');
                    this.props.gnsType === 'wt530' && this.orEl.instance.classList.remove('hide-element');
                    (_d = this.activateEl.getOrDefault()) === null || _d === void 0 ? void 0 : _d.classList.remove('hide-element');
                    (_e = this.loadControl.getOrDefault()) === null || _e === void 0 ? void 0 : _e.setDisabled(false);
                    (_f = this.activateControl.getOrDefault()) === null || _f === void 0 ? void 0 : _f.setDisabled(false);
                    break;
                case 'activate':
                    this.loadEl.instance.classList.add('hide-element');
                    this.props.gnsType === 'wt530' && this.orEl.instance.classList.add('hide-element');
                    (_g = this.activateEl.getOrDefault()) === null || _g === void 0 ? void 0 : _g.classList.remove('hide-element');
                    (_h = this.loadControl.getOrDefault()) === null || _h === void 0 ? void 0 : _h.setDisabled(true);
                    (_j = this.activateControl.getOrDefault()) === null || _j === void 0 ? void 0 : _j.setDisabled(false);
                    break;
            }
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: this.props.class, ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.loadControl, onFocused: () => this.onElementFocused(this.loadSpan), onBlurred: () => this.onElementBlurred(this.loadSpan), onEnt: () => { this.props.onLoad(); return true; } },
                    msfsSdk.FSComponent.buildComponent("div", { ref: this.loadEl },
                        msfsSdk.FSComponent.buildComponent("span", { ref: this.loadSpan }, "Load?"))),
                this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent("div", { ref: this.orEl, className: 'load-or-activate-button-or' }, "OR")),
                ((_a = this.props.showActivate) !== null && _a !== void 0 ? _a : true) && (msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.activateControl, onFocused: () => this.onElementFocused(this.activateSpan), onBlurred: () => this.onElementBlurred(this.activateSpan), onEnt: () => { this.props.onActivate(); return true; } },
                    msfsSdk.FSComponent.buildComponent("div", { ref: this.activateEl },
                        msfsSdk.FSComponent.buildComponent("span", { ref: this.activateSpan }, "Activate?"))))));
        }
    }

    /**
     * menu button popup for ProcApproachPage
     */
    class ProcApproachPageMenu extends MenuDefinition {
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        constructor(bus, fms, noProcedureLoaded, onFacilitySelected, insertApproach) {
            super();
            this.fms = fms;
            this.noProcedureLoaded = noProcedureLoaded;
            this.onFacilitySelected = onFacilitySelected;
            this.insertApproach = insertApproach;
            this.hasNoDestinationAirport = msfsSdk.Subject.create(false);
            this.hasNoPlanAirports = msfsSdk.Subject.create(false);
            /** @inheritdoc */
            this.entries = [
                {
                    label: 'Load into Active FPL?', disabled: this.noProcedureLoaded, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.insertApproach(false);
                        }
                    }
                },
                {
                    label: 'Load And Activate?', disabled: this.noProcedureLoaded, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.insertApproach(true);
                        }
                    }
                },
                {
                    label: 'Select Approach Chnl?', disabled: true, action: () => {
                    }
                },
                {
                    label: 'Select Next FPL Apt?', disabled: this.hasNoDestinationAirport, action: () => {
                        const airport = this.getDestinationAirport();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
                {
                    label: 'Select Destination Apt?', disabled: this.hasNoDestinationAirport, action: () => {
                        const airport = this.getDestinationAirport();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
            ];
            this.onPlanChanged = () => {
                let hasNoPlanAirports = true;
                let hasNoDestinationAirport = true;
                if (this.fms.hasPrimaryFlightPlan()) {
                    const plan = this.fms.getPrimaryFlightPlan();
                    hasNoDestinationAirport = (plan.destinationAirport ? false : true);
                    if (plan.destinationAirport) {
                        hasNoPlanAirports = false;
                    }
                    else {
                        for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                            const leg = plan.getLeg(l);
                            if (leg.leg.fixIcao[0] === 'A') {
                                hasNoPlanAirports = false;
                            }
                        }
                    }
                }
                this.hasNoPlanAirports.set(hasNoPlanAirports);
                this.hasNoDestinationAirport.set(hasNoDestinationAirport);
            };
            bus.getSubscriber().on('fplLegChange').handle(this.onPlanChanged);
        }
        /**
         * Finds the next airport in the flight plan
         * @returns a airport facility
         */
        findNextAirportInPlan() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                    const leg = plan.getLeg(l);
                    if (leg.leg.fixIcao[0] === 'A') {
                        facility = leg.leg.fixIcao;
                        break;
                    }
                }
                if (!facility && plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /**
         * Finds the destination airport in the flight plan
         * @returns the destination airport facility
         */
        getDestinationAirport() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                if (plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * Page in the WPT group
     */
    class WaypointPage extends Page {
        constructor() {
            super(...arguments);
            this.root = msfsSdk.FSComponent.createRef();
            this.waypointSelection = msfsSdk.FSComponent.createRef();
            this.menu = undefined;
        }
        /** @inheritDoc */
        onInteractionEvent(evt) {
            let handled = false;
            if (this.root.instance.isFocused) {
                handled = this.root.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return true;
            }
            else if (evt === InteractionEvent.RightKnobPush) {
                if (this.root.instance.isFocused) {
                    this.root.instance.blur();
                }
                else {
                    this.root.instance.focus(msfsSdk.FocusPosition.First);
                    this.waypointSelection.instance.focusSelf();
                }
                return true;
            }
            else if (evt === InteractionEvent.MENU) {
                if (this.menu) {
                    ViewService.menu(this.menu);
                    return true;
                }
                return false;
            }
            else if (evt === InteractionEvent.DirectTo) {
                return this.onDirectPressed();
            }
            else {
                return super.onInteractionEvent(evt);
            }
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            if (this.props.isPopup.get()) {
                this.waypointSelection.instance.focusSelf();
            }
        }
        /** @inheritDoc */
        onSuspend() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.blur();
            this.waypointSelection.instance.displayKeyboardIcon(false);
            super.onSuspend();
        }
        /**
         * Method to overide in each waypoint page when the direct to button is pressed.
         * @returns Whether this interaction event was handled.
         */
        onDirectPressed() {
            return false;
        }
    }

    /**
     * A control that allows a waypoint to be selected via an alphanumeric input.
     */
    class WaypointSelection extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.input = msfsSdk.FSComponent.createRef();
            this.matchingIcaos = [];
            this.currentRequestId = 0;
        }
        /**
         * Handles when the ident is changed in the input control.
         * @param ident The new ident.
         * @param index The input index that changed.
         * @param changedTo The value the input index changed to.
         */
        onInputChanged(ident, index, changedTo) {
            this.facility = undefined;
            this.matchingIcaos.length = 0;
            if (this.debounceTimeout !== undefined) {
                window.clearTimeout(this.debounceTimeout);
            }
            this.debounceTimeout = window.setTimeout(() => this.loadIdent(ident, ++this.currentRequestId, changedTo === '_'), 250);
        }
        /**
         * Loads an ident into the waypoint display.
         * @param ident The ident to search for.
         * @param requestId The ID of the ident search request to process.
         * @param exactOnly Whether or not to return only an exact match.
         */
        async loadIdent(ident, requestId, exactOnly) {
            var _a;
            let icaos = await this.props.facilityLoader.searchByIdent((_a = this.props.filter) !== null && _a !== void 0 ? _a : msfsSdk.FacilitySearchType.AllExceptVisual, ident, 10);
            if (icaos.length !== 0) {
                if (this.props.filter === msfsSdk.FacilitySearchType.Intersection) {
                    icaos = icaos.filter(icao => icao[0] === 'W');
                    if (icaos.length < 1) {
                        this.props.onChanged({ matchingIcaos: [] });
                        return;
                    }
                }
                const facilityIdent = msfsSdk.ICAO.getIdent(icaos[0]).trim();
                const matchingIcaos = exactOnly
                    ? icaos.filter(icao => msfsSdk.ICAO.getIdent(icao).trim() === ident)
                    : icaos.filter(icao => msfsSdk.ICAO.getIdent(icao).trim() === facilityIdent);
                const facilities = await Promise.all(matchingIcaos.map(icao => this.props.facilityLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao)));
                if (this.currentRequestId === requestId && facilities.length > 0) {
                    this.facility = facilities.sort((a, b) => this.orderByPPosDistance(a, b))[0];
                    this.matchingIcaos = matchingIcaos;
                    this.input.instance.set(facilityIdent);
                    this.props.onChanged({ facility: this.facility, matchingIcaos: this.matchingIcaos });
                }
                else if (this.currentRequestId === requestId) {
                    this.props.onChanged({ matchingIcaos: this.matchingIcaos });
                }
            }
            else {
                this.props.onChanged({ matchingIcaos: [] });
            }
        }
        /** @inheritdoc */
        onEnt() {
            if (this.matchingIcaos.length > 1 && this.facility !== undefined) {
                ViewService.resolveDups(msfsSdk.ICAO.getIdent(this.facility.icao).trim(), this.matchingIcaos)
                    .then(fac => {
                    var _a;
                    if (((_a = this.facility) === null || _a === void 0 ? void 0 : _a.icao) !== fac.icao) {
                        this.facility = fac;
                        this.props.onChanged({ facility: this.facility, matchingIcaos: this.matchingIcaos });
                    }
                    this.props.onFinalized();
                });
            }
            if (this.matchingIcaos.length === 1) {
                this.props.onFinalized();
            }
            return true;
        }
        /** @inheritdoc */
        onRightKnobPush() {
            if (this.isFocused) {
                if (this.input.instance.isEditing) {
                    this.focusSelf();
                    return true;
                }
            }
            return false;
        }
        /** @inheritdoc */
        onRightInnerInc() {
            if (!this.input.instance.isEditing) {
                return this.input.instance.onRightInnerInc();
            }
            return false;
        }
        /** @inheritdoc */
        onRightInnerDec() {
            if (!this.input.instance.isEditing) {
                return this.input.instance.onRightInnerDec();
            }
            return false;
        }
        /** @inheritdoc */
        onFocused() {
            this.focusSelf();
        }
        /**
         * Sets the ident in the waypoint input.
         * @param ident The ident to set.
         * @param notify Whether or not to call the onChanged callback when set.
         */
        setIdent(ident, notify = true) {
            this.input.instance.set(ident);
            if (notify) {
                this.onInputChanged(ident, 0, ident[0]);
            }
        }
        /**
         * Sets the facility in the waypoint input control.
         * @param facility The facility to set.
         * @param notify Whether or not to call the onChanged callback when set.
         */
        setFacility(facility, notify = true) {
            this.facility = facility;
            this.matchingIcaos.length = 0;
            if (facility !== undefined) {
                const ident = msfsSdk.ICAO.getIdent(facility.icao).trim();
                this.input.instance.set(ident);
                this.matchingIcaos.push(facility.icao);
                if (notify) {
                    this.props.onChanged({ facility, matchingIcaos: [facility.icao] });
                }
            }
            else {
                this.input.instance.set('');
                if (notify) {
                    this.props.onChanged({ facility, matchingIcaos: [] });
                }
            }
        }
        /**
         * Shifts focus to the control itself and not the children.
         */
        focusSelf() {
            this.input.instance.focusSelf();
        }
        /**
         * Enables the individual alphanumeric input slots.
         */
        enableSlots() {
            this.input.instance.enableSlots();
        }
        /**
         * Disables the individual alphanumeric input slots.
         */
        disableSlots() {
            this.input.instance.disableSlots();
        }
        /**
         * Disables the individual alphanumeric input slots.
         */
        disableInput() {
            this.disableSlots();
        }
        /**
         * Makes the inactive value initially visible.
         */
        setVisible() {
            this.input.instance.setDisabled(false);
            this.disableSlots();
        }
        /**
         * Shows the Keyboard icon.
         * @param display Boolean to show keyboard icon.
         */
        displayKeyboardIcon(display) {
            this.input.instance.displayKeyboardIcon(display);
        }
        /**
         * Orders facilities by their distance to the plane PPOS.
         * @param a The first facility.
         * @param b The second facility.
         * @returns The comparison order number.
         */
        orderByPPosDistance(a, b) {
            const aDist = this.props.ppos.get().distance(a.lat, a.lon);
            const bDist = this.props.ppos.get().distance(b.lat, b.lon);
            if (aDist < bDist) {
                return -1;
            }
            if (aDist > bDist) {
                return 1;
            }
            return 0;
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(AlphaNumInput, { class: `waypoint-input ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`, length: this.props.length, onChanged: this.onInputChanged.bind(this), ref: this.input, gnsType: this.props.gnsType, enableKeyboard: true })));
        }
    }

    /**
     * A control that allows a waypoint to be selected via an alphanumeric input.
     */
    class WaypointPageIdentInput extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.waypointSelection = msfsSdk.FSComponent.createRef();
            this.icon = msfsSdk.FSComponent.createRef();
            this.airportPrivacy = msfsSdk.ComputedSubject.create(undefined, (v) => GnsFmsUtils.getAirportPrivateTypeString(v));
            this.doneButtonContainer = msfsSdk.FSComponent.createRef();
            this.doneButton = msfsSdk.FSComponent.createRef();
        }
        /** @inheritDoc */
        onAfterRender() {
            var _a;
            this.doneButton.instance.setDisabled(true);
            this.props.selectedFacility.sub(this.onFacilitySelected.bind(this), true);
            (_a = this.props.showDoneButton) === null || _a === void 0 ? void 0 : _a.sub(show => {
                if (show) {
                    this.doneButtonContainer.instance.classList.remove('hide-element');
                    this.doneButton.instance.setDisabled(false);
                }
                else {
                    this.doneButtonContainer.instance.classList.add('hide-element');
                    this.doneButton.instance.setDisabled(true);
                }
            });
        }
        /**
         * Updates the waypoint icon and privacy text display.
         * @param facility The Selected Facility.
         */
        onFacilitySelected(facility) {
            if (facility && msfsSdk.ICAO.getFacilityType(facility.icao) === msfsSdk.FacilityType.Airport) {
                this.airportPrivacy.set(facility);
            }
            else {
                this.airportPrivacy.set(undefined);
            }
            if (facility !== undefined) {
                this.icon.instance.src = Icons.getByFacility(facility).src;
            }
            else {
                this.icon.instance.src = '';
            }
        }
        /**
         * Passes a focus-self to the WaypointSelection component.
         */
        focusSelf() {
            var _a;
            if ((_a = this.props.showDoneButton) === null || _a === void 0 ? void 0 : _a.get()) {
                this.doneButton.instance.focus(msfsSdk.FocusPosition.First);
            }
            else {
                this.waypointSelection.instance.focusSelf();
            }
        }
        /**
         * Sets the ident in the WaypointSelection component.
         * @param ident The ident to set.
         * @param notify Whether or not to call the onChanged callback when set.
         */
        setIdent(ident, notify = true) {
            this.waypointSelection.instance.setIdent(ident, notify);
        }
        /**
         * Sets the facility in the waypoint input control.
         * @param facility The facility to set.
         * @param notify Whether or not to call the onChanged callback when set.
         */
        setFacility(facility, notify = true) {
            this.waypointSelection.instance.setFacility(facility, notify);
        }
        /**
         * Shows the Keyboard icon.
         * @param display Boolean to show keyboard icon.
         */
        displayKeyboardIcon(display) {
            this.waypointSelection.instance.displayKeyboardIcon(display);
        }
        /** @inheritDoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : 'waypoint-page-header' },
                msfsSdk.FSComponent.buildComponent("span", { class: 'waypoint-page-title' }, this.props.title),
                msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-inputbox' },
                    msfsSdk.FSComponent.buildComponent(WaypointSelection, { class: 'waypoint-page-ident-input', onChanged: this.props.onChanged.bind(this), onFinalized: this.props.onFinalized.bind(this), length: this.props.length, ppos: this.props.ppos, facilityLoader: this.props.facilityLoader, filter: this.props.filter, ref: this.waypointSelection, gnsType: this.props.gnsType }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-icon' },
                        msfsSdk.FSComponent.buildComponent("img", { ref: this.icon })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-privacy' }, this.airportPrivacy)),
                msfsSdk.FSComponent.buildComponent("span", { ref: this.doneButtonContainer, class: "hide-element" },
                    msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.doneButton, class: "waypoint-page-done", selectedClass: "selected-white", data: msfsSdk.Subject.create('Done?'), onEnt: () => {
                            var _a, _b;
                            (_b = (_a = this.props).onPopupDonePressed) === null || _b === void 0 ? void 0 : _b.call(_a);
                            return true;
                        } }))));
        }
    }

    /**
     * The approach proc page.
     */
    class ProcApproachPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.previewMap = GNSMapBuilder
                .withProcedurePreviewMap(this.props.bus, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.fms.flightPlanner))
                .build('waypoint-page-map');
            this.planModule = this.previewMap.context.model.getModule(msfsSdk.MapSystemKeys.FlightPlan);
            this.rangeModule = this.previewMap.context.model.getModule(GNSMapKeys.Range);
            this.flightPathCalculator = new msfsSdk.FlightPathCalculator(this.props.fms.facLoader, {
                defaultClimbRate: 1000,
                defaultSpeed: 120,
                bankAngle: 20,
                holdBankAngle: null,
                courseReversalBankAngle: null,
                turnAnticipationBankAngle: null,
                maxBankAngle: 20,
                airplaneSpeedMode: msfsSdk.FlightPathAirplaneSpeedMode.GroundSpeed
            }, this.props.bus);
            this.noProcedureSelected = msfsSdk.Subject.create(true);
            this.menu = new ProcApproachPageMenu(this.props.bus, this.props.fms, this.noProcedureSelected, (facility) => {
                facility && this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility));
            }, (activate) => {
                return this.insertApproach(activate);
            });
            this.approaches = msfsSdk.FSComponent.createRef();
            this.transitions = msfsSdk.FSComponent.createRef();
            this.loadActivate = msfsSdk.FSComponent.createRef();
            this.settingExistingData = false;
            this.openedFromProcPage = false;
            this.selectedFacility = this.props.selectedAirport.sub(this.onAirportSelected.bind(this)).pause();
            this.gnsValidApproaches = [];
            this.previewOpId = 0;
            this.selectedFlag = msfsSdk.Subject.create('');
            this.selectedFlagRef = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.noProcedureSelected.sub(v => {
                if (v) {
                    this.gnsValidApproaches.length = 0;
                }
            });
            this.onSuspend();
        }
        /** @inheritdoc */
        onSuspend() {
            this.previewMap.ref.instance.sleep();
            this.selectedFacility.pause();
            this.approaches.instance.closePopout();
            this.transitions.instance.closePopout();
            this.openedFromProcPage = false;
            this.setLoadOrActivateState();
            super.onSuspend();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.selectedFacility.resume();
            this.previewMap.ref.instance.wake();
            const airport = this.props.selectedAirport.get();
            if (airport) {
                this.onAirportSelected(airport);
            }
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RangeIncrease) {
                this.previewMap.context.getController(GNSMapKeys.Controller).increaseRange();
                return true;
            }
            else if (evt === InteractionEvent.RangeDecrease) {
                this.previewMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                return true;
            }
            let handled = false;
            if (this.root.instance.isFocused) {
                handled = this.root.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Method called when this page is opened from the PROC page,
         * indicating that the LOAD/ACTIVATE interface should be available.
         */
        openFromProcMenu() {
            this.openedFromProcPage = true;
            this.setExistingProcedureData().then(() => {
                if (this.approaches.instance.listLength > 0) {
                    this.approaches.instance.openPopout();
                }
            });
            this.setLoadOrActivateState();
        }
        /**
         * Sets the Approach List Items, or clears the list if no valid facility or no valid appraoches.
         * @param airport The Airport Facility if any.
         * @returns whether approach items were set.
         */
        setApproachItems(airport) {
            this.gnsValidApproaches.length = 0;
            if (airport) {
                if (airport.approaches.length > 0) {
                    this.gnsValidApproaches = GnsFmsUtils.getValidApproaches(airport);
                }
                if (this.gnsValidApproaches.length > 0) {
                    this.approaches.instance.setItems(this.gnsValidApproaches.map(approach => this.buildApproachName(approach.approachProcedure)));
                    this.approaches.instance.setSelectedItem(0, false);
                    return true;
                }
            }
            this.approaches.instance.setItems([]);
            return false;
        }
        /**
         * Displays the current approach data on the page.
         */
        async setExistingProcedureData() {
            var _a, _b;
            let facility;
            this.settingExistingData = true;
            if (this.props.fms.getDirectToState() !== msfsGarminsdk.DirectToState.NONE && this.props.fms.flightPlanner.hasActiveFlightPlan()) {
                const plan = this.props.fms.flightPlanner.getActiveFlightPlan();
                const activeLeg = plan.tryGetLeg(plan.activeLateralLeg);
                if (activeLeg !== null && msfsSdk.ICAO.getFacilityType(activeLeg.leg.fixIcao) === msfsSdk.FacilityType.Airport) {
                    facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, activeLeg.leg.fixIcao);
                    this.props.selectedAirport.set(facility);
                }
                this.updatePreviewMap();
                this.setLoadOrActivateState();
            }
            else if (this.props.fms.hasPrimaryFlightPlan()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                //Check if a procedure is already loaded
                if (plan.procedureDetails.approachIndex > -1 && plan.procedureDetails.approachFacilityIcao) {
                    if (plan.procedureDetails.approachFacilityIcao !== ((_a = this.props.selectedAirport.get()) === null || _a === void 0 ? void 0 : _a.icao)) {
                        // Only bother with the facLoader and the async method if the selectedAirport is NOT already the approachFacility
                        facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.procedureDetails.approachFacilityIcao);
                        this.props.selectedAirport.set(facility);
                    }
                    else {
                        facility = this.props.selectedAirport.get();
                        this.onAirportSelected(facility);
                    }
                    this.setApproachItems(facility);
                    if (!facility) {
                        return;
                    }
                    this.selectedApproach = plan.procedureDetails.approachIndex;
                    this.selectedTransition = plan.procedureDetails.approachTransitionIndex;
                    const selectedApproachListIndex = this.gnsValidApproaches.findIndex(map => map.index === this.selectedApproach);
                    this.approaches.instance.setSelectedItem(selectedApproachListIndex, false);
                    this.transitions.instance.setItems(['VECTORS', ...facility.approaches[plan.procedureDetails.approachIndex].transitions.map(t => t.name)]);
                    this.transitions.instance.setSelectedItem(plan.procedureDetails.approachTransitionIndex + 1, false);
                    this.approaches.instance.openPopout(plan.procedureDetails.approachIndex);
                }
                else if (plan.destinationAirport) {
                    //Check if there is a destination airport specified.
                    if (plan.destinationAirport !== ((_b = this.props.selectedAirport.get()) === null || _b === void 0 ? void 0 : _b.icao)) {
                        // Only bother with the facLoader and the async method if the selectedAirport is NOT already the approachFacility
                        facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.destinationAirport);
                        this.props.selectedAirport.set(facility);
                    }
                    else {
                        facility = this.props.selectedAirport.get();
                        this.onAirportSelected(facility);
                    }
                    this.selectedApproach = undefined;
                    this.selectedTransition = undefined;
                }
                this.updatePreviewMap();
                this.setLoadOrActivateState();
            }
            this.settingExistingData = false;
        }
        /**
         * Sets the state of the load or activate buttons.
         * 'load' | 'loadAndActivate' | 'activate'
         */
        setLoadOrActivateState() {
            if (this.openedFromProcPage && this.checkIfApproachesExist()) {
                const canLoad = this.props.fms.canApproachLoad();
                {
                    this.loadActivate.instance.setDisabled(false);
                    this.loadActivate.instance.setState(canLoad ? 'loadAndActivate' :
                        'activate');
                }
            }
            else {
                this.loadActivate.instance.setDisabled(true);
            }
        }
        /**
         * Checks whether the selected facility has at least one approach.
         * @returns Whether the selected facility has at least one approach.
         */
        checkIfApproachesExist() {
            if (this.openedFromProcPage) {
                const airport = this.props.selectedAirport.get();
                if (airport !== undefined && airport.approaches.length > 0 && this.gnsValidApproaches.length > 0) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const airport = e.facility;
            this.props.selectedAirport.set(airport);
        }
        /**
         * Handles when a new airport is selected in the page group.
         * @param airport The airport that was selected.
         */
        onAirportSelected(airport) {
            this.noProcedureSelected.set(airport === undefined || airport.approaches.length < 1);
            if (airport !== undefined) {
                this.waypointSelection.instance.setFacility(airport, false);
                this.selectedApproach = undefined;
                this.selectedTransition = undefined;
                if (this.setApproachItems(airport)) {
                    const transitions = this.gnsValidApproaches[0].approachProcedure.transitions;
                    if (transitions.length > 0) {
                        this.transitions.instance.setItems(['VECTORS', ...transitions.map(trans => trans.name)]);
                        this.transitions.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.transitions.instance.setItems([]);
                    }
                    this.previewMap.context.getController(GNSMapKeys.Controller).unfocusAirport();
                    this.updatePreviewMap();
                }
                else {
                    this.setApproachItems();
                    this.transitions.instance.setItems([]);
                    this.previewMap.context.getController(GNSMapKeys.Controller).focusAirport(new msfsGarminsdk.AirportWaypoint(airport, this.props.bus), -1);
                }
            }
            else {
                this.setApproachItems();
                this.transitions.instance.setItems([]);
                this.previewMap.context.getController(GNSMapKeys.Controller).unfocusAirport();
            }
            this.setLoadOrActivateState();
        }
        /**
         * Handles when an approach has been selected for an airport.
         * @param index The index of the approach from the list of gnsValidApproaches.
         */
        onApproachSelected(index) {
            if (index < 0) {
                this.transitions.instance.setItems([]);
                this.selectedTransition = undefined;
                this.setLoadOrActivateState();
                return;
            }
            const facilityApproachIndex = this.gnsValidApproaches[index].index;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && !this.settingExistingData) {
                const approach = this.gnsValidApproaches[index].approachProcedure;
                if (approach !== undefined && this.selectedApproach !== facilityApproachIndex) {
                    this.selectedApproach = facilityApproachIndex;
                    const transitions = approach.transitions;
                    if (approach.transitions.length > 0) {
                        this.transitions.instance.setItems(['VECTORS', ...transitions.map(t => t.name)]);
                        this.transitions.instance.setSelectedItem(0, false);
                    }
                    else if (approach.transitions.length === 0) {
                        if (approach.transitions.length === 0 && approach.finalLegs.length > 0) {
                            this.transitions.instance.setItems(['VECTORS', msfsSdk.ICAO.getIdent(approach.finalLegs[0].fixIcao)]);
                        }
                        this.transitions.instance.setSelectedItem(0, false);
                        this.selectedTransition = undefined;
                    }
                    const parts = msfsGarminsdk.FmsUtils.getApproachNameAsParts(approach);
                    this.renderRNAV(parts.flags);
                    this.scrollToNext();
                    this.updatePreviewMap();
                }
            }
        }
        /**
         * Handles when the transition has been selected.
         * @param index The index of the transition.
         */
        onTransitionSelected(index) {
            const adjustedIndex = index - 1;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedApproach !== undefined && !this.settingExistingData) {
                const approach = airport.approaches[this.selectedApproach];
                if (approach !== undefined) {
                    const transition = approach.transitions[adjustedIndex];
                    if ((transition === undefined && adjustedIndex === 0) || transition !== undefined || adjustedIndex === -1) {
                        this.selectedTransition = adjustedIndex;
                    }
                    else {
                        this.selectedTransition = undefined;
                    }
                    this.scrollToNext();
                }
                this.updatePreviewMap();
            }
        }
        /**
         * Activate the next selection.
         */
        scrollToNext() {
            if (this.approaches.instance.isFocused) {
                if (this.transitions.instance.listLength > 0) {
                    this.transitions.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
            else if (this.transitions.instance.isFocused) {
                this.root.instance.scroll('forward');
            }
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                if (this.gnsValidApproaches.length > 0) {
                    this.approaches.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
        }
        /**
         * Builds a text based approach name for selection display.
         * @param approach The approach to build the name for.
         * @returns The approach name.
         */
        buildApproachName(approach) {
            const parts = msfsGarminsdk.FmsUtils.getApproachNameAsParts(approach);
            let name = parts.type;
            if (name === 'RNAV') {
                name += 'É';
            }
            parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
            parts.runway && (name += ` ${parts.runway}`);
            return name;
        }
        /**
         * Inserts the approach into the flight plan.
         * @param activate Whether or not to activate the approach.
         */
        async insertApproach(activate) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedApproach !== undefined && this.selectedTransition !== undefined) {
                const approachToInsert = airport.approaches[this.selectedApproach];
                let canInsert = true;
                if (!msfsGarminsdk.FmsUtils.isGpsApproach(approachToInsert)) {
                    canInsert = await ViewService.confirm('NOT APPROVED FOR GPS', `GPS guidance is for monitoring only.\r\n${activate ? 'Activate' : 'Load'} approach?`);
                }
                if (canInsert) {
                    await this.props.fms.insertApproach(airport, this.selectedApproach, this.selectedTransition, undefined, undefined, undefined, activate);
                    ViewService.back();
                    ViewService.open('FPL', false, 0);
                }
            }
        }
        /**
         * Builds the page's procedure preview plan.
         */
        async updatePreviewMap() {
            var _a, _b;
            this.previewOpId++;
            const currentOpId = this.previewOpId;
            const airport = this.props.selectedAirport.get();
            const approachIndex = (_a = this.selectedApproach) !== null && _a !== void 0 ? _a : this.gnsValidApproaches[0].index;
            const transitionIndex = (_b = this.selectedTransition) !== null && _b !== void 0 ? _b : -1;
            if (airport !== undefined && airport.approaches.length > 0 && approachIndex !== undefined && transitionIndex !== undefined) {
                const procTask = this.props.fms.buildProcedurePreviewPlan(this.flightPathCalculator, airport, msfsGarminsdk.ProcedureType.APPROACH, approachIndex, transitionIndex);
                const transTask = this.props.fms.buildProcedureTransitionPreviewPlan(this.flightPathCalculator, airport, msfsGarminsdk.ProcedureType.APPROACH, approachIndex, transitionIndex);
                const previewPlans = await Promise.all([procTask, transTask]);
                if (currentOpId === this.previewOpId) {
                    previewPlans[1].planIndex = 1;
                    this.planModule.getPlanSubjects(0).flightPlan.set(previewPlans[0]);
                    this.planModule.getPlanSubjects(1).flightPlan.set(previewPlans[1]);
                    const focusCalc = new msfsGarminsdk.MapFlightPlanFocusCalculator(this.previewMap.context.projection);
                    const result = { range: 0, target: new msfsSdk.GeoPoint(0, 0) };
                    focusCalc.calculateRangeTarget([...previewPlans[0].legs()], new Float64Array([6, 6, 6, 6]), new msfsSdk.GeoPoint(0, 0), result);
                    const ranges = this.rangeModule.nominalRanges.get();
                    for (let i = 0; i < ranges.length; i++) {
                        const nominalRange = ranges[i].asUnit(msfsSdk.UnitType.GA_RADIAN);
                        if (nominalRange >= result.range) {
                            this.rangeModule.setNominalRangeIndex(i);
                            break;
                        }
                    }
                    this.previewMap.context.projection.set({ target: result.target });
                }
            }
        }
        /**
         * Renders the RNAV box that overlaps on the map.
         * @param flag rnav type
         */
        renderRNAV(flag) {
            if (this.props.gnsType === 'wt430') ;
            else {
                if (flag === 'LPV') {
                    this.selectedFlagRef.instance.classList.remove('hide-element');
                    this.selectedFlag.set('LPV');
                }
                else if (flag === 'LP') {
                    this.selectedFlagRef.instance.classList.remove('hide-element');
                    this.selectedFlag.set('LP');
                }
                else if (flag === 'LP+V') {
                    this.selectedFlagRef.instance.classList.remove('hide-element');
                    this.selectedFlag.set('LP+V');
                }
                else if (flag === 'L/VNAV') {
                    this.selectedFlagRef.instance.classList.remove('hide-element');
                    this.selectedFlag.set('L/VNAV');
                }
                else if (flag === 'LNAV+V') {
                    this.selectedFlagRef.instance.classList.remove('hide-element');
                    this.selectedFlag.set('LNAV+V');
                }
                else if (flag === 'LNAV') {
                    this.selectedFlagRef.instance.classList.remove('hide-element');
                    this.selectedFlag.set('LNAV');
                }
                else {
                    this.selectedFlagRef.instance.classList.add('hide-element');
                    this.selectedFlag.set('');
                }
            }
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedAirport.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedAirport, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'APT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Airport }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-body' },
                        this.previewMap.map,
                        msfsSdk.FSComponent.buildComponent("div", { class: 'rnav-type-box hide-element', ref: this.selectedFlagRef }, this.selectedFlag),
                        msfsSdk.FSComponent.buildComponent("div", { id: "proc-approach-selectors", class: 'waypoint-page-selectors' },
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'approach', label: this.props.gnsType === 'wt530' ? 'APPROACH' : 'APR', onSelected: this.onApproachSelected.bind(this), ref: this.approaches }),
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'transition', label: 'TRANS', onSelected: this.onTransitionSelected.bind(this), ref: this.transitions }),
                            msfsSdk.FSComponent.buildComponent(LoadActivateButton, { class: 'load-or-activate-button-approach', ref: this.loadActivate, gnsType: this.props.gnsType, onLoad: this.insertApproach.bind(this, false), onActivate: this.insertApproach.bind(this, true) }))))));
        }
    }

    /**
     * menu button popup for ProcArrivalPage
     */
    class ProcArrivalPageMenu extends MenuDefinition {
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        constructor(bus, fms, noProcedureLoaded, onFacilitySelected, insertArrival) {
            super();
            this.fms = fms;
            this.noProcedureLoaded = noProcedureLoaded;
            this.onFacilitySelected = onFacilitySelected;
            this.insertArrival = insertArrival;
            this.hasNoDestinationAirport = msfsSdk.Subject.create(false);
            this.hasNoPlanAirports = msfsSdk.Subject.create(false);
            /** @inheritdoc */
            this.entries = [
                {
                    label: 'Load into Active FPL?', disabled: this.noProcedureLoaded, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.insertArrival();
                        }
                    }
                },
                {
                    label: 'Select Next FPL Apt?', disabled: this.hasNoPlanAirports, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
                {
                    label: 'Select Destination Apt?', disabled: this.hasNoDestinationAirport, action: () => {
                        const airport = this.getDestinationAirport();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
            ];
            this.onPlanChanged = () => {
                let hasNoPlanAirports = true;
                let hasNoDestinationAirport = true;
                if (this.fms.hasPrimaryFlightPlan()) {
                    const plan = this.fms.getPrimaryFlightPlan();
                    hasNoDestinationAirport = (plan.destinationAirport ? false : true);
                    if (plan.destinationAirport) {
                        hasNoPlanAirports = false;
                    }
                    else {
                        for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                            const leg = plan.getLeg(l);
                            if (leg.leg.fixIcao[0] === 'A') {
                                hasNoPlanAirports = false;
                            }
                        }
                    }
                }
                this.hasNoPlanAirports.set(hasNoPlanAirports);
                this.hasNoDestinationAirport.set(hasNoDestinationAirport);
            };
            bus.getSubscriber().on('fplLegChange').handle(this.onPlanChanged);
        }
        /**
         * Finds the next airport in the flight plan
         * @returns a airport facility
         */
        findNextAirportInPlan() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                    const leg = plan.getLeg(l);
                    if (leg.leg.fixIcao[0] === 'A') {
                        facility = leg.leg.fixIcao;
                        break;
                    }
                }
                if (!facility && plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /**
         * Finds the destination airport in the flight plan
         * @returns the destination airport facility
         */
        getDestinationAirport() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                if (plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * The Arrival proc page.
     */
    class ProcArrivalPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.previewMap = GNSMapBuilder
                .withProcedurePreviewMap(this.props.bus, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.fms.flightPlanner))
                .build('waypoint-page-map');
            this.planModule = this.previewMap.context.model.getModule(msfsSdk.MapSystemKeys.FlightPlan);
            this.rangeModule = this.previewMap.context.model.getModule(GNSMapKeys.Range);
            this.flightPathCalculator = new msfsSdk.FlightPathCalculator(this.props.fms.facLoader, {
                defaultClimbRate: 1000,
                defaultSpeed: 120,
                bankAngle: 20,
                holdBankAngle: null,
                courseReversalBankAngle: null,
                turnAnticipationBankAngle: null,
                maxBankAngle: 20,
                airplaneSpeedMode: msfsSdk.FlightPathAirplaneSpeedMode.GroundSpeed
            }, this.props.bus);
            this.noProcedureSelected = msfsSdk.Subject.create(true);
            this.menu = new ProcArrivalPageMenu(this.props.bus, this.props.fms, this.noProcedureSelected, (facility) => {
                facility && this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility));
            }, () => {
                return this.insertArrival();
            });
            this.arrival = msfsSdk.FSComponent.createRef();
            this.transitions = msfsSdk.FSComponent.createRef();
            this.runways = msfsSdk.FSComponent.createRef();
            this.loadActivate = msfsSdk.FSComponent.createRef();
            this.settingExistingData = false;
            this.openedFromProcPage = false;
            this.selectedFacility = this.props.selectedAirport.sub(this.onAirportSelected.bind(this)).pause();
            this.previewOpId = 0;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.onSuspend();
        }
        /** @inheritdoc */
        onSuspend() {
            this.previewMap.ref.instance.sleep();
            this.selectedFacility.pause();
            this.arrival.instance.closePopout();
            this.runways.instance.closePopout();
            this.transitions.instance.closePopout();
            this.openedFromProcPage = false;
            this.setLoadOrActivateState();
            super.onSuspend();
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.selectedFacility.resume();
            this.previewMap.ref.instance.wake();
            const airport = this.props.selectedAirport.get();
            if (airport) {
                this.onAirportSelected(airport);
            }
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RangeIncrease) {
                this.previewMap.context.getController(GNSMapKeys.Controller).increaseRange();
                return true;
            }
            else if (evt === InteractionEvent.RangeDecrease) {
                this.previewMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                return true;
            }
            let handled = false;
            if (this.root.instance.isFocused) {
                handled = this.root.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Method called when this page is opened from the PROC page,
         * indicating that the LOAD/ACTIVATE interface should be available.
         */
        openFromProcMenu() {
            this.openedFromProcPage = true;
            this.setExistingProcedureData().then(() => {
                if (this.arrival.instance.listLength > 0) {
                    this.arrival.instance.openPopout();
                }
            });
            this.setLoadOrActivateState();
        }
        /**
         * Displays the current arrival data on the page.
         */
        async setExistingProcedureData() {
            var _a, _b;
            let facility;
            this.settingExistingData = true;
            if (this.props.fms.getDirectToState() !== msfsGarminsdk.DirectToState.NONE && this.props.fms.flightPlanner.hasActiveFlightPlan()) {
                const plan = this.props.fms.flightPlanner.getActiveFlightPlan();
                const activeLeg = plan.tryGetLeg(plan.activeLateralLeg);
                if (activeLeg !== null && msfsSdk.ICAO.getFacilityType(activeLeg.leg.fixIcao) === msfsSdk.FacilityType.Airport) {
                    facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, activeLeg.leg.fixIcao);
                    this.props.selectedAirport.set(facility);
                }
                this.updatePreviewMap();
                this.setLoadOrActivateState();
            }
            else if (this.props.fms.hasPrimaryFlightPlan()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                //Check if a procedure is already loaded
                if (plan.procedureDetails.arrivalIndex > -1 && plan.procedureDetails.arrivalFacilityIcao) {
                    if (plan.procedureDetails.arrivalFacilityIcao !== ((_a = this.props.selectedAirport.get()) === null || _a === void 0 ? void 0 : _a.icao)) {
                        // Only bother with the facLoader and the async method if the selectedAirport is NOT already the arrivalFacility
                        facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.procedureDetails.arrivalFacilityIcao);
                        this.props.selectedAirport.set(facility);
                    }
                    else {
                        facility = this.props.selectedAirport.get();
                        this.onAirportSelected(facility);
                    }
                    const arrival = facility === null || facility === void 0 ? void 0 : facility.arrivals[plan.procedureDetails.arrivalIndex];
                    this.arrival.instance.setSelectedItem(plan.procedureDetails.arrivalIndex);
                    if (arrival !== undefined) {
                        this.selectedArrival = plan.procedureDetails.departureIndex;
                        const transitions = arrival.enRouteTransitions;
                        const runwayTransitions = arrival.runwayTransitions;
                        if (transitions.length > 0) {
                            this.transitions.instance.setItems(arrival.enRouteTransitions.map(item => item.name));
                            if (plan.procedureDetails.arrivalTransitionIndex >= 0) {
                                this.selectedTransition = plan.procedureDetails.arrivalTransitionIndex;
                                this.transitions.instance.setSelectedItem(this.selectedTransition, false);
                            }
                            else {
                                this.transitions.instance.setSelectedItem(0, false);
                                this.selectedTransition = undefined;
                            }
                        }
                        else {
                            this.transitions.instance.setItems([]);
                            this.selectedTransition = undefined;
                        }
                        if (runwayTransitions.length > 0) {
                            this.runways.instance.setItems(arrival.runwayTransitions.map(item => msfsSdk.RunwayUtils.getRunwayNameString(item.runwayNumber, item.runwayDesignation, true, 'RW')));
                            if (plan.procedureDetails.arrivalRunwayTransitionIndex >= 0) {
                                this.selectedRunway = plan.procedureDetails.arrivalRunwayTransitionIndex;
                                this.runways.instance.setSelectedItem(this.selectedRunway, false);
                            }
                            else {
                                this.runways.instance.setSelectedItem(0, false);
                                this.selectedRunway = undefined;
                            }
                        }
                        else {
                            this.runways.instance.setItems([]);
                            this.selectedRunway = undefined;
                        }
                    }
                }
                else if (plan.destinationAirport) {
                    //Check if there is an origin airport specified.
                    if (plan.originAirport !== ((_b = this.props.selectedAirport.get()) === null || _b === void 0 ? void 0 : _b.icao)) {
                        // Only bother with the facLoader and the async method if the selectedAirport is NOT already the departureFacility
                        facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.destinationAirport);
                        this.props.selectedAirport.set(facility);
                    }
                    else {
                        facility = this.props.selectedAirport.get();
                        this.onAirportSelected(facility);
                    }
                    this.selectedArrival = undefined;
                    this.selectedTransition = undefined;
                    this.selectedRunway = undefined;
                }
                this.updatePreviewMap();
                this.setLoadOrActivateState();
            }
            this.settingExistingData = false;
        }
        /**
         * Sets the state of the load or activate buttons.
         */
        setLoadOrActivateState() {
            if (this.openedFromProcPage && this.canProcedureLoad()) {
                this.loadActivate.instance.setDisabled(false);
                this.loadActivate.instance.setState('load');
            }
            else {
                this.loadActivate.instance.setDisabled(true);
            }
        }
        /**
         * Checks whether the procedure can load.
         * @returns whether the procedure can load.
         */
        canProcedureLoad() {
            if (this.openedFromProcPage) {
                const airport = this.props.selectedAirport.get();
                if (airport !== undefined && airport.arrivals.length > 0) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const airport = e.facility;
            this.props.selectedAirport.set(airport);
        }
        /**
         * Handles when a new airport is selected in the page group.
         * @param airport The airport that was selected.
         */
        onAirportSelected(airport) {
            this.noProcedureSelected.set(airport === undefined || airport.arrivals.length < 1);
            if (airport !== undefined) {
                this.waypointSelection.instance.setFacility(airport, false);
                this.selectedArrival = undefined;
                this.selectedTransition = undefined;
                this.selectedRunway = undefined;
                if (airport.arrivals.length > 0) {
                    this.arrival.instance.setItems(airport.arrivals.map(arrival => this.buildArrivalName(arrival)));
                    this.arrival.instance.setSelectedItem(0, false);
                    const transitions = airport.arrivals[0].enRouteTransitions;
                    const runwayTransitions = airport.arrivals[0].runwayTransitions;
                    if (transitions.length > 0) {
                        this.transitions.instance.setItems(airport.arrivals[0].enRouteTransitions.map(item => item.name));
                        this.transitions.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.transitions.instance.setItems([]);
                    }
                    if (runwayTransitions.length > 0) {
                        this.runways.instance.setItems(airport.arrivals[0].runwayTransitions.map(item => msfsSdk.RunwayUtils.getRunwayNameString(item.runwayNumber, item.runwayDesignation, true, 'RW')));
                        this.runways.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.runways.instance.setItems([]);
                    }
                    this.previewMap.context.getController(GNSMapKeys.Controller).unfocusAirport();
                    this.updatePreviewMap();
                }
                else {
                    this.arrival.instance.setItems([]);
                    this.transitions.instance.setItems([]);
                    this.runways.instance.setItems([]);
                    this.previewMap.context.getController(GNSMapKeys.Controller).focusAirport(new msfsGarminsdk.AirportWaypoint(airport, this.props.bus), -1);
                }
            }
            this.setLoadOrActivateState();
        }
        /**
         * Handles when an Arrival has been selected for an airport.
         * @param index The index of the Arrival.
         */
        onArrivalSelected(index) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && !this.settingExistingData) {
                const arrival = airport.arrivals[index];
                if (arrival !== undefined && this.selectedArrival !== index) {
                    this.selectedArrival = index;
                    const transitions = arrival.enRouteTransitions;
                    const runwayTransitions = arrival.runwayTransitions;
                    if (transitions.length > 0) {
                        this.transitions.instance.setItems(arrival.enRouteTransitions.map(item => item.name));
                        this.transitions.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.transitions.instance.setItems([]);
                        this.selectedTransition = undefined;
                    }
                    if (runwayTransitions.length > 0) {
                        this.runways.instance.setItems(arrival.runwayTransitions.map(item => msfsSdk.RunwayUtils.getRunwayNameString(item.runwayNumber, item.runwayDesignation, true, 'RW')));
                        this.runways.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.runways.instance.setItems([]);
                        this.selectedRunway = undefined;
                    }
                }
                this.scrollToNext();
                this.updatePreviewMap();
            }
        }
        /**
         * Handles when a transition has been selected for an airport.
         * @param index The index of the transition.
         */
        onTransitionSelected(index) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedArrival !== undefined && !this.settingExistingData) {
                const arrival = airport.arrivals[this.selectedArrival];
                if (arrival !== undefined) {
                    const transition = arrival.enRouteTransitions[index];
                    if (transition !== undefined) {
                        this.selectedTransition = index;
                    }
                    else {
                        this.selectedTransition = undefined;
                    }
                    this.scrollToNext();
                }
                this.updatePreviewMap();
            }
        }
        /**
         * Handles when the runway selection has changed.
         * @param index The index of the runway transition.
         */
        onRunwaySelected(index) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedArrival !== undefined && !this.settingExistingData) {
                const arrival = airport.arrivals[this.selectedArrival];
                if (arrival !== undefined) {
                    const runwayTransition = arrival.runwayTransitions[index];
                    if (runwayTransition !== undefined) {
                        this.selectedRunway = index;
                    }
                    else {
                        this.selectedRunway = undefined;
                    }
                    this.scrollToNext();
                }
                this.updatePreviewMap();
            }
        }
        /**
         * Activate the next selection.
         */
        scrollToNext() {
            if (this.arrival.instance.isFocused) {
                if (this.transitions.instance.listLength > 0) {
                    this.transitions.instance.openPopout();
                }
                else if (this.runways.instance.listLength > 0) {
                    this.root.instance.scroll('forward');
                    this.runways.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
            else if (this.transitions.instance.isFocused) {
                if (this.runways.instance.listLength > 0) {
                    this.runways.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
            else if (this.runways.instance.isFocused) {
                this.root.instance.scroll('forward');
            }
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                if (airport.arrivals.length > 0) {
                    this.arrival.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
        }
        /**
         * Builds a text based arrival name for selection display.
         * @param arrival The arrival to build the name for.
         * @returns The arrival name.
         */
        buildArrivalName(arrival) {
            return arrival.name;
        }
        /**
         * Inserts the arrival into the flight plan.
         */
        async insertArrival() {
            var _a, _b;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedArrival !== undefined) {
                this.props.fms.insertArrival(airport, this.selectedArrival, (_a = this.selectedRunway) !== null && _a !== void 0 ? _a : -1, (_b = this.selectedTransition) !== null && _b !== void 0 ? _b : -1);
                ViewService.back();
                ViewService.open('FPL', false, 0);
            }
        }
        /**
         * Builds the page's procedure preview plan.
         */
        async updatePreviewMap() {
            var _a, _b, _c;
            this.previewOpId++;
            const currentOpId = this.previewOpId;
            const airport = this.props.selectedAirport.get();
            const arrivalIndex = (_a = this.selectedArrival) !== null && _a !== void 0 ? _a : 0;
            const transitionIndex = (_b = this.selectedTransition) !== null && _b !== void 0 ? _b : 0;
            const runwayIndex = (_c = this.selectedRunway) !== null && _c !== void 0 ? _c : 0;
            if (airport !== undefined && airport.approaches.length > 0 && arrivalIndex !== undefined && transitionIndex !== undefined) {
                const procTask = this.props.fms.buildProcedurePreviewPlan(this.flightPathCalculator, airport, msfsGarminsdk.ProcedureType.ARRIVAL, arrivalIndex, transitionIndex, undefined, runwayIndex);
                const transTask = this.props.fms.buildProcedureTransitionPreviewPlan(this.flightPathCalculator, airport, msfsGarminsdk.ProcedureType.ARRIVAL, arrivalIndex, transitionIndex, runwayIndex);
                const previewPlans = await Promise.all([procTask, transTask]);
                if (currentOpId === this.previewOpId) {
                    previewPlans[1].planIndex = 1;
                    this.planModule.getPlanSubjects(0).flightPlan.set(previewPlans[0]);
                    this.planModule.getPlanSubjects(1).flightPlan.set(previewPlans[1]);
                    const focusCalc = new msfsGarminsdk.MapFlightPlanFocusCalculator(this.previewMap.context.projection);
                    const result = { range: 0, target: new msfsSdk.GeoPoint(0, 0) };
                    focusCalc.calculateRangeTarget([...previewPlans[0].legs()], new Float64Array([6, 6, 6, 6]), new msfsSdk.GeoPoint(0, 0), result);
                    const ranges = this.rangeModule.nominalRanges.get();
                    for (let i = 0; i < ranges.length; i++) {
                        const nominalRange = ranges[i].asUnit(msfsSdk.UnitType.GA_RADIAN);
                        if (nominalRange >= result.range) {
                            this.rangeModule.setNominalRangeIndex(i);
                            break;
                        }
                    }
                    this.previewMap.context.projection.set({ target: result.target });
                }
            }
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedAirport.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedAirport, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'APT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Airport }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-body' },
                        this.previewMap.map,
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-arrival-page-selectors' },
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'arrival', label: 'ARRIVAL', onSelected: this.onArrivalSelected.bind(this), ref: this.arrival }),
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'arrival-transition', label: 'TRANS', onSelected: this.onTransitionSelected.bind(this), ref: this.transitions }),
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'arrival-runway', label: 'RUNWAY', onSelected: this.onRunwaySelected.bind(this), ref: this.runways }),
                            msfsSdk.FSComponent.buildComponent(LoadActivateButton, { class: 'load-or-activate-button-arrival', ref: this.loadActivate, showActivate: this.props.gnsType === 'wt530', gnsType: this.props.gnsType, onLoad: this.insertArrival.bind(this, false), onActivate: this.insertArrival.bind(this, true) }))))));
        }
    }

    /**
     * menu button popup for ProcDepartureMenu
     */
    class ProcDepartureMenu extends MenuDefinition {
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        constructor(bus, fms, noProcedureLoaded, onFacilitySelected, insertDeparture) {
            super();
            this.fms = fms;
            this.noProcedureLoaded = noProcedureLoaded;
            this.onFacilitySelected = onFacilitySelected;
            this.insertDeparture = insertDeparture;
            this.hasNoDestinationAirport = msfsSdk.Subject.create(false);
            this.hasNoPlanAirports = msfsSdk.Subject.create(false);
            /** @inheritdoc */
            this.entries = [
                {
                    label: 'Load into Active FPL?', disabled: this.noProcedureLoaded, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.insertDeparture();
                        }
                    }
                },
                {
                    label: 'Select Next FPL Apt?', disabled: this.hasNoPlanAirports, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
                {
                    label: 'Select Destination Apt?', disabled: this.hasNoDestinationAirport, action: () => {
                        const airport = this.getDestinationAirport();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
            ];
            this.onPlanChanged = () => {
                let hasNoPlanAirports = true;
                let hasNoDestinationAirport = true;
                if (this.fms.hasPrimaryFlightPlan()) {
                    const plan = this.fms.getPrimaryFlightPlan();
                    hasNoDestinationAirport = (plan.destinationAirport ? false : true);
                    if (plan.destinationAirport) {
                        hasNoPlanAirports = false;
                    }
                    else {
                        for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                            const leg = plan.getLeg(l);
                            if (leg.leg.fixIcao[0] === 'A') {
                                hasNoPlanAirports = false;
                            }
                        }
                    }
                }
                this.hasNoPlanAirports.set(hasNoPlanAirports);
                this.hasNoDestinationAirport.set(hasNoDestinationAirport);
            };
            bus.getSubscriber().on('fplLegChange').handle(this.onPlanChanged);
        }
        /**
         * Finds the next airport in the flight plan
         * @returns a airport facility
         */
        findNextAirportInPlan() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                    const leg = plan.getLeg(l);
                    if (leg.leg.fixIcao[0] === 'A') {
                        facility = leg.leg.fixIcao;
                        break;
                    }
                }
                if (!facility && plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /**
         * Finds the destination airport in the flight plan
         * @returns the destination airport facility
         */
        getDestinationAirport() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                if (plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * The Proc departure props page
     */
    class ProcDeparturePage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.previewMap = GNSMapBuilder
                .withProcedurePreviewMap(this.props.bus, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.fms.flightPlanner))
                .build('waypoint-page-map');
            this.planModule = this.previewMap.context.model.getModule(msfsSdk.MapSystemKeys.FlightPlan);
            this.rangeModule = this.previewMap.context.model.getModule(GNSMapKeys.Range);
            this.flightPathCalculator = new msfsSdk.FlightPathCalculator(this.props.fms.facLoader, {
                defaultClimbRate: 1000,
                defaultSpeed: 120,
                bankAngle: 20,
                holdBankAngle: null,
                courseReversalBankAngle: null,
                turnAnticipationBankAngle: null,
                maxBankAngle: 20,
                airplaneSpeedMode: msfsSdk.FlightPathAirplaneSpeedMode.GroundSpeed
            }, this.props.bus);
            this.noProcedureSelected = msfsSdk.Subject.create(true);
            this.menu = new ProcDepartureMenu(this.props.bus, this.props.fms, this.noProcedureSelected, (facility) => {
                facility && this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility));
            }, () => {
                return this.insertDeparture();
            });
            this.departure = msfsSdk.FSComponent.createRef();
            this.transitions = msfsSdk.FSComponent.createRef();
            this.runways = msfsSdk.FSComponent.createRef();
            this.loadActivate = msfsSdk.FSComponent.createRef();
            this.settingExistingData = false;
            this.openedFromProcPage = false;
            this.selectedFacility = this.props.selectedAirport.sub(this.onAirportSelected.bind(this)).pause();
            this.previewOpId = 0;
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.onSuspend();
        }
        /** @inheritdoc */
        onSuspend() {
            this.previewMap.ref.instance.sleep();
            this.selectedFacility.pause();
            this.departure.instance.closePopout();
            this.runways.instance.closePopout();
            this.transitions.instance.closePopout();
            this.openedFromProcPage = false;
            this.setLoadOrActivateState();
            super.onSuspend();
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.selectedFacility.resume();
            this.previewMap.ref.instance.wake();
            const airport = this.props.selectedAirport.get();
            if (airport) {
                this.onAirportSelected(airport);
            }
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RangeIncrease) {
                this.previewMap.context.getController(GNSMapKeys.Controller).increaseRange();
                return true;
            }
            else if (evt === InteractionEvent.RangeDecrease) {
                this.previewMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                return true;
            }
            let handled = false;
            if (this.root.instance.isFocused) {
                handled = this.root.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Method called when this page is opened from the PROC page,
         * indicating that the LOAD/ACTIVATE interface should be available.
         */
        openFromProcMenu() {
            this.openedFromProcPage = true;
            this.setExistingProcedureData().then(() => {
                if (this.departure.instance.listLength > 0) {
                    this.departure.instance.openPopout();
                }
            });
            this.setLoadOrActivateState();
        }
        /**
         * Displays the current departure data on the page.
         */
        async setExistingProcedureData() {
            var _a, _b;
            this.settingExistingData = true;
            if (this.props.fms.hasPrimaryFlightPlan()) {
                const plan = this.props.fms.getPrimaryFlightPlan();
                //Check if a procedure is already loaded
                if (plan.procedureDetails.departureIndex > -1 && plan.procedureDetails.departureFacilityIcao) {
                    let facility;
                    if (plan.procedureDetails.departureFacilityIcao !== ((_a = this.props.selectedAirport.get()) === null || _a === void 0 ? void 0 : _a.icao)) {
                        // Only bother with the facLoader and the async method if the selectedAirport is NOT already the departureFacility
                        facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.procedureDetails.departureFacilityIcao);
                        this.props.selectedAirport.set(facility);
                    }
                    else {
                        facility = this.props.selectedAirport.get();
                        this.onAirportSelected(facility);
                    }
                    const departure = facility === null || facility === void 0 ? void 0 : facility.departures[plan.procedureDetails.departureIndex];
                    this.departure.instance.setSelectedItem(plan.procedureDetails.departureIndex);
                    if (departure !== undefined) {
                        this.selectedDeparture = plan.procedureDetails.departureIndex;
                        const transitions = departure.enRouteTransitions;
                        const runwayTransitions = departure.runwayTransitions;
                        if (transitions.length > 0) {
                            this.transitions.instance.setItems(departure.enRouteTransitions.map(item => item.name));
                            if (plan.procedureDetails.departureTransitionIndex >= 0) {
                                this.selectedTransition = plan.procedureDetails.departureTransitionIndex;
                                this.transitions.instance.setSelectedItem(this.selectedTransition, false);
                            }
                            else {
                                this.transitions.instance.setSelectedItem(0, false);
                                this.selectedTransition = undefined;
                            }
                        }
                        else {
                            this.transitions.instance.setItems([]);
                            this.selectedTransition = undefined;
                        }
                        if (runwayTransitions.length > 0) {
                            this.runways.instance.setItems(departure.runwayTransitions.map(item => msfsSdk.RunwayUtils.getRunwayNameString(item.runwayNumber, item.runwayDesignation, true, 'RW')));
                            if (plan.procedureDetails.departureRunwayIndex >= 0) {
                                this.selectedRunway = plan.procedureDetails.departureRunwayIndex;
                                this.runways.instance.setSelectedItem(this.selectedRunway, false);
                            }
                            else {
                                this.runways.instance.setSelectedItem(0, false);
                                this.selectedRunway = undefined;
                            }
                        }
                        else {
                            this.runways.instance.setItems([]);
                            this.selectedRunway = undefined;
                        }
                    }
                }
                else if (plan.originAirport) {
                    //Check if there is an origin airport specified.
                    let facility;
                    if (plan.originAirport !== ((_b = this.props.selectedAirport.get()) === null || _b === void 0 ? void 0 : _b.icao)) {
                        // Only bother with the facLoader and the async method if the selectedAirport is NOT already the departureFacility
                        facility = await this.props.fms.facLoader.getFacility(msfsSdk.FacilityType.Airport, plan.originAirport);
                        this.props.selectedAirport.set(facility);
                    }
                    else {
                        facility = this.props.selectedAirport.get();
                        this.onAirportSelected(facility);
                    }
                    this.selectedDeparture = undefined;
                    this.selectedTransition = undefined;
                    this.selectedRunway = undefined;
                }
                this.updatePreviewMap();
                this.setLoadOrActivateState();
            }
            this.settingExistingData = false;
        }
        /**
         * Sets the state of the load or activate buttons.
         */
        setLoadOrActivateState() {
            if (this.openedFromProcPage && this.canProcedureLoad()) {
                this.loadActivate.instance.setDisabled(false);
                this.loadActivate.instance.setState('load');
            }
            else {
                this.loadActivate.instance.setDisabled(true);
            }
        }
        /**
         * Checks whether the procedure can load.
         * @returns whether the procedure can load.
         */
        canProcedureLoad() {
            if (this.openedFromProcPage) {
                const airport = this.props.selectedAirport.get();
                if (airport !== undefined && airport.departures.length > 0) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const airport = e.facility;
            this.props.selectedAirport.set(airport);
        }
        /**
         * Handles when a new airport is selected in the page group.
         * @param airport The airport that was selected.
         */
        onAirportSelected(airport) {
            this.noProcedureSelected.set(airport === undefined || airport.departures.length < 1);
            if (airport !== undefined) {
                this.waypointSelection.instance.setFacility(airport, false);
                this.selectedDeparture = undefined;
                this.selectedTransition = undefined;
                this.selectedRunway = undefined;
                if (airport.departures.length > 0) {
                    this.departure.instance.setItems(airport.departures.map(departure => this.buildDepartureName(departure)));
                    this.departure.instance.setSelectedItem(0, false);
                    const transitions = airport.departures[0].enRouteTransitions;
                    const runwayTransitions = airport.departures[0].runwayTransitions;
                    if (transitions.length > 0) {
                        this.transitions.instance.setItems(transitions.map(item => item.name));
                        this.transitions.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.transitions.instance.setItems([]);
                    }
                    if (runwayTransitions.length > 0) {
                        this.runways.instance.setItems(runwayTransitions.map(item => msfsSdk.RunwayUtils.getRunwayNameString(item.runwayNumber, item.runwayDesignation, true, 'RW')));
                        this.runways.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.runways.instance.setItems([]);
                    }
                    this.previewMap.context.getController(GNSMapKeys.Controller).unfocusAirport();
                    this.updatePreviewMap();
                }
                else {
                    this.departure.instance.setItems([]);
                    this.transitions.instance.setItems([]);
                    this.runways.instance.setItems([]);
                    this.previewMap.context.getController(GNSMapKeys.Controller).focusAirport(new msfsGarminsdk.AirportWaypoint(airport, this.props.bus), -1);
                }
            }
            this.setLoadOrActivateState();
        }
        /**
         * Handles when an deaparture has been selected for an airport.
         * @param index The index of the deaparture.
         */
        onDepartureSelected(index) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && !this.settingExistingData) {
                const departure = airport.departures[index];
                if (departure !== undefined && this.selectedDeparture !== index) {
                    this.selectedDeparture = index;
                    const transitions = departure.enRouteTransitions;
                    const runwayTransitions = departure.runwayTransitions;
                    if (runwayTransitions.length > 0) {
                        this.runways.instance.setItems(departure.runwayTransitions.map(item => msfsSdk.RunwayUtils.getRunwayNameString(item.runwayNumber, item.runwayDesignation, true, 'RW')));
                        this.runways.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.runways.instance.setItems([]);
                        this.selectedRunway = undefined;
                    }
                    if (transitions.length > 0) {
                        this.transitions.instance.setItems(departure.enRouteTransitions.map(item => item.name));
                        this.transitions.instance.setSelectedItem(0, false);
                    }
                    else {
                        this.transitions.instance.setItems([]);
                        this.selectedTransition = undefined;
                    }
                }
                this.scrollToNext();
                this.updatePreviewMap();
            }
        }
        /**
         * Handles when a runway has been selected for an airport.
         * @param index The index of the runway.
         */
        onRunwaySelected(index) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedDeparture !== undefined && !this.settingExistingData) {
                const departure = airport.departures[this.selectedDeparture];
                if (departure !== undefined) {
                    const runwayTransition = departure.runwayTransitions[index];
                    if (runwayTransition !== undefined) {
                        this.selectedRunway = index;
                    }
                    else {
                        this.selectedRunway = undefined;
                    }
                    this.scrollToNext();
                }
                this.updatePreviewMap();
            }
        }
        /**
         * Handles when a transition has been selected for an airport.
         * @param index The index of the transition.
         */
        onTransitionSelected(index) {
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedDeparture !== undefined && !this.settingExistingData) {
                const departure = airport.departures[this.selectedDeparture];
                if (departure !== undefined) {
                    const transition = departure.enRouteTransitions[index];
                    if (transition !== undefined) {
                        this.selectedTransition = index;
                    }
                    else {
                        this.selectedTransition = undefined;
                    }
                    this.scrollToNext();
                }
                this.updatePreviewMap();
            }
        }
        /**
         * Activate the next selection.
         */
        scrollToNext() {
            if (this.departure.instance.isFocused) {
                if (this.runways.instance.listLength > 0) {
                    this.runways.instance.openPopout();
                }
                else if (this.transitions.instance.listLength > 0) {
                    this.root.instance.scroll('forward');
                    this.transitions.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
            else if (this.runways.instance.isFocused) {
                if (this.transitions.instance.listLength > 0) {
                    this.transitions.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
            else if (this.transitions.instance.isFocused) {
                this.root.instance.scroll('forward');
            }
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                if (airport.departures.length > 0) {
                    this.departure.instance.openPopout();
                }
                else {
                    this.root.instance.scroll('forward');
                }
            }
        }
        /**
         * Builds a text based departure name for selection display.
         * @param departure The departure to build the name for.
         * @returns The departure name.
         */
        buildDepartureName(departure) {
            return departure.name;
        }
        /**
         * Inserts the deaparture into the flight plan.
         */
        async insertDeparture() {
            var _a, _b;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined && this.selectedDeparture !== undefined) {
                let oneWayRunway = undefined;
                if (this.selectedRunway !== undefined) {
                    const departure = airport.departures[this.selectedDeparture];
                    if (departure !== undefined) {
                        const runwayTransition = departure.runwayTransitions[this.selectedRunway];
                        if (runwayTransition !== undefined) {
                            oneWayRunway = msfsSdk.RunwayUtils.matchOneWayRunway(airport, runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                        }
                    }
                }
                this.props.fms.insertDeparture(airport, this.selectedDeparture, (_a = this.selectedRunway) !== null && _a !== void 0 ? _a : -1, (_b = this.selectedTransition) !== null && _b !== void 0 ? _b : -1, oneWayRunway);
                ViewService.back();
                ViewService.open('FPL', false, 0);
            }
        }
        /**
         * Builds the page's procedure preview plan.
         */
        async updatePreviewMap() {
            var _a, _b, _c;
            this.previewOpId++;
            const currentOpId = this.previewOpId;
            const airport = this.props.selectedAirport.get();
            const departureIndex = (_a = this.selectedDeparture) !== null && _a !== void 0 ? _a : 0;
            const transitionIndex = (_b = this.selectedTransition) !== null && _b !== void 0 ? _b : 0;
            const runwayIndex = (_c = this.selectedRunway) !== null && _c !== void 0 ? _c : 0;
            if (airport !== undefined && airport.approaches.length > 0 && departureIndex !== undefined && transitionIndex !== undefined) {
                const procTask = this.props.fms.buildProcedurePreviewPlan(this.flightPathCalculator, airport, msfsGarminsdk.ProcedureType.DEPARTURE, departureIndex, transitionIndex, undefined, runwayIndex);
                const transTask = this.props.fms.buildProcedureTransitionPreviewPlan(this.flightPathCalculator, airport, msfsGarminsdk.ProcedureType.DEPARTURE, departureIndex, transitionIndex, runwayIndex);
                const previewPlans = await Promise.all([procTask, transTask]);
                if (currentOpId === this.previewOpId) {
                    previewPlans[1].planIndex = 1;
                    this.planModule.getPlanSubjects(0).flightPlan.set(previewPlans[0]);
                    this.planModule.getPlanSubjects(1).flightPlan.set(previewPlans[1]);
                    const focusCalc = new msfsGarminsdk.MapFlightPlanFocusCalculator(this.previewMap.context.projection);
                    const result = { range: 0, target: new msfsSdk.GeoPoint(0, 0) };
                    focusCalc.calculateRangeTarget([...previewPlans[0].legs()], new Float64Array([6, 6, 6, 6]), new msfsSdk.GeoPoint(0, 0), result);
                    const ranges = this.rangeModule.nominalRanges.get();
                    for (let i = 0; i < ranges.length; i++) {
                        const nominalRange = ranges[i].asUnit(msfsSdk.UnitType.GA_RADIAN);
                        if (nominalRange >= result.range) {
                            this.rangeModule.setNominalRangeIndex(i);
                            break;
                        }
                    }
                    this.previewMap.context.projection.set({ target: result.target });
                }
            }
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedAirport.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedAirport, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'APT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Airport }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-body' },
                        this.previewMap.map,
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-departure-page-selectors' },
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'departure', label: 'DEP', onSelected: this.onDepartureSelected.bind(this), ref: this.departure }),
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'departure-runway', label: 'RUNWAY', onSelected: this.onRunwaySelected.bind(this), ref: this.runways }),
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'departure-transition', label: 'TRANS', onSelected: this.onTransitionSelected.bind(this), ref: this.transitions }),
                            msfsSdk.FSComponent.buildComponent(LoadActivateButton, { class: 'load-or-activate-button-departure', ref: this.loadActivate, showActivate: this.props.gnsType === 'wt530', gnsType: this.props.gnsType, onLoad: this.insertDeparture.bind(this, false), onActivate: this.insertDeparture.bind(this, true) }))))));
        }
    }

    /**
     * menu button popups barebones since no options are selectable in AUX menus
     */
    class WaypointAirportPageMenu extends MenuDefinition {
        /** @inheritdoc */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        constructor(bus, fms, onFacilitySelected = (facility) => undefined) {
            super();
            this.fms = fms;
            this.onFacilitySelected = onFacilitySelected;
            this.hasNoDestinationAirport = msfsSdk.Subject.create(false);
            this.hasNoPlanAirports = msfsSdk.Subject.create(false);
            /** @inheritdoc */
            this.entries = [
                {
                    label: 'Select Next FPL Apt?', disabled: this.hasNoPlanAirports, action: () => {
                        const airport = this.findNextAirportInPlan();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
                {
                    label: 'Select Destination Apt?', disabled: this.hasNoDestinationAirport, action: () => {
                        const airport = this.getDestinationAirport();
                        if (airport !== undefined) {
                            this.onFacilitySelected(airport);
                        }
                        ViewService.back();
                    }
                },
            ];
            this.onPlanChanged = () => {
                let hasNoPlanAirports = true;
                let hasNoDestinationAirport = true;
                if (this.fms.hasPrimaryFlightPlan()) {
                    const plan = this.fms.getPrimaryFlightPlan();
                    hasNoDestinationAirport = (plan.destinationAirport ? false : true);
                    if (plan.destinationAirport) {
                        hasNoPlanAirports = false;
                    }
                    else {
                        for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                            const leg = plan.getLeg(l);
                            if (leg.leg.fixIcao[0] === 'A') {
                                hasNoPlanAirports = false;
                            }
                        }
                    }
                }
                this.hasNoPlanAirports.set(hasNoPlanAirports);
                this.hasNoDestinationAirport.set(hasNoDestinationAirport);
            };
            bus.getSubscriber().on('fplLegChange').handle(this.onPlanChanged);
        }
        /**
         * Finds the next airport in the flight plan
         * @returns a airport facility
         */
        findNextAirportInPlan() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                for (let l = plan.activeLateralLeg; l < plan.length; l++) {
                    const leg = plan.getLeg(l);
                    if (leg.leg.fixIcao[0] === 'A') {
                        facility = leg.leg.fixIcao;
                        break;
                    }
                }
                if (!facility && plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /**
         * Finds the destination airport in the flight plan
         * @returns the destination airport facility
         */
        getDestinationAirport() {
            let facility;
            if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                if (plan.destinationAirport) {
                    facility = plan.destinationAirport;
                }
            }
            return facility;
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * WaypointAirportPage
     */
    class WaypointAirportPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.menu = new WaypointAirportPageMenu(this.props.bus, this.props.fms, (facility) => {
                facility && this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility));
            });
            this.elevationUnit = msfsSdk.Subject.create(msfsSdk.UnitType.FOOT);
            this.facilityName = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________________________';
                }
                const name = Utils.Translate(v.name).toUpperCase();
                return name === '' ? msfsSdk.ICAO.getIdent(v.icao).toUpperCase() : name.substr(0, 20).toUpperCase();
            });
            this.facilityCity = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '________________________';
                }
                const city = v.city.split(', ').map(a => Utils.Translate(a)).join(', ');
                return city === '' ? ' ' : city.substr(0, 20).toUpperCase().toUpperCase();
            });
            this.facilityRegion = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________';
                }
                // airports don't have region codes in their ICAO strings, we will try to grab the code from the first 2
                // letters of the ident. However, some airports (e.g. in the US and those w/o 4-letter idents) don't use the
                // region code for the ident, so we need a third fallback, which is to just display the city name instead.
                const ident = msfsSdk.ICAO.getIdent(v.icao).trim();
                let text = ident.length === 4 ? msfsGarminsdk.Regions.getName(ident.substr(0, 2)) : '';
                if (text === '' && v.city !== '') {
                    text = v.city.split(', ').map(name => Utils.Translate(name)).join(', ');
                }
                if (text) {
                    return text.toUpperCase();
                }
                return '';
            });
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
            this.elevation = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.METER.createNumber(NaN));
            this.fuelType1 = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '';
                }
                return v.fuel1;
            });
            this.fuelType2 = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '';
                }
                return v.fuel2;
            });
            this.approachType = msfsSdk.ComputedSubject.create(undefined, (v) => GnsFmsUtils.getBestApproachTypeString(v, this.props.gnsType === 'wt430'));
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedAirport.sub(this.onAirportSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(airport.icao).trim(), false);
            }
            this.menu.onPlanChanged();
        }
        /**
         * Method to set the display values when the facility changes.
         * @param facility The Facility to load.
         */
        onAirportSelected(facility) {
            this.facilityName.set(facility);
            this.facilityCity.set(facility);
            this.facilityRegion.set(facility);
            this.fuelType1.set(facility);
            this.fuelType2.set(facility);
            this.approachType.set(facility);
            if (facility !== undefined) {
                this.position.set(facility.lat, facility.lon);
                this.elevation.set(facility.runways[0].elevation, msfsSdk.UnitType.METER);
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility.icao).trim(), false);
            }
            else {
                this.elevation.set(NaN);
                this.position.set(NaN, NaN);
            }
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const airport = e.facility;
            this.props.selectedAirport.set(airport);
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.root.instance.triggerEvent(InteractionEvent.RightInnerInc, this.root.instance);
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedAirport.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedAirport, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'APT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Airport }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-location' },
                        msfsSdk.FSComponent.buildComponent("h2", null, this.props.gnsType === 'wt530' ? 'FACILITY, CITY & REGION' : 'FACILITY & CITY NAME'),
                        msfsSdk.FSComponent.buildComponent("div", null,
                            this.facilityName,
                            msfsSdk.FSComponent.buildComponent("br", null),
                            this.facilityCity,
                            msfsSdk.FSComponent.buildComponent("br", null),
                            this.props.gnsType === 'wt530' && this.facilityRegion)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-position' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "POSITION"),
                        msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { location: this.position })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-elev' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "ELEV"),
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 1, forceDecimalZeroes: false, maxDigits: 4, nanString: '____' }), value: this.elevation, displayUnit: this.elevationUnit })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-fuel' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "FUEL"),
                        msfsSdk.FSComponent.buildComponent("div", null,
                            this.fuelType1,
                            this.fuelType2)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-approach' },
                        msfsSdk.FSComponent.buildComponent("h2", null, this.props.gnsType === 'wt530' ? 'APPROACH' : 'APR'),
                        msfsSdk.FSComponent.buildComponent("div", null, this.approachType)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-radar' },
                        msfsSdk.FSComponent.buildComponent("h2", null, "RADAR"),
                        msfsSdk.FSComponent.buildComponent("div", null)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-airport-airspace' },
                        msfsSdk.FSComponent.buildComponent("h2", null, this.props.gnsType === 'wt530' ? 'AIRSPACE' : 'ARSPC'),
                        msfsSdk.FSComponent.buildComponent("div", null)))));
        }
    }

    /**
     * WaypointFrequenciesPage
     */
    class WaypointFrequenciesPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.frequencyListRef = msfsSdk.FSComponent.createRef();
            this.frequenciesUnavailableRef = msfsSdk.FSComponent.createRef();
            this.frequencyList = msfsSdk.ArraySubject.create();
            this.menu = new WaypointAirportPageMenu(this.props.bus, this.props.fms, (facility) => {
                facility && this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility));
            });
            /**
             * Sets the standby com radio frequency.
             * @param facilityFrequency The facility frequency to set to the standby radio frequency.
             */
            this.setStandbyFrequency = (facilityFrequency) => {
                if (facilityFrequency.freqMHz < 118) {
                    SimVar.SetSimVarValue(`K:${this.props.navIndex === 1 ? 'NAV1' : 'NAV2'}_STBY_SET`, 'number', facilityFrequency.freqBCD16);
                }
                else {
                    SimVar.SetSimVarValue(`K:${this.props.comIndex === 1 ? 'COM' : 'COM2'}_STBY_RADIO_SET`, 'number', facilityFrequency.freqBCD16);
                }
            };
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedAirport.sub(this.onAirportSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(airport.icao).trim(), false);
            }
            this.menu.onPlanChanged();
        }
        /**
         * Method to set the display values when the facility changes.
         * @param facility The Facility to load.
         */
        onAirportSelected(facility) {
            this.frequencyList.clear();
            if (facility !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(facility.icao).trim(), false);
            }
            if (facility && facility.frequencies.length > 0) {
                this.frequencyList.insertRange(0, facility.frequencies);
                this.frequenciesUnavailableRef.instance.classList.add('hide-element');
            }
            if (this.frequencyList.length === 0) {
                this.frequenciesUnavailableRef.instance.classList.remove('hide-element');
            }
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const airport = e.facility;
            this.props.selectedAirport.set(airport);
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.root.instance.triggerEvent(InteractionEvent.RightInnerInc, this.root.instance);
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedAirport.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: "page waypoint-page", ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedAirport, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'APT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Airport }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-frequencies-table' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'facility-frequency-unavailable', ref: this.frequenciesUnavailableRef }, "Frequencies Unavailable"),
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { orderBy: (a, b) => GnsFmsUtils.orderFacilityFrequencies(a, b), data: this.frequencyList, renderItem: (data) => msfsSdk.FSComponent.buildComponent(FrequencyListItem, { facilityFrequency: data, onSelected: this.setStandbyFrequency }), ref: this.frequencyListRef, class: '' })))));
        }
    }
    /**
     * A frequency item in the facility frequency list.
     */
    class FrequencyListItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.frequencyRef = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onFocused() {
            this.frequencyRef.instance.classList.add('selected');
        }
        /** @inheritdoc */
        onBlurred() {
            this.frequencyRef.instance.classList.remove('selected');
        }
        /** @inheritdoc */
        onEnt() {
            this.props.onSelected(this.props.facilityFrequency);
            return true;
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'facility-frequency' },
                msfsSdk.FSComponent.buildComponent("div", { class: 'facility-frequency-type' }, GnsFmsUtils.getFacilityFrequencyType(this.props.facilityFrequency)),
                msfsSdk.FSComponent.buildComponent("div", { ref: this.frequencyRef, class: 'facility-frequency-frequency' }, this.props.facilityFrequency.freqMHz.toFixed(3))));
        }
    }

    /**
     * Waypoint intersection page menu button (no options)
     */
    class WaypointIntersectionMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: ' (No Options) ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * WaypointIntersectionPage
     */
    class WaypointIntersectionPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.menu = new WaypointIntersectionMenu();
            this.iconVOR = msfsSdk.FSComponent.createRef();
            this.distanceUnit = msfsSdk.Subject.create(msfsSdk.UnitType.NMILE);
            this.degree = msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE);
            this.rad = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(NaN));
            this.dis = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(NaN));
            this.nearestVOR = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '____';
                }
                return msfsSdk.ICAO.getIdent(v.nearestVorICAO);
            });
            this.facilityCity = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '________________________';
                }
                const city = v.city.split(', ').map(a => Utils.Translate(a)).join(', ');
                return city === '' ? ' ' : city.substr(0, 20).toUpperCase().toUpperCase();
            });
            this.facilityRegion = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________';
                }
                return msfsGarminsdk.Regions.getName(v.icao.substring(1, 3));
            });
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedIntersection.sub(this.onIntersectionSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const intersection = this.props.selectedIntersection.get();
            if (intersection !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(intersection.icao).trim(), false);
            }
        }
        /**
         * gets the nearest vor facility then sets the icon
         * @param icao the icao of the facility
         */
        async setNearestVorIcon(icao) {
            if (!icao) {
                this.iconVOR.instance.src = '';
            }
            else {
                const facility = await this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao);
                if (facility === undefined) {
                    this.iconVOR.instance.src = '';
                }
                else {
                    this.iconVOR.instance.src = Icons.getByFacility(facility).src;
                }
            }
        }
        /**
         * Method to set the display values when the Intersection Facility changes.
         * @param intersection The Facility to load.
         */
        onIntersectionSelected(intersection) {
            this.facilityCity.set(intersection);
            this.facilityRegion.set(intersection);
            if (intersection !== undefined) {
                this.position.set(intersection.lat, intersection.lon);
                this.nearestVOR.set(intersection);
                this.setNearestVorIcon(intersection.nearestVorICAO);
                this.rad.set(intersection.nearestVorMagneticRadial, msfsSdk.UnitType.DEGREE);
                this.dis.set(intersection.nearestVorDistance, msfsSdk.UnitType.METER);
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(intersection.icao).trim(), false);
            }
            else {
                this.nearestVOR.set(undefined);
                this.setNearestVorIcon();
                this.rad.set(NaN);
                this.iconVOR.instance.src = '';
                this.dis.set(NaN);
                this.position.set(NaN, NaN);
            }
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const intersection = e.facility;
            this.props.selectedIntersection.set(intersection);
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.root.instance.triggerEvent(InteractionEvent.RightInnerInc, this.root.instance);
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedIntersection.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedIntersection, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 5, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'INT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Intersection }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-intersection-region' },
                        "REGION",
                        msfsSdk.FSComponent.buildComponent("div", null, this.facilityRegion)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-intersection-position' },
                        "POSITION",
                        msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { location: this.position })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-intersection-nearestvor' },
                        "NEAREST VOR",
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent("div", { style: "width: 40px; display: inline-block;" }, this.nearestVOR),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-icon' },
                                msfsSdk.FSComponent.buildComponent("img", { ref: this.iconVOR })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-intersection-dis-and-rad' },
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-intersection-rad' },
                            msfsSdk.FSComponent.buildComponent("h2", { class: 'waypoint-intersection-rad-span' }, "RAD"),
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 1, pad: 3, forceDecimalZeroes: true, maxDigits: 3, nanString: '___' }), value: this.rad, displayUnit: this.degree })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-intersection-dis' },
                            msfsSdk.FSComponent.buildComponent("h2", { class: 'waypoint-intersection-dis-span' }, "DIS"),
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: -1, forceDecimalZeroes: true, maxDigits: 3, nanString: '__._' }), value: this.dis, displayUnit: this.distanceUnit }))))));
        }
    }

    /**
     * Waypoint ndb page menu button (no options)
     */
    class WaypointNonDirectionalBeaconMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: ' (No Options) ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * The WaypointNonDirectionalBeacon page
     */
    class WaypointNonDirectionalBeaconPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.menu = new WaypointNonDirectionalBeaconMenu();
            this.facilityFrequency = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '____._';
                }
                return '' + v.freqMHz.toFixed(1);
            });
            this.facilityName = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________________________';
                }
                const name = Utils.Translate(v.name).toUpperCase();
                return name === '' ? msfsSdk.ICAO.getIdent(v.icao).toUpperCase() : name.substr(0, 20).toUpperCase();
            });
            this.facilityCity = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '________________________';
                }
                const city = v.city.split(', ').map(a => Utils.Translate(a)).join(', ');
                return city === '' ? ' ' : city.substr(0, 20).toUpperCase().toUpperCase();
            });
            this.facilityRegion = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________';
                }
                return msfsGarminsdk.Regions.getName(v.icao.substring(1, 3));
            });
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedNdb.sub(this.onAirportSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritdoc */
        onResume() {
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const ndb = this.props.selectedNdb.get();
            if (ndb !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(ndb.icao).trim(), false);
            }
            if (this.props.isPopup.get()) {
                this.root.instance.focus(msfsSdk.FocusPosition.Last);
            }
        }
        /**
         * Method to set the display values when the NDB facility changes.
         * @param ndb The Facility to load.
         */
        onAirportSelected(ndb) {
            this.facilityName.set(ndb);
            this.facilityCity.set(ndb);
            this.facilityRegion.set(ndb);
            this.facilityFrequency.set(ndb);
            if (ndb !== undefined) {
                this.position.set(ndb.lat, ndb.lon);
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(ndb.icao).trim(), false);
            }
            else {
                this.facilityFrequency.set(undefined);
                this.position.set(NaN, NaN);
            }
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const ndb = e.facility;
            this.props.selectedNdb.set(ndb);
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.root.instance.triggerEvent(InteractionEvent.RightInnerInc, this.root.instance);
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedNdb.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedNdb, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'NDB', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Ndb }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-ndb-location' },
                        "FACILITY, CITY & REGION",
                        msfsSdk.FSComponent.buildComponent("div", null,
                            this.facilityName,
                            msfsSdk.FSComponent.buildComponent("br", null),
                            this.facilityCity,
                            msfsSdk.FSComponent.buildComponent("br", null),
                            this.facilityRegion)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-ndb-position' },
                        "POSITION",
                        msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { location: this.position })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-ndb-freq' },
                        "FREQ",
                        msfsSdk.FSComponent.buildComponent("div", null, this.facilityFrequency)),
                    this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-ndb-wxbrdcst' },
                        "WX BRDCST",
                        msfsSdk.FSComponent.buildComponent("div", null, "No"))))));
        }
    }

    /**
     * The airport runway page.
     */
    class WaypointRunwayPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.runways = msfsSdk.FSComponent.createRef();
            this.distanceUnit = msfsSdk.Subject.create(msfsSdk.UnitType.FOOT);
            this.runwayLength = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.METER.createNumber(NaN));
            this.runwayWidth = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.METER.createNumber(NaN));
            this.runwaySurface = msfsSdk.ComputedSubject.create(undefined, v => {
                const suffix = this.props.gnsType === 'wt530' ? ' Surface' : '';
                if (v !== undefined) {
                    switch (msfsSdk.RunwayUtils.getSurfaceCategory(v)) {
                        case msfsSdk.RunwaySurfaceCategory.Hard:
                            return `HARD${suffix}`;
                        case msfsSdk.RunwaySurfaceCategory.Soft:
                            return `SOFT${suffix}`;
                        case msfsSdk.RunwaySurfaceCategory.Water:
                            return `WATER${suffix}`;
                        default:
                            return `UNKNOWN${suffix}`;
                    }
                }
                return '';
            });
            this.runwayLighting = msfsSdk.ComputedSubject.create(undefined, v => {
                if (v !== undefined) {
                    switch (v.lighting) {
                        case msfsSdk.RunwayLightingType.FullTime:
                            return 'FULL TIME';
                        case msfsSdk.RunwayLightingType.PartTime:
                            return 'PART TIME';
                        case msfsSdk.RunwayLightingType.Frequency:
                            return 'PILOT CONTROLLED';
                        case msfsSdk.RunwayLightingType.None:
                            return 'NO LIGHTS';
                        default:
                            return '';
                    }
                }
                return '';
            });
            this.AirportMap = GNSMapBuilder
                .withAirportMap(this.props.bus, this.props.settingsProvider, this.props.gnsType, this.props.instrumentIndex)
                .withController(GNSMapKeys.Controller, c => new GNSMapController(c, this.props.settingsProvider, this.props.fms.flightPlanner))
                .build('waypoint-runway-page-map');
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedAirport.sub(this.onAirportSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                this.waypointSelection.instance.setFacility(airport, false);
            }
            this.AirportMap.ref.instance.wake();
        }
        /** @inheritdoc */
        onSuspend() {
            super.onSuspend();
            this.AirportMap.ref.instance.sleep();
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            if (evt === InteractionEvent.RangeIncrease) {
                this.AirportMap.context.getController(GNSMapKeys.Controller).increaseRange();
                return true;
            }
            else if (evt === InteractionEvent.RangeDecrease) {
                this.AirportMap.context.getController(GNSMapKeys.Controller).decreaseRange();
                return true;
            }
            let handled = false;
            if (this.root.instance.isFocused) {
                handled = this.root.instance.onInteractionEvent(evt);
            }
            if (handled) {
                return handled;
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const airport = e.facility;
            this.props.selectedAirport.set(airport);
        }
        /**
         * Handles when a new airport is selected in the page group.
         * @param airport The airport that was selected.
         */
        onAirportSelected(airport) {
            if (airport !== undefined) {
                this.runways.instance.setItems(airport.runways.map(runway => this.buildRunwayName(runway)));
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(airport.icao).trim(), false);
                this.onRunwaySelected(0);
            }
        }
        /**
         * Handles when an runway has been selected for an airport.
         * @param index The index of the approach.
         */
        onRunwaySelected(index) {
            if (index < 0) {
                return;
            }
            const airport = this.props.selectedAirport.get();
            if (airport !== undefined) {
                const runway = airport.runways[index];
                this.runwayLength.set(runway.length, msfsSdk.UnitType.METER);
                this.runwayWidth.set(runway.width, msfsSdk.UnitType.METER);
                this.runwaySurface.set(runway);
                this.runwayLighting.set(runway);
                const airportWaypoint = msfsGarminsdk.GarminFacilityWaypointCache.getCache(this.props.bus).get(airport);
                this.AirportMap.context.getController(GNSMapKeys.Controller).focusAirport(airportWaypoint, index);
            }
            else {
                this.runwayLength.set(NaN);
                this.runwayWidth.set(NaN);
                this.runwaySurface.set(undefined);
                this.runwayLighting.set(undefined);
                this.AirportMap.context.getController(GNSMapKeys.Controller).unfocusAirport();
            }
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.runways.instance.openPopout();
        }
        /**
         * Builds a text based runway name for selection display.
         * @param runway The runway to build the name for.
         * @returns The runway name.
         */
        buildRunwayName(runway) {
            const hypenIndex = runway.designation.indexOf('-');
            let runway1 = runway.designation.substring(0, hypenIndex).trim().padStart(2, '0');
            let runway2 = runway.designation.substring(hypenIndex + 1).trim().padStart(2, '0');
            runway1 += msfsSdk.RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary);
            runway2 += msfsSdk.RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary);
            return runway1 + '-' + runway2;
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedAirport.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedAirport, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'APT', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.Airport }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-page-body' },
                        this.AirportMap.map,
                        msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-runway-page-selectors' },
                            msfsSdk.FSComponent.buildComponent(WaypointPageSelector, { class: 'runway', label: 'RUNWAY', onSelected: this.onRunwaySelected.bind(this), ref: this.runways }),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-runway-page-databox-label' }, "INFO"),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-runway-page-databox', style: "padding-top: 4px" },
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 1, forceDecimalZeroes: false, maxDigits: 5, nanString: '' }), value: this.runwayLength, displayUnit: this.distanceUnit, class: 'waypoint-runway-length' }),
                                msfsSdk.FSComponent.buildComponent("div", { style: 'margin-left: 41px; margin-top: 3px; font-size: 12px; float: left;' }, "X"),
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: msfsSdk.NumberFormatter.create({ precision: 1, forceDecimalZeroes: false, maxDigits: 3, nanString: '' }), value: this.runwayWidth, displayUnit: this.distanceUnit, class: 'waypoint-runway-width' }),
                                this.props.gnsType === 'wt430' && (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                                    msfsSdk.FSComponent.buildComponent("span", { class: "waypoint-runway-surface-type" }, this.runwaySurface),
                                    msfsSdk.FSComponent.buildComponent("span", { class: "waypoint-runway-lighting" }, this.runwayLighting)))),
                            this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                                msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-runway-page-databox', style: 'padding-left: 18px; padding-top: 4px; word-break: break-word; line-height: 15px; text-indent: -15px;' }, this.runwaySurface),
                                msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-runway-page-databox', style: "padding-left: 0; padding-right: 0; padding-top: 4px; white-space: nowrap;" }, this.runwayLighting))))))));
        }
    }

    /**
     * Waypoint usr page menu button
     */
    class WaypointUsrPageMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: ' View User Waypoint List? ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
                { label: ' Delete User Waypoint? ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
                { label: ' Crossfill? ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * WaypointUsrPage
     */
    class WaypointUsrPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.menu = new WaypointUsrPageMenu();
            this.distanceUnit = msfsSdk.Subject.create(msfsSdk.UnitType.NMILE);
            this.angleUnit = msfsSdk.Subject.create(msfsSdk.UnitType.DEGREE);
            this.rad1 = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(0));
            this.rad2 = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.DEGREE.createNumber(0));
            this.dis = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(0));
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
            this.refWpt1 = msfsSdk.FSComponent.createRef();
            this.refWpt2 = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedUsr.sub(this.onUsrSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const intersection = this.props.selectedUsr.get();
            if (intersection !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(intersection.icao).trim(), false);
            }
        }
        /**
         * Method to set the display values when the usr facility changes.
         * @param usr The Facility to load.
         */
        onUsrSelected(usr) {
            if (usr !== undefined) {
                this.position.set(usr.lat, usr.lon);
                if (usr.reference1Radial !== undefined) ;
                else {
                    this.rad1.set(0);
                }
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(usr.icao).trim(), false);
            }
            else {
                this.rad1.set(0);
                //this.dis.set(NaN);
                this.position.set(NaN, NaN);
            }
        }
        /**
         * Callback to render an inactive value.
         * @param value The value to display.
         * @param unit The display unit of the value.
         * @returns a VNODE to render.
         */
        renderInactiveValue(value, unit) {
            return (msfsSdk.FSComponent.buildComponent("div", null,
                value,
                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: unit })));
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const usr = e.facility;
            this.props.selectedUsr.set(usr);
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.root.instance.triggerEvent(InteractionEvent.RightInnerInc, this.root.instance);
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedUsr.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedUsr, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 5, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'USR', ref: this.waypointSelection, gnsType: this.props.gnsType, filter: msfsSdk.FacilitySearchType.User }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-runway-page-selectors' }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-usr-ref-wpt-1' },
                        "REF WPT",
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent(WaypointSelection, { class: 'waypoint-page-ident-input', onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), length: 5, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, ref: this.refWpt1, gnsType: this.props.gnsType }))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-usr-rad-1' },
                        "RAD",
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.rad1, displayUnit: this.angleUnit, digitizer: (value, signValues, digitValues) => {
                                    digitValues[0].set(Math.floor(value / 1000));
                                    digitValues[1].set(Math.floor((value % 1000) / 100));
                                    digitValues[2].set(Math.floor((value % 100) / 10));
                                    digitValues[3].set(Math.floor((value % 10) / 1));
                                }, editOnActivate: false, class: '', renderInactiveValue: (value) => {
                                    return this.renderInactiveValue(value.toFixed(0), this.angleUnit);
                                }, onInputAccepted: (v) => {
                                    this.rad1.set(v, this.angleUnit.get());
                                } },
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 4, increment: 1, scale: 1000, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 7, increment: 1, scale: 100, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                                msfsSdk.FSComponent.buildComponent("span", null, "."),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-usr-dis-1' },
                        "DIS",
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.dis, displayUnit: this.distanceUnit, digitizer: (value, signValues, digitValues) => {
                                    digitValues[0].set(Math.floor(value / 1000));
                                    digitValues[1].set(Math.floor((value % 1000) / 100));
                                    digitValues[2].set(Math.floor((value % 100) / 10));
                                    digitValues[3].set(Math.floor((value % 10) / 1));
                                }, editOnActivate: false, class: '', renderInactiveValue: (value) => {
                                    return this.renderInactiveValue(value.toFixed(0), this.distanceUnit);
                                }, onInputAccepted: (v) => {
                                    this.dis.set(v, this.distanceUnit.get());
                                } },
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                                msfsSdk.FSComponent.buildComponent("span", null, "."),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.distanceUnit })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-usr-ref-wpt-2' },
                        msfsSdk.FSComponent.buildComponent(WaypointSelection, { class: 'waypoint-page-ident-input', onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), length: 5, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, ref: this.refWpt2, gnsType: this.props.gnsType })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-usr-rad-2' },
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.rad2, displayUnit: this.angleUnit, digitizer: (value, signValues, digitValues) => {
                                    digitValues[0].set(Math.floor((value / 100)));
                                    digitValues[1].set(Math.floor((value % 100) / 10));
                                    digitValues[2].set(Math.floor((value % 10)));
                                }, editOnActivate: false, class: '', renderInactiveValue: (value) => {
                                    return this.renderInactiveValue(value.toFixed(0), this.angleUnit);
                                }, onInputAccepted: (v) => {
                                    this.rad2.set(v, this.angleUnit.get());
                                } },
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 4, increment: 1, scale: 1000, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 7, increment: 1, scale: 100, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                                msfsSdk.FSComponent.buildComponent("span", null, "."),
                                msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.angleUnit })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-usr-position' },
                        "POSITION",
                        msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { location: this.position })))));
        }
    }

    /**
     * Waypoint vor page menu button (no options)
     */
    class WaypointVorPageMenu extends MenuDefinition {
        constructor() {
            super(...arguments);
            this.entries = [
                { label: ' (No Options) ', disabled: msfsSdk.Subject.create(true), action: () => undefined },
            ];
        }
        /** @inheritdoc */
        updateEntries() {
            //nothing needs to be here?
        }
    }

    /**
     * The WaypointVorPage page
     */
    class WaypointVorPage extends WaypointPage {
        constructor() {
            super(...arguments);
            this.menu = new WaypointVorPageMenu();
            this.magvar = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '____°';
                }
                if (v.magneticVariation > 180) {
                    const magV = v.magneticVariation * -1;
                    const magVarCorrected = ((magV + 540) % 360 - 180);
                    return 'E' + (Math.abs(magVarCorrected)).toFixed(0).padStart(3, '0') + '°';
                }
                else {
                    const magV = 360 - v.magneticVariation;
                    const magVarCorrected = ((magV + 540) % 360 - 180);
                    return 'W' + (Math.abs(magVarCorrected)).toFixed(0).padStart(3, '0') + '°';
                }
            });
            this.facilityFrequency = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '____._';
                }
                return '' + v.freqMHz.toFixed(2);
            });
            this.facilityName = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________________________';
                }
                const name = Utils.Translate(v.name).toUpperCase();
                return name === '' ? msfsSdk.ICAO.getIdent(v.icao).toUpperCase() : name.substr(0, 20).toUpperCase();
            });
            this.facilityCity = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '________________________';
                }
                const city = v.city.split(', ').map(a => Utils.Translate(a)).join(', ');
                return city === '' ? ' ' : city.substr(0, 20).toUpperCase().toUpperCase();
            });
            this.facilityRegion = msfsSdk.ComputedSubject.create(undefined, (v) => {
                if (v === undefined) {
                    return '__________';
                }
                return msfsGarminsdk.Regions.getName(v.icao.substring(1, 3));
            });
            this.position = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(NaN, NaN));
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.selectedVor.sub(this.onVorSelected.bind(this), true);
            this.onSuspend();
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.el.instance.classList.remove('hide-element');
            this.active = true;
            const vor = this.props.selectedVor.get();
            if (vor !== undefined) {
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(vor.icao).trim(), false);
            }
        }
        /**
         * Method to set the display values when the vor facility changes.
         * @param vor The Facility to load.
         */
        onVorSelected(vor) {
            this.facilityName.set(vor);
            this.facilityCity.set(vor);
            this.facilityRegion.set(vor);
            this.facilityFrequency.set(vor);
            if (vor !== undefined) {
                this.position.set(vor.lat, vor.lon);
                this.waypointSelection.instance.setIdent(msfsSdk.ICAO.getIdent(vor.icao).trim(), false);
                this.magvar.set(vor);
            }
            else {
                this.facilityFrequency.set(undefined);
                this.position.set(NaN, NaN);
                this.magvar.set(undefined);
            }
        }
        /**
         * Handles when the input waypoint is changed.
         * @param e The waypoint change event to process.
         */
        onWaypointChanged(e) {
            const vor = e.facility;
            this.props.selectedVor.set(vor);
        }
        /**
         * Handles when waypoint input is finalized.
         */
        onWaypointFinalized() {
            this.waypointSelection.instance.focusSelf();
            this.root.instance.scroll('forward');
            this.root.instance.triggerEvent(InteractionEvent.RightInnerInc, this.root.instance);
        }
        /**
         * renders the Wx brodcast if its on the 430 or the 530
         * @returns the div that holds the content
         */
        renderWxbrdcst() {
            if (this.props.gnsType === 'wt430') {
                return (msfsSdk.FSComponent.buildComponent("div", null));
            }
            else {
                return (msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-vor-wxbrdcst' },
                    "WX BRDCST",
                    msfsSdk.FSComponent.buildComponent("div", null, "No")));
            }
        }
        /** @inheritDoc */
        onDirectPressed() {
            const facility = this.props.selectedVor.get();
            if (facility !== undefined) {
                ViewService.directToDialogWithIcao(facility.icao);
                return true;
            }
            else {
                return false;
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'page waypoint-page', ref: this.el },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent(WaypointPageIdentInput, { selectedFacility: this.props.selectedVor, onChanged: this.onWaypointChanged.bind(this), onFinalized: this.onWaypointFinalized.bind(this), onPopupDonePressed: this.props.onPopupDonePressed, showDoneButton: this.props.isPopup, length: 4, ppos: this.props.ppos, facilityLoader: this.props.fms.facLoader, title: 'VOR', ref: this.waypointSelection, filter: msfsSdk.FacilitySearchType.Vor, gnsType: this.props.gnsType }),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-vor-location' },
                        "FACILITY, CITY & REGION",
                        msfsSdk.FSComponent.buildComponent("div", null,
                            this.facilityName,
                            msfsSdk.FSComponent.buildComponent("br", null),
                            this.facilityCity,
                            msfsSdk.FSComponent.buildComponent("br", null),
                            this.facilityRegion)),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-vor-position' },
                        "POSITION",
                        msfsSdk.FSComponent.buildComponent(msfsSdk.LatLonDisplay, { location: this.position })),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-vor-freq' },
                        "FREQ",
                        msfsSdk.FSComponent.buildComponent("div", null, this.facilityFrequency)),
                    this.renderWxbrdcst(),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'waypoint-vor-var' },
                        msfsSdk.FSComponent.buildComponent("span", null, "VAR"),
                        msfsSdk.FSComponent.buildComponent("div", null, this.magvar)))));
        }
    }

    /**
     * A page group for the WPT GNS pages.
     */
    class WaypointPageGroup extends PageGroup {
        constructor() {
            super(...arguments);
            this.FacilityTypeToPageMap = {
                [msfsSdk.FacilityType.Airport]: 0,
                [msfsSdk.FacilityType.Intersection]: 6,
                [msfsSdk.FacilityType.NDB]: 7,
                [msfsSdk.FacilityType.VOR]: 8,
                [msfsSdk.FacilityType.USR]: 9,
            };
            this.airport = msfsSdk.Subject.create(undefined);
            this.intersection = msfsSdk.Subject.create(undefined);
            this.vor = msfsSdk.Subject.create(undefined);
            this.ndb = msfsSdk.Subject.create(undefined);
            this.user = msfsSdk.Subject.create(undefined);
            this.ppos = msfsSdk.GeoPointSubject.create(new msfsSdk.GeoPoint(0, 0));
            /**
             * Whether this page was shown from an external interaction, e.g. selecting an airport on the NEAREST AIRPORT page
             */
            this.isPopup = msfsSdk.Subject.create(false);
        }
        /**
         * Called when a facility FS ICAO is selected by another page
         *
         * @param icao         the airport's FS ICAO
         * @param facilityType the facility type
         */
        async handleFacilityRemotelySelected(icao, facilityType) {
            const facility = await this.props.fms.facLoader.getFacility(facilityType, icao);
            this.isPopup.set(true);
            // Navigate to page associated with the facility type
            this.setPage(this.FacilityTypeToPageMap[facilityType]);
            switch (facilityType) {
                case msfsSdk.FacilityType.Airport:
                    this.airport.set(facility);
                    break;
                case msfsSdk.FacilityType.Intersection:
                    this.intersection.set(facility);
                    break;
                case msfsSdk.FacilityType.VOR:
                    this.vor.set(facility);
                    break;
                case msfsSdk.FacilityType.NDB:
                    this.ndb.set(facility);
                    break;
                case msfsSdk.FacilityType.USR:
                    this.user.set(facility);
                    break;
                default:
                    throw new Error('Unsupported facility type: ' + facilityType);
            }
        }
        /** @inheritDoc */
        suspend() {
            super.suspend();
            this.isPopup.set(false);
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            let attempts = 60;
            const scan = () => {
                if (attempts > 0) {
                    try {
                        const nearestContext = msfsSdk.NearestContext.getInstance();
                        this.airport.set(nearestContext.getNearest(msfsSdk.FacilityType.Airport));
                        this.intersection.set(nearestContext.getNearest(msfsSdk.FacilityType.Intersection));
                        this.vor.set(nearestContext.getNearest(msfsSdk.FacilityType.VOR));
                        this.ndb.set(nearestContext.getNearest(msfsSdk.FacilityType.NDB));
                    }
                    catch (err) {
                        setTimeout(scan, 1000);
                    }
                    if (this.airport.get() === undefined || this.intersection.get() === undefined
                        || this.vor.get() === undefined || this.ndb.get() === undefined) {
                        setTimeout(scan, 1000);
                    }
                    attempts--;
                }
            };
            scan();
            this.props.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
            // Handle events for external selections of facilities
            this.props.bus.getSubscriber()
                .on('gns_nearest_pages_select_wpt_apt')
                .handle((icao) => this.handleFacilityRemotelySelected(icao, msfsSdk.FacilityType.Airport));
            this.props.bus.getSubscriber()
                .on('gns_nearest_pages_select_wpt_int')
                .handle((icao) => this.handleFacilityRemotelySelected(icao, msfsSdk.FacilityType.Intersection));
            this.props.bus.getSubscriber()
                .on('gns_nearest_pages_select_wpt_ndb')
                .handle((icao) => this.handleFacilityRemotelySelected(icao, msfsSdk.FacilityType.NDB));
            this.props.bus.getSubscriber()
                .on('gns_nearest_pages_select_wpt_vor')
                .handle((icao) => this.handleFacilityRemotelySelected(icao, msfsSdk.FacilityType.VOR));
            this.props.bus.getSubscriber()
                .on('gns_nearest_pages_select_wpt_usr')
                .handle((icao) => this.handleFacilityRemotelySelected(icao, msfsSdk.FacilityType.USR));
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(WaypointAirportPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedAirport: this.airport, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(WaypointRunwayPage, { bus: this.props.bus, settingsProvider: this.props.settingsProvider, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedAirport: this.airport, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(WaypointFrequenciesPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, fms: this.props.fms, ppos: this.ppos, selectedAirport: this.airport, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed, comIndex: this.props.options.comIndex, navIndex: this.props.options.navIndex }),
                msfsSdk.FSComponent.buildComponent(ProcApproachPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedAirport: this.airport, settingsProvider: this.props.settingsProvider, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(ProcArrivalPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedAirport: this.airport, settingsProvider: this.props.settingsProvider, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(ProcDeparturePage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedAirport: this.airport, settingsProvider: this.props.settingsProvider, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(WaypointIntersectionPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedIntersection: this.intersection, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(WaypointNonDirectionalBeaconPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedNdb: this.ndb, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(WaypointVorPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedVor: this.vor, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed }),
                msfsSdk.FSComponent.buildComponent(WaypointUsrPage, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, selectedUsr: this.user, ppos: this.ppos, fms: this.props.fms, isPopup: this.isPopup, onPopupDonePressed: this.props.onPopupDonePressed })));
        }
    }

    /**
     * VNAV Page
     */
    class VnavPage extends Page {
        constructor() {
            super(...arguments);
            this.root = msfsSdk.FSComponent.createRef();
            this.targetAltitudeModeSelectorRef = msfsSdk.FSComponent.createRef();
            this.targetAltitudeModeDialogRef = msfsSdk.FSComponent.createRef();
            this.refLegSelectorRef = msfsSdk.FSComponent.createRef();
            this.refLegDialogRef = msfsSdk.FSComponent.createRef();
            this.refModeSelectorRef = msfsSdk.FSComponent.createRef();
            this.refModeDialogRef = msfsSdk.FSComponent.createRef();
            this.unitsSettingsManager = msfsGarminsdk.UnitsUserSettings.getManager(this.props.bus);
            this.gnsVnavSettingsManager = GnsVnavSettingsManager.getManager(this.props.bus);
            this.vnavCanBeUsed = msfsSdk.Subject.create(false);
            this.aglSupportedForCurrentLeg = msfsSdk.Subject.create(false);
            this.targetAltitudeModeSelectionEnabled = msfsSdk.MappedSubject.create(([vnavCanBeUsed, aglSupportForCurrentLeg]) => vnavCanBeUsed && aglSupportForCurrentLeg, this.vnavCanBeUsed, this.aglSupportedForCurrentLeg);
            this.refModeConstrainedForCurrentLeg = msfsSdk.Subject.create(false);
            this.refModeSelectionEnabled = msfsSdk.MappedSubject.create(([vnavCanBeUsed, refModeConstrainedForCurrentLeg]) => vnavCanBeUsed && !refModeConstrainedForCurrentLeg, this.vnavCanBeUsed, this.refModeConstrainedForCurrentLeg);
            this.anyLegsAvailable = msfsSdk.Subject.create(false);
            this.targetAltitudeSetting = this.gnsVnavSettingsManager.getSetting('target_altitude');
            this.targetAltitudeModeSetting = this.gnsVnavSettingsManager.getSetting('target_altitude_mode');
            this.refDistanceSetting = this.gnsVnavSettingsManager.getSetting('ref_distance');
            this.refModeSetting = this.gnsVnavSettingsManager.getSetting('ref_mode');
            this.refLegIndexSetting = this.gnsVnavSettingsManager.getSetting('ref_leg_index');
            this.vsProfileSetting = this.gnsVnavSettingsManager.getSetting('profile_vs');
            this.messagesOnSetting = this.gnsVnavSettingsManager.getSetting('messages_on');
            this.targetAltitudeNumberUnit = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FOOT.createNumber(0));
            this.refDistanceNumberUnit = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.NMILE.createNumber(0));
            this.vsProfileNumberUnit = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FPM.createNumber(0));
            this.vsRequired = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.FPM.createNumber(0));
            this.availableLegs = [];
            this.targetAltitudeModeText = msfsSdk.Subject.create('');
            this.refModeText = msfsSdk.Subject.create('');
            this.refLegText = msfsSdk.Subject.create('');
            this.statusText = msfsSdk.Subject.create('');
            this.statusValue = msfsSdk.Subject.create('');
            this.menu = new VnavPageMenu(this.messagesOnSetting, () => this.messagesOnSetting.set(!this.messagesOnSetting.get()), () => this.gnsVnavSettingsManager.getAllSettings().forEach((setting) => setting.resetToDefault()));
        }
        /** @inheritDoc */
        onResume() {
            super.onResume();
            this.root.instance.blur();
        }
        /** @inheritDoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.targetAltitudeModeDialogRef.instance.setItems([
                'Above Wpt',
                'MSL',
            ], false);
            this.refModeDialogRef.instance.setItems([
                'Before',
                'After',
            ], false);
            this.handleClosePopup(this.targetAltitudeModeDialogRef);
            this.handleClosePopup(this.refModeDialogRef);
            this.handleClosePopup(this.refLegDialogRef);
            this.setupNumberUnitSubject(this.targetAltitudeSetting, msfsSdk.UnitType.FOOT, this.targetAltitudeNumberUnit, this.unitsSettingsManager.altitudeUnits);
            this.setupNumberUnitSubject(this.refDistanceSetting, msfsSdk.UnitType.NMILE, this.refDistanceNumberUnit, this.unitsSettingsManager.distanceUnitsLarge);
            this.setupNumberUnitSubject(this.vsProfileSetting, msfsSdk.UnitType.FPM, this.vsProfileNumberUnit, this.unitsSettingsManager.verticalSpeedUnits);
            this.targetAltitudeModeSetting.sub((value) => {
                this.targetAltitudeModeText.set(value === GnsVnavTargetAltitudeMode.Msl ? 'MSL' : 'Above Wpt');
            }, true);
            this.refModeSetting.sub((value) => {
                this.refModeText.set(value === GnsVnavRefMode.Before ? 'Before' : 'After');
            }, true);
            this.vnavCanBeUsed.sub(() => this.refLegText.set(this.calculateRefLegText()));
            this.refLegIndexSetting.sub(() => this.refLegText.set(this.calculateRefLegText()));
            const sub = this.props.bus.getSubscriber();
            sub.on('gnsvnav_has_input_data').whenChanged().handle((canBeUsed) => {
                this.vnavCanBeUsed.set(canBeUsed);
            });
            sub.on('gnsvnav_agl_available').whenChanged().handle((isAvailable) => {
                this.aglSupportedForCurrentLeg.set(isAvailable);
            });
            sub.on('gnsvnav_forced_ref_mode').whenChanged().handle((forcedRefMode) => {
                if (forcedRefMode === null) {
                    this.refModeConstrainedForCurrentLeg.set(false);
                }
                else {
                    this.refModeConstrainedForCurrentLeg.set(true);
                }
            });
            sub.on('gnsvnav_available_ref_legs').whenChanged().handle((legs) => {
                this.handleNewLegsAvailable(legs);
            });
            this.handleNewLegsAvailable([]);
            sub.on('gnsvnav_vsr').whenChanged().handle((vsr) => {
                this.vsRequired.set(vsr, this.unitsSettingsManager.verticalSpeedUnits.get());
            });
            sub.on('gnsvnav_status').whenChanged().handle((data) => {
                if (data) {
                    const [type, value] = data;
                    switch (type) {
                        case GnsVnavStatusType.BeginDescentIn: {
                            const formattedTime = Utils.SecondsToDisplayDuration(value, true, true, false);
                            this.statusText.set('Begin Descent in');
                            this.statusValue.set(formattedTime);
                            break;
                        }
                        case GnsVnavStatusType.DescendToTarget: {
                            this.statusText.set('Descend to target');
                            this.statusValue.set('');
                            break;
                        }
                        default:
                            this.statusText.set('');
                            this.statusValue.set('');
                    }
                }
            });
            // Hook up target altitude mode selection enabled
            this.targetAltitudeModeSelectionEnabled.sub((enabled) => {
                this.targetAltitudeModeSelectorRef.instance.setDisabled(!enabled);
            }, true);
            // Hook up ref mode selection enabled
            this.refModeSelectionEnabled.sub((enabled) => {
                this.refModeSelectorRef.instance.setDisabled(!enabled);
            }, true);
            // Hook up ref leg selection enabled
            this.anyLegsAvailable.sub((enabled) => {
                this.refLegSelectorRef.instance.setDisabled(!enabled);
            }, true);
        }
        /**
         * Sets up for keeping a user setting, a number unit subject, and a unit subject in sync
         *
         * @param setting              the setting to get values from
         * @param settingCanonicalUnit the canonical unit of the setting to get values from
         * @param numberUnitSub        the number unit subject
         * @param unitSettingSub       a subscription to the unit to use for the number unit subject
         */
        setupNumberUnitSubject(setting, settingCanonicalUnit, numberUnitSub, unitSettingSub) {
            setting.sub((value) => {
                const converted = unitSettingSub.get().convertFrom(value, settingCanonicalUnit);
                numberUnitSub.set(converted);
            }, true);
            unitSettingSub.sub((unit) => {
                const currentValue = numberUnitSub.get();
                const converted = unit.convertFrom(currentValue.number, currentValue.unit);
                numberUnitSub.set(unit.createNumber(converted));
            }, true);
        }
        /**
         * Handles new possible legs being recieved from the controller
         *
         * @param legs the available legs
         */
        handleNewLegsAvailable(legs) {
            // TODO this is called too often
            this.availableLegs.length = 0;
            this.availableLegs.push(...legs);
            this.anyLegsAvailable.set(legs.length > 0);
            this.refLegText.set(this.calculateRefLegText());
            this.refLegDialogRef.instance.setItems(legs.map((it) => it.ident), false);
        }
        /**
         * Figure out the ref leg text to be displayed
         *
         * @returns string
         */
        calculateRefLegText() {
            var _a;
            const vnavCanBeUsed = this.vnavCanBeUsed.get();
            const refLegIndex = this.refLegIndexSetting.get();
            if (!vnavCanBeUsed || refLegIndex === -1 || !this.anyLegsAvailable.get()) {
                return '_____';
            }
            const matching = this.availableLegs.find((leg) => leg.index === refLegIndex);
            // If there is no matching leg found, the index wasn't -1 and there are still available legs,
            // we return the same value as was previously set. This replicates trainer behaviour, where the
            // previously used leg's ident remains even after the lag was passed.
            return (_a = matching === null || matching === void 0 ? void 0 : matching.ident) !== null && _a !== void 0 ? _a : this.refLegText.get();
        }
        /** @inheritDoc */
        onInteractionEvent(evt) {
            if (this.targetAltitudeModeDialogRef.instance.isFocused) {
                const handled = this.targetAltitudeModeDialogRef.instance.onInteractionEvent(evt);
                if (handled) {
                    return true;
                }
            }
            if (this.refLegDialogRef.instance.isFocused) {
                const handled = this.refLegDialogRef.instance.onInteractionEvent(evt);
                if (handled) {
                    return true;
                }
            }
            if (this.refModeDialogRef.instance.isFocused) {
                const handled = this.refModeDialogRef.instance.onInteractionEvent(evt);
                if (handled) {
                    return true;
                }
            }
            if (evt === InteractionEvent.RightKnobPush) {
                if (this.root.instance.isFocused) {
                    this.root.instance.blur();
                }
                else {
                    this.root.instance.focus(msfsSdk.FocusPosition.First);
                }
                return true;
            }
            if (evt === InteractionEvent.VNAV) {
                ViewService.back();
                return true;
            }
            if (evt === InteractionEvent.MENU) {
                ViewService.menu(this.menu);
                return true;
            }
            if (this.root.instance.isFocused) {
                const handled = this.root.instance.onInteractionEvent(evt);
                if (handled) {
                    return true;
                }
            }
            return super.onInteractionEvent(evt);
        }
        /**
         * Handles opening a popup
         *
         * @param popup the popup to open
         *
         * @returns true
         */
        handleOpenPopup(popup) {
            this.root.instance.blur();
            popup.instance.openPopout(0);
            popup.instance.focus(msfsSdk.FocusPosition.First);
            return true;
        }
        /**
         * Handles closing a popup
         *
         * @param popup the popup to close
         *
         * @returns true
         */
        handleClosePopup(popup) {
            popup.instance.closePopout();
            popup.instance.blur();
            this.root.instance.focus(msfsSdk.FocusPosition.MostRecent);
            return true;
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { ref: this.el, id: "vnav-page", class: "page hide-element" },
                msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                    msfsSdk.FSComponent.buildComponent("h2", { class: "page-header" }, "VERTICAL NAVIGATION"),
                    msfsSdk.FSComponent.buildComponent("div", { class: "vnav-page-target-altitude" },
                        msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "TARGET ALTITUDE"),
                        msfsSdk.FSComponent.buildComponent("div", { class: "databox full-width" },
                            msfsSdk.FSComponent.buildComponent("div", { class: "vnav-page-entry-altitude-value-container" },
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.targetAltitudeNumberUnit, displayUnit: this.unitsSettingsManager.altitudeUnits, digitizer: (value, signValues, digitValues) => {
                                        digitValues[0].set(Math.floor(value / 10000) * 10000);
                                        digitValues[1].set(Math.floor(value % 10000 / 1000) * 1000);
                                        digitValues[2].set(Math.floor(value % 1000 / 100) * 100);
                                        digitValues[3].set(Math.floor(value % 100 / 10) * 10);
                                        digitValues[4].set(Math.floor(value % 10));
                                    }, editOnActivate: false, activateOnClr: true, class: 'vnav-page-entry-altitude-value', renderInactiveValue: (value) => (msfsSdk.FSComponent.buildComponent("div", null,
                                        value.toFixed(0),
                                        msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.altitudeUnits }))), onInputAccepted: (v) => {
                                        const converted = this.unitsSettingsManager.altitudeUnits.get().convertTo(v, msfsSdk.UnitType.FOOT);
                                        this.targetAltitudeSetting.set(converted);
                                    } },
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10000, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.altitudeUnits }))),
                            msfsSdk.FSComponent.buildComponent("span", { class: "vnav-page-entry-altitude-type" },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.targetAltitudeModeSelectorRef, data: this.targetAltitudeModeText, onRightInnerDec: this.handleOpenPopup.bind(this, this.targetAltitudeModeDialogRef), onRightInnerInc: this.handleOpenPopup.bind(this, this.targetAltitudeModeDialogRef) })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: "vnav-page-target-position" },
                        msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "TARGET POSITION"),
                        msfsSdk.FSComponent.buildComponent("div", { class: "databox full-width" },
                            msfsSdk.FSComponent.buildComponent("div", { class: "vnav-page-entry-position-distance-value-container" },
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.refDistanceNumberUnit, displayUnit: this.unitsSettingsManager.distanceUnitsLarge, digitizer: (value, signValues, digitValues) => {
                                        const scaled = value * 10;
                                        // The value is encoded as a three-digit integer, so we manually extract here
                                        const fixedValue = Array.from(scaled.toFixed(0));
                                        if (fixedValue.length === 3) {
                                            const digitOne = parseInt(fixedValue[0]);
                                            const digitTwo = parseInt(fixedValue[1]);
                                            const digitThree = parseInt(fixedValue[2]);
                                            digitValues[0].set(digitOne * 100);
                                            digitValues[1].set(digitTwo * 10);
                                            digitValues[2].set(digitThree);
                                        }
                                        else if (fixedValue.length === 2) {
                                            const digitOne = parseInt(fixedValue[0]);
                                            const digitTwo = parseInt(fixedValue[1]);
                                            digitValues[0].set(0);
                                            digitValues[1].set(digitOne * 10);
                                            digitValues[2].set(digitTwo);
                                        }
                                    }, editOnActivate: false, activateOnClr: true, class: 'vnav-page-entry-position-distance-value', renderInactiveValue: (value) => (msfsSdk.FSComponent.buildComponent("div", null,
                                        (value / 10).toFixed(1),
                                        msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.distanceUnitsLarge }))), onInputAccepted: (v) => {
                                        const scaled = v / 10;
                                        const converted = this.unitsSettingsManager.distanceUnitsLarge.get().convertTo(scaled, msfsSdk.UnitType.NMILE);
                                        this.refDistanceSetting.set(converted);
                                    } },
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent("span", null, "."),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.distanceUnitsLarge }))),
                            msfsSdk.FSComponent.buildComponent("span", { class: "vnav-page-entry-position-distance-type" },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.refModeSelectorRef, data: this.refModeText, onRightInnerDec: this.handleOpenPopup.bind(this, this.refModeDialogRef), onRightInnerInc: this.handleOpenPopup.bind(this, this.refModeDialogRef) })),
                            msfsSdk.FSComponent.buildComponent("span", { class: "vnav-page-entry-position-distance-ref" },
                                msfsSdk.FSComponent.buildComponent(SelectableText, { ref: this.refLegSelectorRef, data: this.refLegText, onRightInnerDec: this.handleOpenPopup.bind(this, this.refLegDialogRef), onRightInnerInc: this.handleOpenPopup.bind(this, this.refLegDialogRef) })))),
                    msfsSdk.FSComponent.buildComponent("div", { id: "vnav-page-vs", class: "vnav-vs-profile-vsr" },
                        msfsSdk.FSComponent.buildComponent("div", { style: "width: 41%" },
                            msfsSdk.FSComponent.buildComponent("h2", { class: "cyan vnav-page-vs-profile" }, "VS PROFILE"),
                            msfsSdk.FSComponent.buildComponent("div", { class: "vnav-page-entry-vs-profile-container databox full-width" },
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitInput, { data: this.vsProfileNumberUnit, displayUnit: this.unitsSettingsManager.verticalSpeedUnits, digitizer: (value, signValues, digitValues) => {
                                        digitValues[0].set(Math.floor(Math.abs(value) / 1000) * 1000);
                                        digitValues[1].set(Math.floor(Math.abs(value) % 1000 / 100) * 100);
                                        digitValues[2].set(Math.floor(Math.abs(value) % 100 / 10) * 10);
                                        digitValues[3].set(Math.floor(Math.abs(value) % 10));
                                    }, editOnActivate: false, activateOnClr: true, class: 'vnav-page-entry-vs-profile', renderInactiveValue: (value) => (msfsSdk.FSComponent.buildComponent("div", null,
                                        value.toFixed(0),
                                        msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.verticalSpeedUnits }))), onInputAccepted: (v) => {
                                        const converted = this.unitsSettingsManager.distanceUnitsLarge.get().convertTo(v, msfsSdk.UnitType.NMILE);
                                        this.vsProfileSetting.set(converted);
                                    } },
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1000, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 100, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 10, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSDigitInput, { value: msfsSdk.Subject.create(0), minValue: 0, maxValue: 10, increment: 1, scale: 1, wrap: true }),
                                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.verticalSpeedUnits })))),
                        msfsSdk.FSComponent.buildComponent("div", { style: "width: 41%" },
                            msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "VSR"),
                            msfsSdk.FSComponent.buildComponent("div", { class: "databox full-width" },
                                msfsSdk.FSComponent.buildComponent("div", { class: "vnav-page-entry-vs-required" },
                                    this.vsRequired.map((it) => {
                                        if (it.number === Number.MAX_SAFE_INTEGER) {
                                            return '_____';
                                        }
                                        else {
                                            return it.number.toFixed(0);
                                        }
                                    }),
                                    msfsSdk.FSComponent.buildComponent(GNSVerticalUnitDisplay, { unit: this.unitsSettingsManager.verticalSpeedUnits }))))),
                    this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent("div", { style: "margin-top: 13px;" },
                        msfsSdk.FSComponent.buildComponent("h2", { class: "cyan" }, "STATUS"),
                        msfsSdk.FSComponent.buildComponent("div", { class: "databox full-width vnav-page-status-container" },
                            msfsSdk.FSComponent.buildComponent("span", null, this.statusText),
                            msfsSdk.FSComponent.buildComponent("span", null, this.statusValue))))),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.targetAltitudeModeDialogRef, class: "vnav-page-ref-target-altitude-mode-dialog", label: "REFERENCE", onSelected: (index) => {
                        this.targetAltitudeModeSetting.set(index === 0 ? GnsVnavTargetAltitudeMode.Agl : GnsVnavTargetAltitudeMode.Msl);
                        this.handleClosePopup(this.targetAltitudeModeDialogRef);
                    } }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.refLegDialogRef, class: "vnav-page-ref-leg-dialog", label: "WAYPOINT", onSelected: (index) => {
                        this.refLegIndexSetting.set(this.availableLegs[index].index);
                        this.handleClosePopup(this.refLegDialogRef);
                    } }),
                msfsSdk.FSComponent.buildComponent(OptionDialog, { ref: this.refModeDialogRef, class: "vnav-page-ref-mode-dialog", label: "POSITION", onSelected: (index) => {
                        this.refModeSetting.set(index === 0 ? GnsVnavRefMode.Before : GnsVnavRefMode.After);
                        this.handleClosePopup(this.refModeDialogRef);
                    } })));
        }
    }
    /**
     * Menu for the VNAV page
     */
    class VnavPageMenu extends MenuDefinition {
        /** @inheritDoc */
        constructor(vnavMessagesOn, onToggleVnavMessages, onRestoreDefaults) {
            super();
            this.vnavMessagesOn = vnavMessagesOn;
            this.onToggleVnavMessages = onToggleVnavMessages;
            this.onRestoreDefaults = onRestoreDefaults;
            this.vnavMessagesEntryText = msfsSdk.Subject.create('VNAV Messages On?');
            this.entries = [
                { label: this.vnavMessagesEntryText, disabled: false, action: this.onToggleVnavMessages },
                { label: 'Restore Defaults?', disabled: false, action: this.onRestoreDefaults },
            ];
            this.vnavMessagesOn.sub((on) => {
                this.vnavMessagesEntryText.set(`VNAV Messages ${on ? 'Off' : 'On'}?`);
            });
        }
    }

    /**
     * Confirmation dialog for generic messages.
     */
    class MessageDialog extends Dialog {
        constructor() {
            super(...arguments);
            this.messageDialogMenuItemsRef = msfsSdk.FSComponent.createRef();
            /**
             * Picks the next page to be loaded
             * @returns if the page has been loaded
             */
            this.onListItemSelected = () => {
                //todo be able to select items?
                return true;
            };
        }
        /** @inheritdoc */
        onResume() {
            super.onResume();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
        }
        /**
         * Method called when the message dialog is opened.
         */
        onMessageDialogClosed() {
            this.props.alerts.onAlertsViewed();
        }
        /**
         * Renders the bottom text depending on the GNS type
         * @returns the bottom element
         */
        renderBottomText() {
            if (this.props.gnsType !== 'wt430') {
                return (msfsSdk.FSComponent.buildComponent("div", { class: 'message-dialog-bottom-text' },
                    "Press",
                    msfsSdk.FSComponent.buildComponent("div", { class: 'message-dialog-boxed-msg' }, "MSG"),
                    "to continue"));
            }
            else {
                return (msfsSdk.FSComponent.buildComponent("div", null));
            }
        }
        /** @inheritdoc */
        renderDialog() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'message-dialog ' },
                msfsSdk.FSComponent.buildComponent("h2", { class: 'message-dialog-title' }, "MESSAGES"),
                msfsSdk.FSComponent.buildComponent("div", { class: 'message-dialog-middle' },
                    msfsSdk.FSComponent.buildComponent("div", { class: 'message-dialog-table' },
                        msfsSdk.FSComponent.buildComponent(GNSUiControlList, { data: this.props.alerts, renderItem: (data) => msfsSdk.FSComponent.buildComponent(MessageDialogItem, { data: data.message }), ref: this.messageDialogMenuItemsRef, hideScrollbar: true })),
                    this.renderBottomText()),
                msfsSdk.FSComponent.buildComponent("div", { class: "white-box" })));
        }
    }
    /**
     * A item that goes into the message Dialog.
     */
    class MessageDialogItem extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.label = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'message-dialog-item' },
                msfsSdk.FSComponent.buildComponent("div", { ref: this.label }, this.props.data)));
        }
    }

    /**
     * A component that contains all the right side main screen pages.
     */
    class PageContainer extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.pageGroups = [];
            this.pageGroupsByLabel = new Map();
            this.pageStack = [];
            this.confirmDialog = msfsSdk.FSComponent.createRef();
            this.waypointInfo = msfsSdk.FSComponent.createRef();
            this.dupWaypoints = msfsSdk.FSComponent.createRef();
            this.menuDialog = msfsSdk.FSComponent.createRef();
            this.directToDialog = msfsSdk.FSComponent.createRef();
            this.obsDialog = msfsSdk.FSComponent.createRef();
            this.activateLegDialog = msfsSdk.FSComponent.createRef();
            this.trafficAlertDialog = msfsSdk.FSComponent.createRef();
            this.tcasDataProvider = new msfsSdk.DefaultTcasAdvisoryDataProvider(this.props.bus, this.props.trafficSystem);
            this.currentGs = 0;
            this.approachActive = false;
            this.messageDialog = msfsSdk.FSComponent.createRef();
            this.screen = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            ViewService.setPresenter(this);
            msfsSdk.FSComponent.visitNodes(node, childNode => {
                if (childNode.instance instanceof PageGroup) {
                    this.pageGroupsByLabel.set(childNode.instance.props.label, childNode.instance);
                    if (!childNode.instance.props.isDetached) {
                        this.pageGroups.push(childNode.instance);
                        if (this.pageStack.length === 0) {
                            childNode.instance.resume();
                            this.pageStack.push({ pageGroup: childNode.instance, page: childNode.instance.getPage(0) });
                        }
                    }
                    return true;
                }
                return false;
            });
            this.screen.instance = document.querySelector('.mainscreen-right');
            //Handle the opening of the TA popup
            this.tcasDataProvider.taIntruders.sub((set, type) => {
                var _a;
                if (type === msfsSdk.SubscribableSetEventType.Added
                    && !((_a = this.pageGroupsByLabel.get('NAV')) === null || _a === void 0 ? void 0 : _a.getPage(3).isActive)
                    && this.currentGs >= 30
                    && !this.approachActive) {
                    this.openDialog(this.trafficAlertDialog.instance);
                }
            });
            this.tcasDataProvider.init();
            this.props.bus.getSubscriber().on('ground_speed').handle(gs => this.currentGs = gs);
            this.props.bus.getSubscriber().on('fms_flight_phase').handle(phase => this.approachActive = phase.isApproachActive);
        }
        /**
         * Intializes the page container.
         */
        init() {
            const current = this.pageStack[this.pageStack.length - 1];
            if ((current === null || current === void 0 ? void 0 : current.pageGroup) !== undefined) {
                this.props.onPageGroupChanged(current.pageGroup.props.label, current.pageGroup.length);
                current.pageGroup.resume();
            }
        }
        /**
         * Handles when an interaction event is received.
         * @param evt The interaction event that was received.
         */
        onInteractionEvent(evt) {
            let handled = false;
            const current = this.pageStack[this.pageStack.length - 1];
            if ((current === null || current === void 0 ? void 0 : current.pageGroup) !== undefined) {
                handled = current.pageGroup.onInteractionEvent(evt);
            }
            else if ((current === null || current === void 0 ? void 0 : current.page) !== undefined) {
                handled = current.page.onInteractionEvent(evt);
            }
            if (!handled) {
                switch (evt) {
                    case InteractionEvent.RightOuterInc:
                        this.changePageGroup('inc');
                        break;
                    case InteractionEvent.RightOuterDec:
                        this.changePageGroup('dec');
                        break;
                    case InteractionEvent.FPL:
                        this.openPageGroup('FPL', false, 0);
                        break;
                    case InteractionEvent.VNAV:
                        this.openPageGroup('VNAV', false, 0);
                        break;
                    case InteractionEvent.PROC:
                        this.openPageGroup('PROC', false, 0);
                        break;
                    case InteractionEvent.CLR:
                        this.back();
                        break;
                    case InteractionEvent.MSG:
                        if (this.messageDialog.instance.isActive) {
                            this.back();
                            this.messageDialog.instance.onMessageDialogClosed();
                        }
                        else {
                            this.openMessageDialog();
                        }
                        break;
                    case InteractionEvent.DirectTo:
                        if (this.directToDialog.instance.isActive) {
                            this.back();
                        }
                        else {
                            this.openDirectToDialogWithLeg();
                        }
                        break;
                }
            }
        }
        /**
         * Changes the active page group on the screen.
         * @param direction The direction to advance to.
         */
        changePageGroup(direction) {
            const current = this.pageStack[this.pageStack.length - 1];
            if ((current === null || current === void 0 ? void 0 : current.pageGroup) !== undefined && !(current === null || current === void 0 ? void 0 : current.pageGroup.props.isDetached)) {
                const currentGroupIndex = this.pageGroups.indexOf(current.pageGroup);
                const newGroupIndex = Utils.Clamp(currentGroupIndex + (direction === 'inc' ? 1 : -1), 0, this.pageGroups.length - 1);
                this.openPageGroup(this.pageGroups[newGroupIndex].props.label, true);
            }
        }
        /** @inheritdoc */
        openPageGroup(group, replace, pageNumber) {
            const pageGroup = this.pageGroupsByLabel.get(group);
            if (pageGroup !== undefined) {
                const current = this.pageStack[this.pageStack.length - 1];
                if (current !== undefined) {
                    // If we currently have a dialog open, we want to back out of it before opening the page group
                    if (current.isDialog) {
                        this.back();
                        return this.openPageGroup(group, replace, pageNumber);
                    }
                    if (current.pageGroup !== undefined && current.pageGroup !== pageGroup) {
                        current.pageGroup.suspend();
                        if (pageGroup.props.isDetached && current.pageGroup.props.isDetached) {
                            this.pageStack.pop();
                        }
                    }
                    else {
                        current.page.onSuspend();
                    }
                }
                this.props.onPageGroupChanged(pageGroup.props.label, pageGroup.length);
                if (pageNumber !== undefined) {
                    pageGroup.setPage(pageNumber);
                }
                else {
                    pageGroup.resume();
                }
                const page = pageGroup.activePage;
                if (replace) {
                    this.pageStack[this.pageStack.length - 1] = { pageGroup, page };
                }
                else {
                    this.pageStack.push({ pageGroup, page });
                }
                return page;
            }
        }
        /** @inheritdoc */
        back() {
            var _a;
            if (this.pageStack.length > 1) {
                const currentPageEntry = this.pageStack.pop();
                if (currentPageEntry !== undefined) {
                    if (currentPageEntry.pageGroup !== undefined) {
                        currentPageEntry.pageGroup.suspend();
                    }
                    else {
                        currentPageEntry.page.onSuspend();
                    }
                }
                const pageEntry = this.pageStack[this.pageStack.length - 1];
                if (pageEntry !== undefined) {
                    if (pageEntry.pageGroup !== undefined) {
                        this.props.onPageGroupChanged(pageEntry.pageGroup.props.label, pageEntry.pageGroup.length);
                        this.props.onPageChanged(pageEntry.pageGroup.indexOfPage(pageEntry.page));
                        if (!((currentPageEntry === null || currentPageEntry === void 0 ? void 0 : currentPageEntry.page) instanceof Dialog)) {
                            pageEntry.pageGroup.resume();
                        }
                        (_a = pageEntry.pageGroup.activePage) === null || _a === void 0 ? void 0 : _a.resumeAnimations();
                    }
                    else {
                        if (!(pageEntry.page instanceof Dialog)) {
                            pageEntry.page.onResume();
                        }
                        pageEntry.page.resumeAnimations();
                    }
                }
            }
        }
        /** @inheritdoc */
        default() {
            let current = this.pageStack.pop();
            while (current !== undefined) {
                if (current.pageGroup !== undefined) {
                    current.pageGroup.suspend();
                }
                else {
                    current.page.onSuspend();
                }
                current = this.pageStack.pop();
            }
            this.openPageGroup('NAV', false, 0);
        }
        /** @inheritdoc */
        openActivateLegDialog(legIndex) {
            this.activateLegDialog.instance.legIndex = legIndex;
            this.openDialog(this.activateLegDialog.instance);
        }
        /** @inheritdoc */
        openConfirmDialog(title, body, resolve, reject) {
            try {
                this.confirmDialog.instance.setTitle(title);
                this.confirmDialog.instance.setBody(body);
                this.confirmDialog.instance.setResolve(val => {
                    this.back();
                    resolve(val);
                });
                this.openDialog(this.confirmDialog.instance);
            }
            catch (err) {
                reject(err);
            }
        }
        /** @inheritdoc */
        openWaypointDialog(resolve, reject) {
            try {
                this.waypointInfo.instance.setResolve(val => {
                    this.back();
                    resolve(val);
                });
                this.openDialog(this.waypointInfo.instance);
            }
            catch (err) {
                reject(err);
            }
        }
        /** @inheritdoc */
        openDupsDialog(ident, icaos, resolve, reject) {
            try {
                this.dupWaypoints.instance.setIdent(ident);
                this.dupWaypoints.instance.setIcaos(icaos);
                this.dupWaypoints.instance.setResolve(val => {
                    this.back();
                    resolve(val);
                });
                this.openDialog(this.dupWaypoints.instance);
            }
            catch (err) {
                reject(err);
            }
        }
        /** @inheritDoc */
        openDirectToDialogWithLeg(legDefinition) {
            msfsSdk.NearestContext.onInitialized(async () => {
                if (legDefinition) {
                    const legFacilityIcao = legDefinition.leg.fixIcao;
                    const facility = await this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(legFacilityIcao), legFacilityIcao).catch((e) => {
                        console.error('Could not get facility from leg fixIcao for opening DIRECT TO dialog. See error below');
                        throw e;
                    });
                    this.directToDialog.instance.acceptPreviewFacility(facility, legDefinition);
                    this.openDialog(this.directToDialog.instance);
                }
                else {
                    if (this.props.gnsType === 'wt430') {
                        this.props.onPageGroupChanged('DRCT', 1);
                    }
                    this.openDialog(this.directToDialog.instance);
                }
            });
        }
        /** @inheritDoc */
        openDirectToDialogWithIcao(icao) {
            msfsSdk.NearestContext.onInitialized(async () => {
                if (icao) {
                    const facility = await this.props.fms.facLoader.getFacility(msfsSdk.ICAO.getFacilityType(icao), icao).catch((e) => {
                        console.error('Could not get facility from leg fixIcao for opening DIRECT TO dialog. See error below');
                        throw e;
                    });
                    this.directToDialog.instance.acceptPreviewFacility(facility);
                    this.openDialog(this.directToDialog.instance);
                }
                else {
                    if (this.props.gnsType === 'wt430') {
                        this.props.onPageGroupChanged('DRCT', 1);
                    }
                    this.openDialog(this.directToDialog.instance);
                }
            });
        }
        /** @inheritDoc */
        openMessageDialog() {
            if (this.props.gnsType === 'wt430') {
                this.props.onPageGroupChanged('MSG', 1);
            }
            this.openDialog(this.messageDialog.instance);
        }
        /** @inheritDoc */
        openObsDialog() {
            // noop
        }
        /**
         * Opens a dialog page.
         * @param dialog The dialog page to open.
         * @returns The currently open page, or undefined if none open.
         */
        openDialog(dialog) {
            this.screen.instance.removeChild(dialog.getRootElement());
            this.screen.instance.appendChild(dialog.getRootElement());
            const pageEntry = this.pageStack[this.pageStack.length - 1];
            if (pageEntry !== undefined) {
                pageEntry.page.freezeAnimations();
            }
            this.pageStack.push({ page: dialog, isDialog: true });
            dialog.onResume();
            return pageEntry === null || pageEntry === void 0 ? void 0 : pageEntry.page;
        }
        /** @inheritdoc */
        openMenu(definition, title) {
            if (Array.isArray(definition)) {
                this.menuDialog.instance.setMenuItems(definition);
                if (title !== undefined) {
                    this.menuDialog.instance.setTitle(title);
                }
            }
            else {
                definition.updateEntries();
                this.menuDialog.instance.setMenuItems(definition.entries);
                if (title !== undefined) {
                    this.menuDialog.instance.setTitle(title);
                }
                else {
                    this.menuDialog.instance.setTitle(definition.title);
                }
            }
            this.openDialog(this.menuDialog.instance);
            return this.menuDialog.instance;
        }
        /** @inheritDoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(PageGroup, { bus: this.props.bus, label: 'NAV', onPageChanged: this.props.onPageChanged },
                    this.props.gnsType === 'wt530' ? (msfsSdk.FSComponent.buildComponent(ArcNavMap, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, settingsProvider: this.props.settingsProvider, fms: this.props.fms, trafficSystem: this.props.trafficSystem, tcasDataProvider: this.tcasDataProvider })) : (msfsSdk.FSComponent.buildComponent(NavInfo, { gnsType: this.props.gnsType, bus: this.props.bus, fms: this.props.fms })),
                    msfsSdk.FSComponent.buildComponent(StandardNavMap, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, fms: this.props.fms, settingsProvider: this.props.settingsProvider, flightPlanner: this.props.fms.flightPlanner, trafficSystem: this.props.trafficSystem, tcasDataProvider: this.tcasDataProvider }),
                    msfsSdk.FSComponent.buildComponent(TerrainMap, { bus: this.props.bus, gnsType: this.props.gnsType, instrumentIndex: this.props.options.instrumentIndex, fms: this.props.fms, settingsProvider: this.props.settingsProvider, flightPlanner: this.props.fms.flightPlanner }),
                    msfsSdk.FSComponent.buildComponent(TrafficMap, { bus: this.props.bus, gnsType: this.props.gnsType, trafficSystem: this.props.trafficSystem }),
                    msfsSdk.FSComponent.buildComponent(GPSStatus, { bus: this.props.bus, gnsType: this.props.gnsType, sats: this.props.gpsSat, settingsProvider: this.props.settingsProvider }),
                    this.props.gnsType === 'wt430' && (msfsSdk.FSComponent.buildComponent(VnavPage, { bus: this.props.bus, gnsType: this.props.gnsType }))),
                msfsSdk.FSComponent.buildComponent(WaypointPageGroup, { bus: this.props.bus, settingsProvider: this.props.settingsProvider, label: 'WPT', onPageChanged: this.props.onPageChanged, onPopupDonePressed: () => this.back(), gnsType: this.props.gnsType, fms: this.props.fms, options: this.props.options }),
                msfsSdk.FSComponent.buildComponent(PageGroup, { bus: this.props.bus, label: 'AUX', onPageChanged: this.props.onPageChanged },
                    msfsSdk.FSComponent.buildComponent(AuxFlightPlanning, { bus: this.props.bus, gnsType: this.props.gnsType, settingsProvider: this.props.settingsProvider }),
                    msfsSdk.FSComponent.buildComponent(AuxUtility, { bus: this.props.bus, gnsType: this.props.gnsType }),
                    msfsSdk.FSComponent.buildComponent(AuxSetup1, { bus: this.props.bus, gnsType: this.props.gnsType, xmlConfig: this.props.xmlConfig, fms: this.props.fms, settingsProvider: this.props.settingsProvider }),
                    msfsSdk.FSComponent.buildComponent(AuxSetup2, { bus: this.props.bus, gnsType: this.props.gnsType, xmlConfig: this.props.xmlConfig, settingsProvider: this.props.settingsProvider })),
                msfsSdk.FSComponent.buildComponent(PageGroup, { bus: this.props.bus, label: 'NRST', onPageChanged: this.props.onPageChanged },
                    msfsSdk.FSComponent.buildComponent(NearestAirport, { bus: this.props.bus, gnsType: this.props.gnsType, onAirportSelected: () => this.openPageGroup('WPT', false), comIndex: this.props.options.comIndex, navIndex: this.props.options.navIndex }),
                    msfsSdk.FSComponent.buildComponent(NearestIntersection, { bus: this.props.bus, gnsType: this.props.gnsType, onIntersectionSelected: () => this.openPageGroup('WPT', false), comIndex: this.props.options.comIndex, navIndex: this.props.options.navIndex }),
                    msfsSdk.FSComponent.buildComponent(NearestNdb, { bus: this.props.bus, gnsType: this.props.gnsType, onNdbSelected: () => this.openPageGroup('WPT', false), comIndex: this.props.options.comIndex, navIndex: this.props.options.navIndex }),
                    msfsSdk.FSComponent.buildComponent(NearestVor, { bus: this.props.bus, gnsType: this.props.gnsType, onVorSelected: () => this.openPageGroup('WPT', false), comIndex: this.props.options.comIndex, navIndex: this.props.options.navIndex })),
                msfsSdk.FSComponent.buildComponent(PageGroup, { bus: this.props.bus, label: 'FPL', onPageChanged: this.props.onPageChanged, isDetached: true },
                    msfsSdk.FSComponent.buildComponent(FPLPage, { bus: this.props.bus, gnsType: this.props.gnsType, fms: this.props.fms, onPageSelected: (v) => this.openPageGroup('WPT', false, v) })),
                this.props.gnsType === 'wt530' && (msfsSdk.FSComponent.buildComponent(PageGroup, { bus: this.props.bus, label: 'VNAV', onPageChanged: this.props.onPageChanged, isDetached: true },
                    msfsSdk.FSComponent.buildComponent(VnavPage, { bus: this.props.bus, gnsType: this.props.gnsType }))),
                msfsSdk.FSComponent.buildComponent(PageGroup, { bus: this.props.bus, label: 'PROC', onPageChanged: this.props.onPageChanged, isDetached: true },
                    msfsSdk.FSComponent.buildComponent(ProcedurePage, { bus: this.props.bus, fms: this.props.fms, gnsType: this.props.gnsType, onPageSelected: (v) => this.openPageGroup('WPT', false, v) })),
                msfsSdk.FSComponent.buildComponent(ConfirmDialog, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.confirmDialog }),
                msfsSdk.FSComponent.buildComponent(WaypointInfo, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.waypointInfo, fms: this.props.fms }),
                msfsSdk.FSComponent.buildComponent(DupWaypoints, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.dupWaypoints, fms: this.props.fms }),
                msfsSdk.FSComponent.buildComponent(MenuDialog, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.menuDialog, fms: this.props.fms }),
                msfsSdk.FSComponent.buildComponent(DirectToDialog, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.directToDialog, fms: this.props.fms }),
                msfsSdk.FSComponent.buildComponent(ActivateLegDialog, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.activateLegDialog, fms: this.props.fms }),
                msfsSdk.FSComponent.buildComponent(ObsDialog, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.obsDialog }),
                msfsSdk.FSComponent.buildComponent(TrafficAlertDialog, { bus: this.props.bus, gnsType: this.props.gnsType, trafficSystem: this.props.trafficSystem, ref: this.trafficAlertDialog }),
                msfsSdk.FSComponent.buildComponent(MessageDialog, { bus: this.props.bus, gnsType: this.props.gnsType, ref: this.messageDialog, alerts: this.props.alerts })));
        }
    }

    /**
     * A component that displays the current instrument and CDI scaling status.
     */
    class StatusPane extends msfsSdk.DisplayComponent {
        constructor() {
            super(...arguments);
            this.cdiScaleFormatter = msfsGarminsdk.CdiScaleFormatter.create(false);
            this.cdiScaleLabel = msfsSdk.Subject.create(this.cdiScaleFormatter(msfsGarminsdk.CDIScaleLabel.Enroute));
            this.scaleEl = msfsSdk.FSComponent.createRef();
            this.integEl = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender() {
            this.props.bus.getSubscriber().on('lnavdata_cdi_scale_label')
                .whenChanged()
                .handle(this.onCdiScaleChanged.bind(this));
            this.props.bus.getSubscriber().on('gps_system_state_changed_1').handle(s => {
                if (s === msfsSdk.GPSSystemState.Searching || s === msfsSdk.GPSSystemState.Acquiring) {
                    this.integEl.instance.classList.remove('hide-element');
                }
                else {
                    this.integEl.instance.classList.add('hide-element');
                }
            });
        }
        /**
         * Handles when the CDI scale changes.
         * @param cdiScale The new CDI scale.
         */
        onCdiScaleChanged(cdiScale) {
            const isRnav = cdiScale >= msfsGarminsdk.CDIScaleLabel.LNav && cdiScale <= msfsGarminsdk.CDIScaleLabel.LPV;
            if (isRnav) {
                this.scaleEl.instance.classList.add('cdi-scale-rnav');
            }
            else {
                this.scaleEl.instance.classList.remove('cdi-scale-rnav');
            }
            this.cdiScaleLabel.set(this.cdiScaleFormatter(cdiScale));
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'status-pane' },
                msfsSdk.FSComponent.buildComponent("div", null),
                msfsSdk.FSComponent.buildComponent("div", null,
                    msfsSdk.FSComponent.buildComponent("div", { ref: this.scaleEl }, this.cdiScaleLabel)),
                msfsSdk.FSComponent.buildComponent("div", null,
                    msfsSdk.FSComponent.buildComponent("div", { class: 'status-pane-integ hide-element', ref: this.integEl }, "INTEG"))));
        }
    }

    /**
     * The GNS self-test page.
     */
    class SelfTest extends Page {
        constructor() {
            super(...arguments);
            this.obs = msfsSdk.NumberUnitSubject.create(msfsSdk.BasicNavAngleUnit.create(true).createNumber(NaN));
            this.fuelCapacity = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GALLON.createNumber(NaN));
            this.fuelOnBoard = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GALLON.createNumber(NaN));
            this.fuelFlow = msfsSdk.NumberUnitSubject.create(msfsSdk.UnitType.GPH_FUEL.createNumber(NaN));
            this.root = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onAfterRender(node) {
            super.onAfterRender(node);
            this.props.bus.getSubscriber().on(`nav_obs_${this.props.navRadioIndex}`).withPrecision(0).handle(obs => this.obs.set(obs));
            this.props.bus.getSubscriber().on('instrument_powered').handle(this.onPowerStateChanged.bind(this));
        }
        /** @inheritdoc */
        onInteractionEvent(evt) {
            return this.root.instance.onInteractionEvent(evt);
        }
        /**
         * Handles when the self-test is confirmed.
         * @returns True that the control was handled.
         */
        onConfirmed() {
            this.props.bus.getPublisher().pub('instrument_powered', PowerState.On);
            return true;
        }
        /**
         * Handles when the power state of the instrument is changed.
         * @param state The new power state.
         */
        onPowerStateChanged(state) {
            if (state === PowerState.SelfTest) {
                this.onResume();
                this.root.instance.focus(msfsSdk.FocusPosition.Last);
            }
            else {
                this.onSuspend();
            }
        }
        /**
         * Handles rendering different screens based on which version is being used.
         * @returns The right version of the instrument
         */
        render430or530() {
            if (this.props.gnsType === 'wt430') {
                return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                    msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-left' },
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent("label", null, "LCDI"),
                            msfsSdk.FSComponent.buildComponent("label", null, "LFLG"),
                            msfsSdk.FSComponent.buildComponent("label", null, "VCDI"),
                            msfsSdk.FSComponent.buildComponent("label", null, "VFLG")),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-values' },
                            msfsSdk.FSComponent.buildComponent("div", null, "Half Left"),
                            msfsSdk.FSComponent.buildComponent("div", null, "Out of View"),
                            msfsSdk.FSComponent.buildComponent("div", null, "Half Up"),
                            msfsSdk.FSComponent.buildComponent("div", null, "Out of View")),
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-tofrm' },
                                msfsSdk.FSComponent.buildComponent("label", null, "TO/FRM"),
                                msfsSdk.FSComponent.buildComponent("div", null, "To")),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-annum' },
                                msfsSdk.FSComponent.buildComponent("label", null, "ANNUN"),
                                msfsSdk.FSComponent.buildComponent("div", null, "On")),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-rmi' },
                                msfsSdk.FSComponent.buildComponent("label", null, "RMI"),
                                msfsSdk.FSComponent.buildComponent("div", null, "135")),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-dtk' },
                                msfsSdk.FSComponent.buildComponent("label", null, "DTK"),
                                msfsSdk.FSComponent.buildComponent("div", null,
                                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.BEARING_FORMATTER, value: msfsSdk.BasicNavAngleUnit.create(true).createNumber(150), displayUnit: msfsSdk.BasicNavAngleUnit.create(true) }))),
                            msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-obs' },
                                msfsSdk.FSComponent.buildComponent("label", null, "OBS"),
                                msfsSdk.FSComponent.buildComponent("div", null,
                                    msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.BEARING_FORMATTER, value: this.obs, displayUnit: msfsSdk.BasicNavAngleUnit.create(true) }))))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-right' },
                        msfsSdk.FSComponent.buildComponent("h3", { class: 'self-test-430-right-label' }, "CAP"),
                        msfsSdk.FSComponent.buildComponent("h3", { class: 'self-test-430-right-label' }, "FOB"),
                        msfsSdk.FSComponent.buildComponent("h3", { class: 'self-test-430-right-label' }, "FF"),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-right-cap' },
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'self-test-field-cap', formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: this.fuelCapacity, displayUnit: msfsSdk.UnitType.GALLON })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-right-fob' },
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'self-test-field-fob', formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: this.fuelOnBoard, displayUnit: msfsSdk.UnitType.GALLON })),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-right-ff' },
                            msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'self-test-field-ff', formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: this.fuelFlow, displayUnit: msfsSdk.UnitType.GALLON })),
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent(SelfTestControl, { class: 'self-test-control-sff' }, "Set Full Fuel?"),
                            msfsSdk.FSComponent.buildComponent(SelfTestControl, { class: 'self-test-control' }, "Go To Chklist?"),
                            msfsSdk.FSComponent.buildComponent(SelfTestControl, { class: 'self-test-control ok-button', onEnt: this.onConfirmed.bind(this) }, "OK?")))));
            }
            else {
                return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                    msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-left' },
                        msfsSdk.FSComponent.buildComponent("div", null,
                            msfsSdk.FSComponent.buildComponent("label", null, "LCDI"),
                            msfsSdk.FSComponent.buildComponent("label", null, "LFLG"),
                            msfsSdk.FSComponent.buildComponent("label", null, "VCDI"),
                            msfsSdk.FSComponent.buildComponent("label", null, "VFLG"),
                            msfsSdk.FSComponent.buildComponent("label", null, "TO/FRM"),
                            msfsSdk.FSComponent.buildComponent("label", null, "ANNUN"),
                            msfsSdk.FSComponent.buildComponent("label", null, "RMI"),
                            msfsSdk.FSComponent.buildComponent("label", null, "OBS"),
                            msfsSdk.FSComponent.buildComponent("label", null, "DTK")),
                        msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-values' },
                            msfsSdk.FSComponent.buildComponent("div", null, "Half Left"),
                            msfsSdk.FSComponent.buildComponent("div", null, "Out of View"),
                            msfsSdk.FSComponent.buildComponent("div", null, "Half Up"),
                            msfsSdk.FSComponent.buildComponent("div", null, "Out of View"),
                            msfsSdk.FSComponent.buildComponent("div", null, "To"),
                            msfsSdk.FSComponent.buildComponent("div", null, "On"),
                            msfsSdk.FSComponent.buildComponent("div", null, "135"),
                            msfsSdk.FSComponent.buildComponent("div", null,
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.BEARING_FORMATTER, value: this.obs, displayUnit: msfsSdk.BasicNavAngleUnit.create(true) })),
                            msfsSdk.FSComponent.buildComponent("div", null,
                                msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { formatter: GNSDataFieldTypeRenderer.BEARING_FORMATTER, value: msfsSdk.BasicNavAngleUnit.create(true).createNumber(150), displayUnit: msfsSdk.BasicNavAngleUnit.create(true) })))),
                    msfsSdk.FSComponent.buildComponent("div", { class: 'self-test-right' },
                        msfsSdk.FSComponent.buildComponent("h3", null, "FUEL CAPACITY"),
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'self-test-field', formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: this.fuelCapacity, displayUnit: msfsSdk.UnitType.GALLON }),
                        msfsSdk.FSComponent.buildComponent("h3", null, "FUEL ON-BOARD"),
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'self-test-field', formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: this.fuelOnBoard, displayUnit: msfsSdk.UnitType.GALLON }),
                        msfsSdk.FSComponent.buildComponent("h3", null, "FUEL FLOW"),
                        msfsSdk.FSComponent.buildComponent(GNSNumberUnitDisplay, { class: 'self-test-field', formatter: GNSDataFieldTypeRenderer.FUEL_FORMATTER, value: this.fuelFlow, displayUnit: msfsSdk.UnitType.GALLON }),
                        msfsSdk.FSComponent.buildComponent(GNSUiControl, { ref: this.root, isolateScroll: true },
                            msfsSdk.FSComponent.buildComponent(SelfTestControl, { class: 'self-test-control' }, "Set Full Fuel?"),
                            msfsSdk.FSComponent.buildComponent("hr", null),
                            msfsSdk.FSComponent.buildComponent(SelfTestControl, { class: 'self-test-control' }, "Go To Checklists?"),
                            msfsSdk.FSComponent.buildComponent("hr", null),
                            msfsSdk.FSComponent.buildComponent(SelfTestControl, { class: 'self-test-control ok-button', onEnt: this.onConfirmed.bind(this) }, "OK?")))));
            }
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent("div", { class: 'self-test hide-element', ref: this.el },
                msfsSdk.FSComponent.buildComponent("h3", null, "INSTRUMENT PANEL SELF-TEST"),
                this.render430or530()));
        }
    }
    /**
     * A control that is a simple highlightable button.
     */
    class SelfTestControl extends GNSUiControl {
        constructor() {
            super(...arguments);
            this.el = msfsSdk.FSComponent.createRef();
        }
        /** @inheritdoc */
        onFocused() {
            this.el.instance.classList.add('selected-white');
        }
        /** @inheritdoc */
        onBlurred() {
            this.el.instance.classList.remove('selected-white');
        }
        /** @inheritdoc */
        render() {
            var _a;
            return (msfsSdk.FSComponent.buildComponent("div", { class: `${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
                msfsSdk.FSComponent.buildComponent("span", { ref: this.el }, this.props.children)));
        }
    }

    const AirportClassMaskFromSurfaceTypeOption = {
        [SurfaceTypeOption.Any]: msfsSdk.BitFlags.union(msfsSdk.AirportClassMask.HardSurface, msfsSdk.AirportClassMask.SoftSurface, msfsSdk.AirportClassMask.AllWater, msfsSdk.AirportClassMask.HeliportOnly, msfsSdk.AirportClassMask.Private),
        [SurfaceTypeOption.HardOnly]: msfsSdk.AirportClassMask.HardSurface,
        [SurfaceTypeOption.HardOrSoft]: msfsSdk.BitFlags.union(msfsSdk.AirportClassMask.HardSurface, msfsSdk.AirportClassMask.SoftSurface),
        [SurfaceTypeOption.Water]: msfsSdk.AirportClassMask.AllWater,
    };
    /**
     * Controls the nearest search filter for the GNS unit
     */
    class NearestAirportFilter {
        /**
         * Sets the provided surface type option as the active surface type filter
         *
         * @param option the surface type option
         */
        static setSurfaceTypeFilter(option) {
            this.classMask = AirportClassMaskFromSurfaceTypeOption[option];
            this.updateNearestContext();
        }
        /**
         * Sets the provided minimum runway length as the active minimum runway length filter
         *
         * @param length the minimum runway length, in feet
         */
        static setMinimumRunwayLength(length) {
            const lengthMetres = msfsSdk.UnitType.FOOT.convertTo(length, msfsSdk.UnitType.METER);
            this.minimumRunwayLength = Math.max(0, lengthMetres);
            this.updateNearestContext();
        }
        /**
         * Updates the nearest context with the active nearest filters
         */
        static updateNearestContext() {
            msfsSdk.NearestContext.getInstance().airports.setFilter(true, this.classMask);
            msfsSdk.NearestContext.getInstance().airports.setExtendedFilters(msfsSdk.NearestAirportSearchSession.Defaults.SurfaceTypeMask, msfsSdk.NearestAirportSearchSession.Defaults.ApproachTypeMask, msfsSdk.NearestAirportSearchSession.Defaults.ToweredMask, this.minimumRunwayLength);
            msfsSdk.NearestContext.getInstance().update();
        }
    }
    NearestAirportFilter.classMask = AirportClassMaskFromSurfaceTypeOption[SurfaceTypeOption.Any];
    NearestAirportFilter.minimumRunwayLength = 0;

    /**
     * A Course controller for the GNS.
     */
    class GnsCourseController {
        /**
         * Creates an instance of a GnsCourseController.
         * @param bus An instance of the event bus.
         * @param navIndex index to the nav system
         */
        constructor(bus, navIndex) {
            this.opId = 0;
            this.activeDtkMessage = null;
            this.dtk = msfsSdk.ConsumerSubject.create(bus.getSubscriber().on('lnavdata_dtk_mag'), 0);
            bus.getSubscriber().on('lnav_tracked_leg_index').whenChanged().handle(this.onTrackedLegChanged.bind(this));
            this.publisher = bus.getPublisher();
            switch (navIndex) {
                case 2:
                    //TODO: Is there a way to verify that there is a second CDI installed?
                    this.navObs = msfsSdk.ConsumerSubject.create(bus.getSubscriber().on('nav_obs_2'), 0);
                    break;
                case 3:
                    this.navObs = msfsSdk.ConsumerSubject.create(bus.getSubscriber().on('nav_obs_3'), 0);
                    break;
                default:
                    this.navObs = msfsSdk.ConsumerSubject.create(bus.getSubscriber().on('nav_obs_1'), 0);
            }
            this.navObs.sub(v => {
                if (this.activeDtkMessage !== null) {
                    const dtk = this.dtk.get();
                    if (Math.abs(msfsSdk.NavMath.diffAngle(dtk, v)) < 5) {
                        this.publisher.pub('alerts_remove', 'lnav-set-course', false, false);
                        this.activeDtkMessage = null;
                    }
                }
            });
        }
        /**
         * Handle method that runs everytime the leg is changed so the system can update.
         * @param legIndex the index of the leg that has been changed
         */
        onTrackedLegChanged(legIndex) {
            this.publisher.pub('alerts_remove', 'lnav-set-course', false, false);
            this.activeDtkMessage = null;
            if (legIndex > 0) {
                this.opId++;
                const opId = this.opId;
                msfsSdk.Wait.awaitDelay(600000).then(() => {
                    if (this.opId === opId) {
                        const dtk = this.dtk.get();
                        const navObs = this.navObs.get();
                        if (Math.abs(msfsSdk.NavMath.diffAngle(dtk, navObs)) > 5) {
                            const message = {
                                key: 'lnav-set-course',
                                persistent: true,
                                message: 'Set course to ' + dtk.toFixed(0).padStart(3, '0') + '°'
                            };
                            this.activeDtkMessage = dtk;
                            this.publisher.pub('alerts_push', message, false, false);
                        }
                    }
                });
            }
        }
    }

    var _a;
    /**
     * A publisher for AHRS information for the Nxi which sources data from PLANE simvars instead of the attitude and
     * heading indicator simvars.
     *
     * This class is meant to be a temporary fix for the vacuum gyro problem until the Nxi can be made to fully support
     * customizable attitude/heading indicator indexes.
     */
    class GnsAhrsPublisher extends msfsSdk.SimVarPublisher {
        /**
         * Creates an AhrsPublisher.
         * @param bus The event bus to which to publish.
         * @param pacer An optional pacer to use to control the rate of publishing.
         */
        constructor(bus, pacer) {
            super(new Map(GnsAhrsPublisher.SIMVARS), bus, pacer);
            bus.getSubscriber().on('magvar').atFrequency(1).handle(magvar => GnsAhrsPublisher.magVar = magvar);
        }
    }
    _a = GnsAhrsPublisher;
    GnsAhrsPublisher.magVar = 0;
    GnsAhrsPublisher.SIMVARS = [
        ['hdg_deg', { name: 'HEADING INDICATOR', type: msfsSdk.SimVarValueType.Degree }],
        ['hdg_deg_true', { name: 'HEADING INDICATOR', type: msfsSdk.SimVarValueType.Degree, map: (heading) => msfsSdk.MagVar.magneticToTrue(heading, _a.magVar) }],
        ['delta_heading_rate', { name: 'DELTA HEADING RATE', type: msfsSdk.SimVarValueType.Degree }],
        ['pitch_deg', { name: 'PLANE PITCH DEGREES', type: msfsSdk.SimVarValueType.Degree }],
        ['roll_deg', { name: 'PLANE BANK DEGREES', type: msfsSdk.SimVarValueType.Degree }],
        ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: msfsSdk.SimVarValueType.Number }],
    ];

    /**
     * A GNS autopilot state manager.
     */
    class GNSAPStateManager extends msfsGarminsdk.GarminAPStateManager {
        /**
         * Creates an instance of the APStateManager.
         * @param bus An instance of the event bus.
         * @param apConfig This autopilot's configuration.
         * @param supportFlightDirector Whether to support a flight director independent from the autopilot state.
         */
        constructor(bus, apConfig, supportFlightDirector) {
            super(bus, apConfig);
            this.bus = bus;
            this.supportFlightDirector = supportFlightDirector;
            this.controlPub = this.bus.getPublisher();
        }
        /** @inheritdoc */
        setupKeyIntercepts(manager) {
            super.setupKeyIntercepts(manager);
            manager.interceptKey('AP_NAV_SELECT_SET', false);
            manager.interceptKey('TOGGLE_GPS_DRIVES_NAV1', false);
        }
        /**
         * Sends AP Mode Events from the Intercept to the Autopilot.
         * @param type is the AP Mode Type for this event
         * @param mode is the mode to set/unset.
         * @param set is whether to actively set or unset this mode.
         */
        sendApModeEvent(type, mode, set) {
            if (this.supportFlightDirector || this.apMasterOn.get()) {
                super.sendApModeEvent(type, mode, set);
            }
        }
        /** @inheritdoc */
        handleApNavSelect(value) {
            if (value !== undefined && value >= 1 && value <= 2) {
                this.controlPub.pub('set_ap_nav_source', value);
            }
        }
        /** @inheritdoc */
        handleKeyIntercepted(data) {
            const controlEventPub = this.bus.getPublisher();
            switch (data.key) {
                case 'AP_NAV_SELECT_SET':
                    if (data.value0 !== undefined && data.value0 >= 1 && data.value0 <= 2) {
                        controlEventPub.pub('cdi_src_set', { type: msfsSdk.NavSourceType.Nav, index: data.value0 }, true);
                    }
                    break;
                case 'TOGGLE_GPS_DRIVES_NAV1':
                    controlEventPub.pub('cdi_src_gps_toggle', true, true);
                    break;
                case 'AP_ATT_HOLD_ON':
                    this.sendApModeEvent(msfsSdk.APModeType.VERTICAL, msfsSdk.APVerticalModes.PITCH, true);
                    break;
                case 'AP_ATT_HOLD_OFF':
                    this.sendApModeEvent(msfsSdk.APModeType.VERTICAL, msfsSdk.APVerticalModes.PITCH, false);
                    break;
                case 'AP_ATT_HOLD':
                    this.sendApModeEvent(msfsSdk.APModeType.VERTICAL, msfsSdk.APVerticalModes.PITCH);
                    break;
                default:
                    super.handleKeyIntercepted(data);
            }
        }
    }

    /**
     * A component that displays the main screen of the GNS530.
     */
    class MainScreen extends msfsSdk.DisplayComponent {
        /**
         * Creates an instance of a DisplayComponent.
         * @param props The propertis of the component.
         */
        constructor(props) {
            super(props);
            this.primaryFlightPlanInitPromise = new Promise(resolve => { this.primaryFlightPlanInitPromiseResolve = resolve; });
            this.settingsProvider = new GNSSettingsProvider(this.props.bus);
            this.gnsCdiMode = msfsSdk.Subject.create(GnsCdiMode.GPS);
            this.comPane = msfsSdk.FSComponent.createRef();
            this.vLocPane = msfsSdk.FSComponent.createRef();
            this.footerBar = msfsSdk.FSComponent.createRef();
            this.pageContainer = msfsSdk.FSComponent.createRef();
            this.startupScreen = msfsSdk.FSComponent.createRef();
            this.selfTest = msfsSdk.FSComponent.createRef();
            this.isComSelected = true;
            this.gamePlanSynced = false;
            this.currentPowerState = PowerState.Off;
            this.lastCalculate = 0;
            SimVar.SetSimVarValue('L:XMLVAR_NEXTGEN_FLIGHTPLAN_ENABLED', msfsSdk.SimVarValueType.Bool, true);
            this.alertsSubject = new AlertsSubject(this.props.bus);
            this.gnsCourseController = new GnsCourseController(this.props.bus, this.props.options.navIndex);
            this.gnssPublisher = new msfsSdk.GNSSPublisher(this.props.bus);
            this.enabledSbasGroups = msfsSdk.SetSubject.create(Object.values(msfsSdk.SBASGroupName));
            this.gpsSatComputer = new msfsSdk.GPSSatComputer(1, this.props.bus, 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/gps_ephemeris.json', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/GPS/Shared/Assets/gps_sbas.json', 5000, this.enabledSbasGroups, 'none', {
                channelCount: 15,
                satInUseMaxCount: 15,
                satInUsePdopTarget: 2,
                satInUseOptimumCount: 5
            });
            this.adcPublisher = new msfsSdk.AdcPublisher(this.props.bus);
            this.ahrsPublisher = new GnsAhrsPublisher(this.props.bus);
            this.navEventsPublisher = new msfsGarminsdk.NavEventsPublisher(this.props.bus);
            this.lNavPublisher = new msfsSdk.LNavSimVarPublisher(this.props.bus);
            this.vNavPublisher = new msfsSdk.VNavSimVarPublisher(this.props.bus);
            this.lNavDataPublisher = new msfsGarminsdk.LNavDataSimVarPublisher(this.props.bus);
            this.vNavDataPublisher = new msfsSdk.VNavDataEventPublisher(this.props.bus);
            this.clock = new msfsSdk.Clock(this.props.bus);
            this.controlPublisher = new msfsSdk.ControlPublisher(this.props.bus);
            this.trafficInstrument = new msfsSdk.TrafficInstrument(this.props.bus, {
                simTimeUpdateFreq: 2,
                realTimeUpdateFreq: 1,
                contactDeprecateTime: 10
            });
            this.adsb = new msfsGarminsdk.GarminAdsb(this.props.bus);
            this.adsbPublisher = new GNSAdsbPublisher(this.props.bus);
            this.trafficSystem = new msfsGarminsdk.TrafficAdvisorySystem(this.props.bus, this.trafficInstrument, this.adsb, false);
            this.controlPublisher.startPublish();
            // Flight Planning Items
            this.facLoader = new msfsSdk.FacilityLoader(msfsSdk.FacilityRepository.getRepository(this.props.bus), () => {
                msfsSdk.NearestContext.initialize(this.facLoader, this.props.bus);
                const intersections = msfsSdk.NearestContext.getInstance().intersections;
                intersections.awaitStart().then(() => {
                    intersections.setFilter(msfsSdk.BitFlags.union(msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.None), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Named), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Unnamed), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.Offroute), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.IAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.FAF), msfsSdk.BitFlags.createFlag(msfsSdk.IntersectionType.RNAV)), true);
                });
                setInterval(() => msfsSdk.NearestContext.getInstance().update(), 2000);
            });
            this.calculator = new msfsSdk.FlightPathCalculator(this.facLoader, {
                defaultClimbRate: 1000,
                defaultSpeed: 120,
                bankAngle: 20,
                holdBankAngle: null,
                courseReversalBankAngle: null,
                turnAnticipationBankAngle: null,
                maxBankAngle: 20,
                airplaneSpeedMode: msfsSdk.FlightPathAirplaneSpeedMode.GroundSpeed
            }, this.props.bus);
            this.planner = msfsSdk.FlightPlanner.getPlanner(this.props.bus, this.calculator);
            this.fms = new msfsGarminsdk.Fms(this.isPrimaryInstrument, this.props.bus, this.planner, undefined, undefined, GnsFmsUtils.gnsProcedureLegValid);
            this.navdataComputer = new msfsGarminsdk.NavdataComputer(this.props.bus, this.planner, this.facLoader);
            // Setup nav and control event consumers
            const sub = this.props.bus.getSubscriber();
            sub.on('cdi_src_gps_toggle').handle(this.handleCDISourceToggle.bind(this));
            sub.on('cdi_src_set').handle(v => {
                if (v.type === msfsSdk.NavSourceType.Nav) {
                    this.gnsCdiMode.set(GnsCdiMode.VLOC);
                }
            });
            this.gnsCdiMode.sub(v => {
                this.props.bus.getPublisher().pub('gns_cdi_mode', { navIndex: this.props.options.navIndex, gnsCdiMode: v }, true, true);
            }, true);
            this.isLNavSuspended = msfsSdk.ConsumerSubject.create(sub.on('lnav_is_suspended'), false);
            this.isObsActive = msfsSdk.ConsumerSubject.create(sub.on('gps_obs_active'), false);
            this.isObsAvailable = msfsSdk.ConsumerSubject.create(sub.on('obs_available'), false);
            this.obsMode = msfsSdk.MappedSubject.create(([isLnavSuspended, isObsActive]) => {
                return isObsActive
                    ? msfsGarminsdk.ObsSuspModes.OBS
                    : isLnavSuspended ? msfsGarminsdk.ObsSuspModes.SUSP : msfsGarminsdk.ObsSuspModes.NONE;
            }, this.isLNavSuspended, this.isObsActive);
            // Publish OBS mode on bus
            this.obsMode.sub((mode) => {
                this.props.bus.getPublisher().pub('obs_susp_mode', mode);
            });
            SimVar.SetSimVarValue(`L:${this.props.options.templateId}_SelectedSource`, 'number', 1);
            // Backplane items
            this.props.backplane.addPublisher('adc', this.adcPublisher);
            this.props.backplane.addPublisher('ahrs', this.ahrsPublisher);
            this.props.backplane.addPublisher('gnss', this.gnssPublisher);
            this.props.backplane.addPublisher('navEvents', this.navEventsPublisher);
            this.props.backplane.addPublisher('lnav', this.lNavPublisher);
            this.props.backplane.addPublisher('vnav', this.vNavPublisher);
            this.props.backplane.addPublisher('lnavdata', this.lNavDataPublisher);
            this.props.backplane.addPublisher('vnavdata', this.vNavDataPublisher);
            this.props.backplane.addPublisher('adsb', this.adsbPublisher);
            this.props.backplane.addInstrument('traffic', this.trafficInstrument);
            this.init();
        }
        /**
         * Obtains whether this instrument is the primary instrument
         *
         * @returns a boolean
         */
        get isPrimaryInstrument() {
            return this.props.options.navIndex === 1;
        }
        /** Handle CDI source toggling. */
        handleCDISourceToggle() {
            if (!this.props.options.isUsingNewCdiBehaviour || this.isPrimaryInstrument) {
                this.gnsCdiMode.set(this.gnsCdiMode.get() === GnsCdiMode.GPS ? GnsCdiMode.VLOC : GnsCdiMode.GPS);
            }
        }
        /**
         * Sets up sync of settings to SimVars
         */
        syncSettingsToSimVars() {
            this.settingsProvider.generalSettings.getSetting('com_frequency_spacing').sub((value) => {
                const comSpacingLVarValue = SimVar.GetSimVarValue(`A:COM SPACING MODE:${this.props.options.comIndex}`, 'Enum');
                if (value === msfsSdk.ComSpacing.Spacing833Khz) {
                    if (comSpacingLVarValue === 0) {
                        SimVar.SetSimVarValue(`K:COM_${this.props.options.comIndex}_SPACING_MODE_SWITCH`, 'Boolean', true);
                    }
                }
                else {
                    if (comSpacingLVarValue === 1) {
                        SimVar.SetSimVarValue(`K:COM_${this.props.options.comIndex}_SPACING_MODE_SWITCH`, 'Boolean', true);
                    }
                }
            }, true);
        }
        /**
         * Initializes SBAS group settings sync to the GPS satellite computer system.
         */
        initSbasSettingsSync() {
            const gpsSettings = this.settingsProvider.gps;
            gpsSettings.getSetting('sbas_waas_enabled').sub(enabled => enabled ? this.enabledSbasGroups.add(msfsSdk.SBASGroupName.WAAS) : this.enabledSbasGroups.delete(msfsSdk.SBASGroupName.WAAS));
            gpsSettings.getSetting('sbas_egnos_enabled').sub(enabled => enabled ? this.enabledSbasGroups.add(msfsSdk.SBASGroupName.EGNOS) : this.enabledSbasGroups.delete(msfsSdk.SBASGroupName.EGNOS));
            gpsSettings.getSetting('sbas_gagan_enabled').sub(enabled => enabled ? this.enabledSbasGroups.add(msfsSdk.SBASGroupName.GAGAN) : this.enabledSbasGroups.delete(msfsSdk.SBASGroupName.GAGAN));
            gpsSettings.getSetting('sbas_msas_enabled').sub(enabled => enabled ? this.enabledSbasGroups.add(msfsSdk.SBASGroupName.MSAS) : this.enabledSbasGroups.delete(msfsSdk.SBASGroupName.MSAS));
        }
        /** @inheritdoc */
        onAfterRender() {
            this.comPane.instance.setActive(true);
            this.props.bus.getSubscriber().on('hEvent').handle(this.onInteractionEvent.bind(this));
            this.pageContainer.instance.init();
            this.props.bus.getSubscriber().on('instrument_powered').handle(this.onPowerStateChanged.bind(this));
        }
        /**
         * Handles when the GNS power state is changed.
         * @param state The new power state.
         */
        onPowerStateChanged(state) {
            this.currentPowerState = state;
            if (state === PowerState.OnSkipInit) {
                this.gpsSatComputer.acquireAndUseSatellites();
                this.pageContainer.instance.openPageGroup('NAV', true, 1);
            }
            if (state === PowerState.On) {
                this.pageContainer.instance.openPageGroup('NAV', true, 4);
            }
            if (state === PowerState.Off) {
                this.gpsSatComputer.reset();
            }
        }
        /**
         * Initialization Method.
         */
        init() {
            this.trafficSystem.init();
            this.clock.init();
            this.initSbasSettingsSync();
            if (this.isPrimaryInstrument) {
                this.apRadioNavInstrument = new msfsSdk.APRadioNavInstrument(this.props.bus);
                this.autopilotInstrument = new msfsSdk.AutopilotInstrument(this.props.bus);
                this.gpsSynchronizer = new msfsSdk.GpsSynchronizer(this.props.bus, this.fms.flightPlanner, this.fms.facLoader);
                this.props.backplane.addInstrument('ap', this.autopilotInstrument);
                this.props.backplane.addInstrument('apradionav', this.apRadioNavInstrument);
            }
            this.props.backplane.init();
            this.initFlightPlanAndAp().then();
            // Configure NearestContext based on settings
            msfsSdk.NearestContext.onInitialized(() => {
                const surfaceTypeSetting = this.settingsProvider.generalSettings.getSetting('nearest_airport_criteria_surface_type');
                const minLengthSetting = this.settingsProvider.generalSettings.getSetting('nearest_airport_criteria_min_length');
                msfsSdk.CombinedSubject.create(surfaceTypeSetting, minLengthSetting).sub(([surfaceType, minLength]) => {
                    if (surfaceType !== undefined) {
                        NearestAirportFilter.setSurfaceTypeFilter(surfaceType);
                    }
                    if (minLength !== undefined) {
                        NearestAirportFilter.setMinimumRunwayLength(minLength);
                    }
                });
                msfsSdk.NearestContext.getInstance().intersections.setFilterDupTerminal(true);
                // Sync settings to SimVars
                this.syncSettingsToSimVars();
            });
            this.gpsSatComputer.init();
        }
        /**
         * Initializes the primary flight plan
         */
        async initFlightPlanAndAp() {
            // Request a sync from the FMC in case of an instrument reload
            this.planner.requestSync();
            await msfsSdk.Wait.awaitDelay(500);
            // Initialize the primary plan in case one was not synced
            if (!this.planner.hasFlightPlan(msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX)) {
                await this.fms.initPrimaryFlightPlan();
            }
            else if (this.isPrimaryInstrument) {
                const plan = this.fms.getPrimaryFlightPlan();
                const numSegments = plan.segmentCount;
                if (numSegments === 0) {
                    await this.fms.initPrimaryFlightPlan(true);
                }
            }
            this.primaryFlightPlanInitPromiseResolve();
            // Setup AP
            if (this.isPrimaryInstrument) {
                this.cdiNavSource = new CDINavSource(this.props.bus, this.gnsCdiMode);
                const apConfig = new GNSAPConfig(this.props.bus, this.planner, this.props.options.disableApNavArm, this.props.options.disableApBackCourse, this.props.options.apSupportsFlightDirector);
                this.autopilot = new GNSAutopilot(this.props.bus, this.planner, apConfig, new GNSAPStateManager(this.props.bus, apConfig, this.props.options.apSupportsFlightDirector));
                msfsSdk.Wait.awaitSubscribable(msfsSdk.GameStateProvider.get(), state => state === GameState.briefing || state === GameState.ingame).then(() => {
                    this.props.bus.getSubscriber().on('simTimeHiFreq').handle(() => {
                        this.autopilot.update();
                    });
                });
                setTimeout(() => {
                    this.autopilot.stateManager.initialize();
                }, 500);
                this.props.bus.getPublisher().pub('vnav_set_state', false);
            }
            this.vnavController = new GnsVnavController(this.props.bus, this.fms);
        }
        /**
         * Method to run on flight start.
         */
        onFlightStart() {
            if (this.props.options.navIndex === 1) {
                this.autopilot.stateManager.initialize();
            }
            if (this.isPrimaryInstrument) {
                if (this.gamePlanSynced) {
                    this.fms.activateNearestLeg();
                    return;
                }
                this.initFlightPlanSimSync();
            }
        }
        /**
         * Initializes flight plan sync to and from the sim. This method should only be called once the flight has finished
         * loading (i.e. when the game state is either briefing or ingame).
         */
        async initFlightPlanSimSync() {
            [this.flightPlanSimSyncManager] = await Promise.all([
                msfsGarminsdk.FlightPlanSimSyncManager.getManager(this.props.bus, this.fms),
                this.primaryFlightPlanInitPromise,
                msfsSdk.Wait.awaitDelay(5000) // Ensure we wait at least 5 seconds because trying to load the sim flight plan too early sometimes ends up with missing waypoints.
            ]);
            try {
                await this.flightPlanSimSyncManager.loadFromSim(true);
            }
            catch (e) {
                console.error(e);
                if (e instanceof Error) {
                    console.error(e.stack);
                }
            }
            this.flightPlanSimSyncManager.startAutoSync();
            this.gamePlanSynced = true;
        }
        /**
         * Update loop for the main screen.
         */
        update() {
            var _a, _b;
            const isPrimaryInstrument = this.props.options.navIndex === 1;
            this.clock.onUpdate();
            this.props.backplane.onUpdate();
            if (isPrimaryInstrument) {
                (_a = this.autopilot) === null || _a === void 0 ? void 0 : _a.update();
                // Planner update
                const now = Date.now();
                if (now - this.lastCalculate > 3000) {
                    this.planner.hasFlightPlan(msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX) && this.planner.getFlightPlan(msfsGarminsdk.Fms.PRIMARY_PLAN_INDEX).calculate();
                    // SimVar.SetSimVarValue('K:HEADING_GYRO_SET', SimVarValueType.Number, 0);
                    this.lastCalculate = now;
                }
                this.gpsSynchronizer.update();
            }
            (_b = this.vnavController) === null || _b === void 0 ? void 0 : _b.update();
            if (this.currentPowerState === PowerState.On || this.currentPowerState === PowerState.OnSkipInit) {
                this.gpsSatComputer.onUpdate();
            }
        }

        /**
         * Handles when an interaction event is received by the main screen.
         * @param evt The event that was received.
         */
        onInteractionEvent(evt) {
            const interactionEvent = InteractionEventMap.get(evt);
            if (interactionEvent !== undefined) {
                switch (interactionEvent) {
                    case InteractionEvent.LeftKnobPush:
                        this.isComSelected = !this.isComSelected;
                        if (this.isComSelected) {
                            this.comPane.instance.setActive(true);
                            this.vLocPane.instance.setActive(false);
                            SimVar.SetSimVarValue(`L:${this.props.options.templateId}_SelectedSource`, 'number', 1);
                        }
                        else {
                            this.comPane.instance.setActive(false);
                            this.vLocPane.instance.setActive(true);
                            SimVar.SetSimVarValue(`L:${this.props.options.templateId}_SelectedSource`, 'number', 2);
                        }
                        break;
                    case InteractionEvent.LeftInnerInc:
                        this.changeRadio('FRACT', 'INC');
                        break;
                    case InteractionEvent.LeftInnerDec:
                        this.changeRadio('FRACT', 'DEC');
                        break;
                    case InteractionEvent.LeftOuterInc:
                        this.changeRadio('WHOLE', 'INC');
                        break;
                    case InteractionEvent.LeftOuterDec:
                        this.changeRadio('WHOLE', 'DEC');
                        break;
                    case InteractionEvent.NavSwap:
                        SimVar.SetSimVarValue(`K:NAV${this.props.options.navIndex}_RADIO_SWAP`, 'number', 0);
                        break;
                    case InteractionEvent.ComSwap:
                        SimVar.SetSimVarValue(`K:COM${this.props.options.navIndex}_RADIO_SWAP`, 'number', 0);
                        break;
                    case InteractionEvent.CDI:
                        this.gnsCdiMode.set(this.gnsCdiMode.get() === GnsCdiMode.GPS ? GnsCdiMode.VLOC : GnsCdiMode.GPS);
                        break;
                    case InteractionEvent.OBS: {
                        this.obsPressed();
                        break;
                    }
                    default:
                        if (!this.startupScreen.instance.isBooted()) {
                            this.startupScreen.instance.onInteractionEvent(interactionEvent);
                        }
                        else if (this.selfTest.instance.isActive) {
                            this.selfTest.instance.onInteractionEvent(interactionEvent);
                        }
                        else {
                            this.pageContainer.instance.onInteractionEvent(interactionEvent);
                        }
                        break;
                }
            }
        }
        /**
         * Changes the nav/com radio in the system.
         * @param step The step to use to change the radio.
         * @param direction The direction to move the radio.
         */
        changeRadio(step, direction) {
            if (this.isComSelected) {
                SimVar.SetSimVarValue(`K:COM${this.props.options.comIndex === 1 ? '' : this.props.options.comIndex}_RADIO_${step}_${direction}`, 'number', 0);
            }
            else {
                SimVar.SetSimVarValue(`K:NAV${this.props.options.navIndex}_RADIO_${step}_${direction}`, 'number', 0);
            }
        }
        /**
         * Handles when the OBS button is pressed.
         */
        obsPressed() {
            const obsMode = this.obsMode.get();
            switch (obsMode) {
                case msfsGarminsdk.ObsSuspModes.SUSP:
                    this.controlPublisher.publishEvent('suspend_sequencing', false);
                    break;
                case msfsGarminsdk.ObsSuspModes.OBS:
                    SimVar.SetSimVarValue('K:GPS_OBS_OFF', 'number', 0);
                    this.controlPublisher.publishEvent('suspend_sequencing', false);
                    break;
                default:
                    if (this.isObsAvailable.get()) {
                        SimVar.SetSimVarValue('K:GPS_OBS_ON', 'number', 0);
                    }
                    else {
                        this.props.bus.getPublisher().pub('alerts_push', {
                            key: 'obs-not-available',
                            message: 'OBS not available',
                        });
                    }
            }
        }
        /**
         * Handles when the page is changed.
         * @param index The new page index.
         */
        onPageChanged(index) {
            this.footerBar.instance.onPageChanged(index);
        }
        /**
         * Handles when the page group is changed.
         * @param label The new page group label.
         * @param pages The new page group total number of pages.
         */
        onPageGroupChanged(label, pages) {
            this.footerBar.instance.onPageGroupChanged(label, pages);
        }
        /** @inheritdoc */
        render() {
            return (msfsSdk.FSComponent.buildComponent(msfsSdk.FSComponent.Fragment, null,
                msfsSdk.FSComponent.buildComponent(StartupScreen, { bus: this.props.bus, gnsType: this.props.class, onConfirmed: () => { }, ref: this.startupScreen }),
                msfsSdk.FSComponent.buildComponent(SelfTest, { bus: this.props.bus, gnsType: this.props.class, settingsProvider: this.settingsProvider, navRadioIndex: this.props.options.navIndex, ref: this.selfTest }),
                msfsSdk.FSComponent.buildComponent("div", { class: `${this.props.class} mainscreen-left` },
                    msfsSdk.FSComponent.buildComponent(RadioPane, { bus: this.props.bus, type: msfsSdk.RadioType.Com, index: this.props.options.comIndex, ref: this.comPane }),
                    msfsSdk.FSComponent.buildComponent(RadioPane, { bus: this.props.bus, type: msfsSdk.RadioType.Nav, index: this.props.options.navIndex, ref: this.vLocPane }),
                    this.props.class === 'wt530' ? msfsSdk.FSComponent.buildComponent(NavInfoPane, { bus: this.props.bus, radioIndex: this.props.options.navIndex }) : null,
                    msfsSdk.FSComponent.buildComponent(StatusPane, { bus: this.props.bus })),
                msfsSdk.FSComponent.buildComponent("div", { class: `${this.props.class} mainscreen-right` },
                    msfsSdk.FSComponent.buildComponent(PageContainer, { onPageChanged: this.onPageChanged.bind(this), onPageGroupChanged: this.onPageGroupChanged.bind(this), bus: this.props.bus, ref: this.pageContainer, gnsType: this.props.class, fms: this.fms, settingsProvider: this.settingsProvider, xmlConfig: this.props.xmlConfig, gpsSat: this.gpsSatComputer, trafficSystem: this.trafficSystem, alerts: this.alertsSubject, options: this.props.options })),
                msfsSdk.FSComponent.buildComponent("div", { class: `${this.props.class} mainscreen-footer` },
                    msfsSdk.FSComponent.buildComponent(FooterBar, { ref: this.footerBar, bus: this.props.bus, gnsType: this.props.class, isPrimaryInstrument: this.isPrimaryInstrument, isUsingSplitCDIs: this.props.options.isUsingNewCdiBehaviour, gnsCdiMode: this.gnsCdiMode, instrumentIndex: this.props.options.instrumentIndex, alerts: this.alertsSubject, flightPlanner: this.fms.flightPlanner }))));
        }
    }

    /**
     * A manager for GNS settings.
     */
    class GNSSettingSaveManager extends msfsSdk.UserSettingSaveManager {
        /**
         * Constructor.
         * @param bus The event bus
         */
        constructor(bus) {
            const generalSettingsManager = GeneralUserSettingsManager.getManager(bus);
            const settings = [
                ...new ArcMapFieldsSettingsProvider(bus).getAllSettings(),
                ...generalSettingsManager.getAllSettings(),
                ...new GpsSettingsProvider(bus).getAllSettings(),
                ...new MapSettingsProvider(bus).getAllSettings(),
                ...new StandardNavMapDataFieldsSettingsProvider(bus).getAllSettings(),
                ...new WT430NavInfoFieldsSettingsProvider(bus).getAllSettings()
            ];
            super(settings, bus);
        }
    }

    /// <reference types="@microsoft/msfs-types/Pages/VCockpit/Instruments/Shared/BaseInstrument" />
    /**
     * The base GNS430 instrument.
     */
    class WT430 extends BaseInstrument {
        /**
         * Creates an instance of the WT430.
         */
        constructor() {
            super();
            this.mainScreen = msfsSdk.FSComponent.createRef();
            this.bus = new msfsSdk.EventBus();
            this.hEventPublisher = new msfsSdk.HEventPublisher(this.bus);
            this.navComSimVarPublisher = new msfsSdk.NavComSimVarPublisher(this.bus);
            this.navComInstrument = new msfsSdk.NavComInstrument(this.bus, undefined, 2, 2, false);
            this.options = {
                instrumentIndex: 1,
                eventPrefix: 'AS430',
                templateId: 'AS430',
                navIndex: 1,
                comIndex: 1,
                isUsingNewCdiBehaviour: false,
                disableApNavArm: false,
                apSupportsFlightDirector: false,
                disableApBackCourse: false
            };
            this.isNavigating = false;
            this.baseInstrumentPublisher = new msfsSdk.BaseInstrumentPublisher(this, this.bus);
            this.backplane = new msfsSdk.InstrumentBackplane();
            this.backplane.addPublisher('base', this.baseInstrumentPublisher);
            this.backplane.addPublisher('navcom', this.navComSimVarPublisher);
            this.backplane.addInstrument('navcom', this.navComInstrument);
            this.settingSaveManager = new GNSSettingSaveManager(this.bus);
        }
        /**
         * The instrument template ID.
         * @returns The instrument template ID.
         */
        get templateID() {
            return 'AS430';
        }
        /**
         * Whether or not the instrument is interactive (a touchscreen instrument).
         * @returns True
         */
        get isInteractive() {
            return true;
        }
        /** @inheritdoc */
        connectedCallback() {
            super.connectedCallback();
            // force enable animations
            document.documentElement.classList.add('animationsEnabled');
            this.setOptions();
            msfsSdk.FSComponent.render(msfsSdk.FSComponent.buildComponent(MainScreen, { ref: this.mainScreen, class: 'wt430', bus: this.bus, backplane: this.backplane, options: this.options, xmlConfig: this.xmlConfig }), document.getElementById('InstrumentsContainer'));
            const saveKey = `${SimVar.GetSimVarValue('ATC MODEL', 'string')}.${this.instrumentIdentifier}.${this.options.navIndex}`;
            this.settingSaveManager.load(saveKey);
            this.settingSaveManager.startAutoSave(saveKey);
        }
        /** @inheritdoc */
        Init() {
            super.Init();
            this.hEventPublisher.startPublish();
            SimVar.SetSimVarValue(`L:WT_GNS430_INSTALLED_${this.instrumentIndex}`, msfsSdk.SimVarValueType.Bool, true);
        }
        /** @inheritdoc */
        Update() {
            var _a;
            super.Update();
            (_a = this.mainScreen.getOrDefault()) === null || _a === void 0 ? void 0 : _a.update();
            if (!SimVar.GetSimVarValue('L:XMLVAR_NEXTGEN_FLIGHTPLAN_ENABLED', msfsSdk.SimVarValueType.Bool)) {
                SimVar.SetSimVarValue('L:XMLVAR_NEXTGEN_FLIGHTPLAN_ENABLED', msfsSdk.SimVarValueType.Bool, true);
            }
            if (this.gpsDisabledVar !== undefined) {
                if (SimVar.GetSimVarValue(this.gpsDisabledVar, msfsSdk.SimVarValueType.Bool) === 1 && !this.isNavigating) {
                    window.location.assign(`coui://html_ui/Pages/VCockpit/Core/VCockpit.html?id=${encodeURIComponent(this.gpsDisabledVar)}` +
                        `&guid=${this.getAttribute('Guid')}` +
                        `&instrumentId=${this.instrumentIdentifier}` +
                        `&instrumentIdx=${this.instrumentIndex}` +
                        `&primary=${this.options.navIndex === 1 ? 'true' : 'false'}`);
                    this.isNavigating = true;
                }
            }
        }
        /** @inheritdoc */
        onPowerOn() {
            super.onPowerOn();
            this.bus.getPublisher().pub('instrument_powered', this.wasTurnedOff() ? PowerState.Booting : PowerState.OnSkipInit, false, true);
        }
        /** @inheritdoc */
        onShutDown() {
            super.onShutDown();
            this.bus.getPublisher().pub('instrument_powered', PowerState.Off, false, true);
        }
        /**
         * Gets and Sets the options for this instrument from the panel.xml
         */
        setOptions() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const elements = this.xmlConfig.querySelectorAll('PlaneHTMLConfig > Instrument');
            let nodeIndex = -1;
            if (this.instrumentIndex === 1) {
                const as430NodeIndex = Array.from(elements).findIndex((node) => { var _a; return ((_a = node.querySelector('Name')) === null || _a === void 0 ? void 0 : _a.textContent) === 'AS430'; });
                if (as430NodeIndex === -1) {
                    nodeIndex = Array.from(elements).findIndex((node) => { var _a; return ((_a = node.querySelector('Name')) === null || _a === void 0 ? void 0 : _a.textContent) === 'AS430_1'; });
                }
                else {
                    nodeIndex = as430NodeIndex;
                }
            }
            else if (this.instrumentIndex > 1) {
                nodeIndex = Array.from(elements).findIndex((node) => { var _a; return ((_a = node.querySelector('Name')) === null || _a === void 0 ? void 0 : _a.textContent) === `AS430_${this.instrumentIndex}`; });
            }
            const node = (_a = elements === null || elements === void 0 ? void 0 : elements[nodeIndex]) !== null && _a !== void 0 ? _a : undefined;
            if (node !== undefined) {
                this.options.isUsingNewCdiBehaviour = ((_b = node.querySelector('NewCDIBehavior')) === null || _b === void 0 ? void 0 : _b.textContent) === 'True';
                this.options.comIndex = parseInt((_d = (_c = node.querySelector('ComIndex')) === null || _c === void 0 ? void 0 : _c.textContent) !== null && _d !== void 0 ? _d : '1');
                this.options.navIndex = parseInt((_f = (_e = node.querySelector('NavIndex')) === null || _e === void 0 ? void 0 : _e.textContent) !== null && _f !== void 0 ? _f : '1');
                this.options.disableApNavArm = ((_g = node.querySelector('DisableAPNavArm')) === null || _g === void 0 ? void 0 : _g.textContent) === 'True';
                this.options.apSupportsFlightDirector = ((_h = node.querySelector('SupportAPFlightDirector')) === null || _h === void 0 ? void 0 : _h.textContent) === 'True';
                this.options.disableApBackCourse = ((_j = node.querySelector('DisableAPBackCourse')) === null || _j === void 0 ? void 0 : _j.textContent) === 'True';
            }
            this.options.templateId = this.templateID;
            this.options.instrumentIndex = this.instrumentIndex;
            this.gpsDisabledVar = `L:XMLVAR_GPS_DISABLED_${this.templateID}_${this.instrumentIndex}`;
        }
        /**
         * A callback called when the instrument received a H event.
         * @param args The H event and associated arguments, if any.
         */
        onInteractionEvent(args) {
            // TODO Update our typedefs so we don't have to cast this to any.
            const event = this.DecomposeEventFromPrefix(args);
            if (event !== null) {
                this.hEventPublisher.dispatchHEvent(event);
            }
        }
        /**
         * Callback called when the flight starts.
         */
        onFlightStart() {
            var _a;
            super.onFlightStart();
            (_a = this.mainScreen.getOrDefault()) === null || _a === void 0 ? void 0 : _a.onFlightStart();
        }
    }
    /** Set up the instrument */
    function setup() {
        const searchString = window.location.search.substring(1);
        if (searchString.length > 0) {
            const queryParts = searchString.split('&');
            const disabledVar = decodeURIComponent(queryParts[0].split('=')[1]);
            const guid = decodeURIComponent(queryParts[1].split('=')[1]);
            const instrumentId = decodeURIComponent(queryParts[2].split('=')[1]);
            const instrumentIdx = decodeURIComponent(queryParts[3].split('=')[1]);
            const isPrimary = decodeURIComponent(queryParts[4].split('=')[1]) === 'true' ? true : false;
            let viewListener = undefined;
            let isNavigating = false;
            let initted = false;
            const checkVar = () => {
                try {
                    if (RegisterViewListener !== undefined && SimVar !== undefined && !isNavigating) {
                        if (viewListener === undefined) {
                            viewListener = RegisterViewListener('JS_LISTENER_INSTRUMENTS');
                        }
                        if (viewListener !== undefined) {
                            const isDisabled = SimVar.GetSimVarValue(disabledVar, 'number');
                            if (!initted) {
                                if (isPrimary) {
                                    SimVar.SetSimVarValue('GPS OVERRIDDEN', msfsSdk.SimVarValueType.Bool, false);
                                    SimVar.SetSimVarValue('K:AP_AVIONICS_MANAGED_OFF', msfsSdk.SimVarValueType.Bool, true);
                                    SimVar.SetSimVarValue('L:WT1000_AP_G1000_INSTALLED', msfsSdk.SimVarValueType.Bool, false);
                                }
                                SimVar.SetSimVarValue(`L:WT_GNS430_INSTALLED_${instrumentIdx}`, msfsSdk.SimVarValueType.Bool, false);
                                SimVar.SetSimVarValue('L:XMLVAR_NEXTGEN_FLIGHTPLAN_ENABLED', msfsSdk.SimVarValueType.Bool, false);
                                LaunchFlowEvent('ON_VCOCKPIT_INSTRUMENT_INITIALIZED', guid, instrumentId, false, false);
                                initted = true;
                            }
                            if (isDisabled !== null && isDisabled !== 1) {
                                window.location.assign('coui://html_ui/Pages/VCockpit/Core/VCockpit.html');
                                isNavigating = true;
                            }
                        }
                    }
                }
                catch (err) {
                    // noop
                }
                requestAnimationFrame(checkVar);
            };
            requestAnimationFrame(checkVar);
        }
        else {
            registerInstrument('wt-gns430', WT430);
        }
    }
    setup();

})(msfssdk, garminsdk);
